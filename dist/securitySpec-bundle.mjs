const e={origin:new URL(import.meta.url).origin,async store(e,t,a){let r=await this.Security.verify(a,{team:t,notBefore:"team"});if(!r)throw new Error(`Signature ${a} does not match owner of ${t}.`);return r.payload.length?this[e][t]=a:delete this[e][t],null},async retrieve(e,t){return this[e][t]},Team:{},KeyRecovery:{},EncryptionKey:{}};const t=location.origin;function a(e,a){return`${t}/db/${e}/${a}.json`}async function r(e){if(404===e.status)return"";if(!e.ok)return Promise.reject(e.statusText);let t=await e.text();return t?JSON.parse(t):t}const i={get origin(){return t},store:(e,t,i)=>fetch(a(e,t),{method:"PUT",body:JSON.stringify(i),headers:{"Content-Type":"application/json"}}).then(r),retrieve:(e,t)=>fetch(a(e,t),{cache:"default",headers:{Accept:"application/json"}}).then(r)};var n=e=>e;function c(e,t){return t?e+n(t):e}"undefined"!=typeof window&&(n=window.prompt);const o=new URL(import.meta.url),s=new URL("vault-bundle.mjs",o),d=document.createElement("iframe"),y=new MessageChannel,p=Object.assign({log(...e){console.log(...e)},getUserDeviceSecret:c},i),l=new Promise((e=>{p.ready=e,d.style.display="none",document.body.append(d),d.setAttribute("srcdoc",`<!DOCTYPE html><html><body><script type="module" src="${s.href}"><\/script></body></html>`),d.contentWindow.name="vault!"+o.href,y.port1.start(),d.onload=()=>d.contentWindow.postMessage("initializePort",s.origin,[y.port2])})),u=function({target:e=self,receiver:t=e,namespace:a=t,origin:r=e!==t&&e.location.origin,dispatcherLabel:i=a.name||t.name||t.location?.href||t,targetLabel:n=e.name||r||e.location?.href||e,log:c=null,info:o=console.info.bind(console),warn:s=console.warn.bind(console),error:d=console.error.bind(console)}){const y={},p="2.0",l=e.postMessage.bind(e),u=r?e=>l(e,r):l;let w=0;return t.addEventListener("message",(async function(t){c?.(i,"got message",t.data,"from",n,t.origin);let{id:o,method:l,params:w=[],result:h,error:f,jsonrpc:g}=t.data||{};if(t.source&&t.source!==e)return d?.(i,"to",n,"got message from",t.source);if(r&&r!==t.origin)return d?.(i,r,"mismatched origin",n,t.origin);if(g!==p)return s?.(`${i} ignoring non-jsonrpc message ${JSON.stringify(t.data)}.`);if(l){let e,t=null,r=Array.isArray(w)?w:[w];try{e=await a[l](...r)}catch(e){t=function(e){let{name:t,message:a,code:r,data:i}=e;return{name:t,message:a,code:r,data:i}}(e),a[l]||t.message.includes(l)?t.message||(t.message=`${t.name||t.toString()} in ${l}.`):(t.message=`${l} is not defined.`,t.code=-32601)}if(void 0===o)return;let s=t?{id:o,error:t,jsonrpc:p}:{id:o,result:e,jsonrpc:p};return c?.(i,"answering",o,t||e,"to",n),u(s)}let m=y[o];if(delete y[o],!m)return s?.(`${i} ignoring response ${t.data}.`);f?m.reject(f):m.resolve(h)})),o?.(`${i} will dispatch to ${n}`),function(e,...t){let a=++w,r=y[a]={};return new Promise(((o,s)=>{c?.(i,"request",a,e,t,"to",n),Object.assign(r,{resolve:o,reject:s}),u({id:a,method:e,params:t,jsonrpc:p})}))}}({dispatcherLabel:"entry!"+o.href,namespace:p,target:y.port1,targetLabel:d.contentWindow.name}),w={sign:(e,...t)=>u("sign",e,...t),verify:(e,...t)=>u("verify",e,...t),encrypt:(e,...t)=>u("encrypt",e,...t),decrypt:(e,...t)=>u("decrypt",e,...t),create:(...e)=>u("create",...e),changeMembership:({tag:e,add:t,remove:a}={})=>u("changeMembership",{tag:e,add:t,remove:a}),destroy:e=>u("destroy",e),clear:(e=null)=>u("clear",e),ready:l,get Storage(){return p},set Storage(e){Object.assign(p,e)},set getUserDeviceSecret(e){p.getUserDeviceSecret=e}},h=10485760;function f(e=h){return Array.from({length:e},((e,t)=>1&t)).join("")}const g=/^[A-Za-z0-9_\-.]+$/;function m(e,t=g){expect(t.test(e)).toBeTruthy()}function b(e,t){expect(new Uint8Array(e.payload)).toEqual(t)}function v(e,t=446){const a=15e3,r=t>1e3?a:5e3,i=f();describe("signing",(function(){let t;beforeAll((async function(){t=await e.generateSigningKey()})),it("with a private key produces a base64URL signature that verifies with the public key.",(async function(){let a=await e.sign(t.privateKey,i);m(a),expect(await e.verify(t.publicKey,a)).toBeTruthy()})),it("returns undefined for verify with the wrong key.",(async function(){let a=await e.sign(t.privateKey,i),r=await e.generateSigningKey();expect(await e.verify(r.publicKey,a)).toBeUndefined()})),it("handles binary, and verifies with that as payload property.",(async function(){let a=new Uint8Array([21,31]),r=await e.sign(t.privateKey,a),i=await e.verify(t.publicKey,r);expect(i.cty).toBeUndefined(),b(i,a)})),it('handles text, setting cty as "text/plain", and verifies with that as the text property and an encoding of that for payload.',(async function(){let a=await e.sign(t.privateKey,i),r=await e.verify(t.publicKey,a);expect(r.protectedHeader.cty).toBe("text/plain"),expect(r.text).toBe(i),expect(r.payload).toEqual((new TextEncoder).encode(i))})),it('handles json, setting cty as "json", and verifies with that as json property, the string of that as the text property, and the encoding of that string for payload.',(async function(){let a={foo:"bar"},r=await e.sign(t.privateKey,a),i=await e.verify(t.publicKey,r);expect(i.protectedHeader.cty).toBe("json"),expect(i.json).toEqual(a),expect(i.text).toBe(JSON.stringify(a)),expect(i.payload).toEqual((new TextEncoder).encode(JSON.stringify(a)))})),it("Uses specified headers if supplied, including cty.",(async function(){let a="text/html",r=Date.now(),i="<something else>",n=await e.sign(t.privateKey,i,{cty:a,iat:r,foo:17}),c=await e.verify(t.publicKey,n);expect(c.protectedHeader.cty).toBe(a),expect(c.protectedHeader.iat).toBe(r),expect(c.protectedHeader.foo).toBe(17),expect(c.text).toEqual(i)}))})),describe("encryption",(function(){let n;function c(t,a,r=a){it(`can work on much larger data with a ${t}.`,(async function(){let t=await a,n=await r,c=await e.encrypt(t,i),o=await e.decrypt(n,c);m(c),expect(o.text).toBe(i)}))}function o(r,i){it(`rejects wrong ${r}.`,(async function(){let[a,r]=await i(),n=f(t),c=await e.encrypt(a,n);await expectAsync(e.decrypt(r,c)).toBeRejected()}),a)}beforeAll((async function(){n=await e.generateEncryptingKey()})),it(`can work up through at least ${t} bytes with an asymmetric keypair.`,(async function(){let a=f(t),r=await e.encrypt(n.publicKey,a),i=await e.decrypt(n.privateKey,r);m(r),expect(i.text).toBe(a)}),r),c("fixed symmetric key",e.generateSymmetricKey()),c("reproducible secret",e.generateSymmetricKey("secret"),e.generateSymmetricKey("secret")),it("handles binary, and decrypts as same.",(async function(){let t=new Uint8Array([21,31]),a=await e.encrypt(n.publicKey,t),r=await e.decrypt(n.privateKey,a),i=e.decodeProtectedHeader(a);expect(i.cty).toBeUndefined(),b(r,t)})),it("handles text, and decrypts as same.",(async function(){let t=await e.encrypt(n.publicKey,i),a=await e.decrypt(n.privateKey,t),r=e.decodeProtectedHeader(t);expect(r.cty).toBe("text/plain"),expect(a.text).toBe(i)})),it("handles json, and decrypts as same.",(async function(){let t={foo:"bar"},a=await e.encrypt(n.publicKey,t),r=e.decodeProtectedHeader(a),i=await e.decrypt(n.privateKey,a);expect(r.cty).toBe("json"),expect(i.json).toEqual(t)})),it("Uses specified headers if supplied, including cty.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await e.encrypt(n.publicKey,r,{cty:t,iat:a,foo:17}),c=await e.decrypt(n.privateKey,i),o=e.decodeProtectedHeader(i);expect(o.cty).toBe(t),expect(o.iat).toBe(a),expect(o.foo).toBe(17),expect(c.text).toBe(r)})),o("asymmetric key",(async()=>[(await e.generateEncryptingKey()).publicKey,(await e.generateEncryptingKey()).privateKey])),o("symmetric key",(async()=>[await e.generateSymmetricKey(),await e.generateSymmetricKey()])),o("secret",(async()=>[await e.generateSymmetricKey("secret"),await e.generateSymmetricKey("secretX")]))})),describe("export/import",(function(){async function t(t){return JSON.stringify(await e.exportJWK(t))}function a(t){return e.importJWK(JSON.parse(t))}describe("of signing keys",(function(){it("works with the private signing key as a 253 byte serialization.",(async function(){let r=await e.generateSigningKey(),n=await t(r.privateKey),c=await a(n),o=await e.sign(c,i);expect(n.length).toBe(253),expect(await e.verify(r.publicKey,o)).toBeTruthy()}));it("works with the public verifying key as a 182 byte serialization.",(async function(){let r=await e.generateSigningKey(),n=await t(r.publicKey),c=await a(n),o=await e.sign(r.privateKey,i);expect(n.length).toBe(182),expect(await e.verify(c,o)).toBeTruthy()}));it("works with public key as a raw verifying key as a base64URL serialization of no more that 132 bytes",(async function(){let t=await e.generateSigningKey(),a=await e.exportRaw(t.publicKey),r=await e.importRaw(a),n=await e.sign(t.privateKey,i);m(a),expect(a.length).toBeLessThanOrEqual(132),expect(await e.verify(r,n)).toBeTruthy()}))})),describe("of encryption keys",(function(){const r=[3169,3173];it(`works with the private key as a ${r[0]}-${r[1]} byte serialization.`,(async function(){let i=await e.generateEncryptingKey(),n=await t(i.privateKey),c=await a(n),o=f(446),s=await e.encrypt(i.publicKey,o),d=await e.decrypt(c,s);expect(n.length).toBeGreaterThanOrEqual(r[0]),expect(n.length).toBeLessThanOrEqual(r[1]),expect(d.text).toBe(o)}));it("works with the public key as a 735 byte serialization.",(async function(){let r=await e.generateEncryptingKey(),i=await t(r.publicKey),n=await a(i),c=f(446),o=await e.encrypt(n,c),s=await e.decrypt(r.privateKey,o);expect(i.length).toBe(735),expect(s.text).toBe(c)}))})),describe("of symmetric key",(function(){it("works as a 79 byte serialization.",(async function(){let r=await e.generateSymmetricKey(),n=await t(r),c=await a(n),o=await e.encrypt(r,i),s=await e.decrypt(c,o);expect(n.length).toBe(79),expect(s.text).toBe(i)}))}))})),it("wraps like export+encrypt.",(async function(){let t=await e.generateSymmetricKey(),a=await e.generateEncryptingKey(),r=await e.exportJWK(t),i=await e.encrypt(a.publicKey,r),n=await e.decrypt(a.privateKey,i),c=await e.importJWK(n.json),o=await e.wrapKey(t,a.publicKey),s=await e.unwrapKey(o,a.privateKey),d="this is a message",y=await e.encrypt(s,d),p=await e.decrypt(c,y);m(o),expect(p.text).toBe(d)}),a)}var E=crypto;const S=e=>e instanceof CryptoKey,x=async(e,t)=>{const a=`SHA-${e.slice(-3)}`;return new Uint8Array(await E.subtle.digest(a,t))},K=new TextEncoder,A=new TextDecoder,H=2**32;function B(...e){const t=e.reduce(((e,{length:t})=>e+t),0),a=new Uint8Array(t);let r=0;for(const t of e)a.set(t,r),r+=t.length;return a}function P(e,t,a){if(t<0||t>=H)throw new RangeError(`value must be >= 0 and <= ${H-1}. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,255&t],a)}function k(e){const t=Math.floor(e/H),a=e%H,r=new Uint8Array(8);return P(r,t,0),P(r,a,4),r}function C(e){const t=new Uint8Array(4);return P(t,e),t}function T(e){return B(C(e.length),e)}const U=e=>(e=>{let t=e;"string"==typeof t&&(t=K.encode(t));const a=[];for(let e=0;e<t.length;e+=32768)a.push(String.fromCharCode.apply(null,t.subarray(e,e+32768)));return btoa(a.join(""))})(e).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),W=e=>{let t=e;t instanceof Uint8Array&&(t=A.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return(e=>{const t=atob(e),a=new Uint8Array(t.length);for(let e=0;e<t.length;e++)a[e]=t.charCodeAt(e);return a})(t)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}};class _ extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(e){super(e),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,Error.captureStackTrace?.(this,this.constructor)}}class J extends _{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class D extends _{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class R extends _{constructor(){super(...arguments),this.code="ERR_JWE_DECRYPTION_FAILED",this.message="decryption operation failed"}static get code(){return"ERR_JWE_DECRYPTION_FAILED"}}class j extends _{constructor(){super(...arguments),this.code="ERR_JWE_INVALID"}static get code(){return"ERR_JWE_INVALID"}}class O extends _{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class M extends _{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}var I=E.getRandomValues.bind(E);function $(e){switch(e){case"A128GCM":case"A128GCMKW":case"A192GCM":case"A192GCMKW":case"A256GCM":case"A256GCMKW":return 96;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return 128;default:throw new D(`Unsupported JWE Algorithm: ${e}`)}}const G=(e,t)=>{if(t.length<<3!==$(e))throw new j("Invalid Initialization Vector length")},L=(e,t)=>{const a=e.byteLength<<3;if(a!==t)throw new j(`Invalid Content Encryption Key length. Expected ${t} bits, got ${a} bits`)};function N(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function F(e,t){return e.name===t}function z(e){return parseInt(e.name.slice(4),10)}function q(e,t){if(t.length&&!t.some((t=>e.usages.includes(t)))){let e="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const a=t.pop();e+=`one of ${t.join(", ")}, or ${a}.`}else 2===t.length?e+=`one of ${t[0]} or ${t[1]}.`:e+=`${t[0]}.`;throw new TypeError(e)}}function V(e,t,...a){switch(t){case"HS256":case"HS384":case"HS512":{if(!F(e.algorithm,"HMAC"))throw N("HMAC");const a=parseInt(t.slice(2),10);if(z(e.algorithm.hash)!==a)throw N(`SHA-${a}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!F(e.algorithm,"RSASSA-PKCS1-v1_5"))throw N("RSASSA-PKCS1-v1_5");const a=parseInt(t.slice(2),10);if(z(e.algorithm.hash)!==a)throw N(`SHA-${a}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!F(e.algorithm,"RSA-PSS"))throw N("RSA-PSS");const a=parseInt(t.slice(2),10);if(z(e.algorithm.hash)!==a)throw N(`SHA-${a}`,"algorithm.hash");break}case"EdDSA":if("Ed25519"!==e.algorithm.name&&"Ed448"!==e.algorithm.name)throw N("Ed25519 or Ed448");break;case"ES256":case"ES384":case"ES512":{if(!F(e.algorithm,"ECDSA"))throw N("ECDSA");const a=function(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}(t);if(e.algorithm.namedCurve!==a)throw N(a,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}q(e,a)}function X(e,t,...a){switch(t){case"A128GCM":case"A192GCM":case"A256GCM":{if(!F(e.algorithm,"AES-GCM"))throw N("AES-GCM");const a=parseInt(t.slice(1,4),10);if(e.algorithm.length!==a)throw N(a,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!F(e.algorithm,"AES-KW"))throw N("AES-KW");const a=parseInt(t.slice(1,4),10);if(e.algorithm.length!==a)throw N(a,"algorithm.length");break}case"ECDH":switch(e.algorithm.name){case"ECDH":case"X25519":case"X448":break;default:throw N("ECDH, X25519, or X448")}break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!F(e.algorithm,"PBKDF2"))throw N("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!F(e.algorithm,"RSA-OAEP"))throw N("RSA-OAEP");const a=parseInt(t.slice(9),10)||1;if(z(e.algorithm.hash)!==a)throw N(`SHA-${a}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}q(e,a)}function Y(e,t,...a){if(a.length>2){const t=a.pop();e+=`one of type ${a.join(", ")}, or ${t}.`}else 2===a.length?e+=`one of type ${a[0]} or ${a[1]}.`:e+=`of type ${a[0]}.`;return null==t?e+=` Received ${t}`:"function"==typeof t&&t.name?e+=` Received function ${t.name}`:"object"==typeof t&&null!=t&&t.constructor?.name&&(e+=` Received an instance of ${t.constructor.name}`),e}var Z=(e,...t)=>Y("Key must be ",e,...t);function Q(e,t,...a){return Y(`Key for the ${e} algorithm must be `,t,...a)}var ee=e=>S(e);const te=["CryptoKey"];async function ae(e,t,a,r,i,n){if(!(t instanceof Uint8Array))throw new TypeError(Z(t,"Uint8Array"));const c=parseInt(e.slice(1,4),10),o=await E.subtle.importKey("raw",t.subarray(c>>3),"AES-CBC",!1,["decrypt"]),s=await E.subtle.importKey("raw",t.subarray(0,c>>3),{hash:"SHA-"+(c<<1),name:"HMAC"},!1,["sign"]),d=B(n,r,a,k(n.length<<3)),y=new Uint8Array((await E.subtle.sign("HMAC",s,d)).slice(0,c>>3));let p,l;try{p=((e,t)=>{if(!(e instanceof Uint8Array))throw new TypeError("First argument must be a buffer");if(!(t instanceof Uint8Array))throw new TypeError("Second argument must be a buffer");if(e.length!==t.length)throw new TypeError("Input buffers must have the same length");const a=e.length;let r=0,i=-1;for(;++i<a;)r|=e[i]^t[i];return 0===r})(i,y)}catch{}if(!p)throw new R;try{l=new Uint8Array(await E.subtle.decrypt({iv:r,name:"AES-CBC"},o,a))}catch{}if(!l)throw new R;return l}const re=async(e,t,a,r,i,n)=>{if(!(S(t)||t instanceof Uint8Array))throw new TypeError(Z(t,...te,"Uint8Array"));if(!r)throw new j("JWE Initialization Vector missing");if(!i)throw new j("JWE Authentication Tag missing");switch(G(e,r),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return t instanceof Uint8Array&&L(t,parseInt(e.slice(-3),10)),ae(e,t,a,r,i,n);case"A128GCM":case"A192GCM":case"A256GCM":return t instanceof Uint8Array&&L(t,parseInt(e.slice(1,4),10)),async function(e,t,a,r,i,n){let c;t instanceof Uint8Array?c=await E.subtle.importKey("raw",t,"AES-GCM",!1,["decrypt"]):(X(t,e,"decrypt"),c=t);try{return new Uint8Array(await E.subtle.decrypt({additionalData:n,iv:r,name:"AES-GCM",tagLength:128},c,B(a,i)))}catch{throw new R}}(e,t,a,r,i,n);default:throw new D("Unsupported JWE Content Encryption Algorithm")}},ie=(...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let a;for(const e of t){const t=Object.keys(e);if(a&&0!==a.size)for(const e of t){if(a.has(e))return!1;a.add(e)}else a=new Set(t)}return!0};function ne(e){if("object"!=typeof(t=e)||null===t||"[object Object]"!==Object.prototype.toString.call(e))return!1;var t;if(null===Object.getPrototypeOf(e))return!0;let a=e;for(;null!==Object.getPrototypeOf(a);)a=Object.getPrototypeOf(a);return Object.getPrototypeOf(e)===a}const ce=[{hash:"SHA-256",name:"HMAC"},!0,["sign"]];function oe(e,t){if(e.algorithm.length!==parseInt(t.slice(1,4),10))throw new TypeError(`Invalid key size for alg: ${t}`)}function se(e,t,a){if(S(e))return X(e,t,a),e;if(e instanceof Uint8Array)return E.subtle.importKey("raw",e,"AES-KW",!0,[a]);throw new TypeError(Z(e,...te,"Uint8Array"))}const de=async(e,t,a)=>{const r=await se(t,e,"wrapKey");oe(r,e);const i=await E.subtle.importKey("raw",a,...ce);return new Uint8Array(await E.subtle.wrapKey("raw",i,r,"AES-KW"))},ye=async(e,t,a)=>{const r=await se(t,e,"unwrapKey");oe(r,e);const i=await E.subtle.unwrapKey("raw",a,r,"AES-KW",...ce);return new Uint8Array(await E.subtle.exportKey("raw",i))};async function pe(e,t,a,r,i=new Uint8Array(0),n=new Uint8Array(0)){if(!S(e))throw new TypeError(Z(e,...te));if(X(e,"ECDH"),!S(t))throw new TypeError(Z(t,...te));X(t,"ECDH","deriveBits");const c=B(T(K.encode(a)),T(i),T(n),C(r));let o;o="X25519"===e.algorithm.name?256:"X448"===e.algorithm.name?448:Math.ceil(parseInt(e.algorithm.namedCurve.substr(-3),10)/8)<<3;return async function(e,t,a){const r=Math.ceil((t>>3)/32),i=new Uint8Array(32*r);for(let t=0;t<r;t++){const r=new Uint8Array(4+e.length+a.length);r.set(C(t+1)),r.set(e,4),r.set(a,4+e.length),i.set(await x("sha256",r),32*t)}return i.slice(0,t>>3)}(new Uint8Array(await E.subtle.deriveBits({name:e.algorithm.name,public:e},t,o)),r,c)}function le(e){if(!S(e))throw new TypeError(Z(e,...te));return["P-256","P-384","P-521"].includes(e.algorithm.namedCurve)||"X25519"===e.algorithm.name||"X448"===e.algorithm.name}async function ue(e,t,a,r){!function(e){if(!(e instanceof Uint8Array)||e.length<8)throw new j("PBES2 Salt Input must be 8 or more octets")}(e);const i=function(e,t){return B(K.encode(e),new Uint8Array([0]),t)}(t,e),n=parseInt(t.slice(13,16),10),c={hash:`SHA-${t.slice(8,11)}`,iterations:a,name:"PBKDF2",salt:i},o={length:n,name:"AES-KW"},s=await function(e,t){if(e instanceof Uint8Array)return E.subtle.importKey("raw",e,"PBKDF2",!1,["deriveBits"]);if(S(e))return X(e,t,"deriveBits","deriveKey"),e;throw new TypeError(Z(e,...te,"Uint8Array"))}(r,t);if(s.usages.includes("deriveBits"))return new Uint8Array(await E.subtle.deriveBits(c,s,n));if(s.usages.includes("deriveKey"))return E.subtle.deriveKey(c,s,o,!1,["wrapKey","unwrapKey"]);throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"')}const we=async(e,t,a,r,i)=>{const n=await ue(i,e,r,t);return ye(e.slice(-6),n,a)};function he(e){switch(e){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return"RSA-OAEP";default:throw new D(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}var fe=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:a}=t.algorithm;if("number"!=typeof a||a<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};const ge=async(e,t,a)=>{if(!S(t))throw new TypeError(Z(t,...te));if(X(t,e,"decrypt","unwrapKey"),fe(e,t),t.usages.includes("decrypt"))return new Uint8Array(await E.subtle.decrypt(he(e),t,a));if(t.usages.includes("unwrapKey")){const r=await E.subtle.unwrapKey("raw",a,t,he(e),...ce);return new Uint8Array(await E.subtle.exportKey("raw",r))}throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation')};function me(e){switch(e){case"A128GCM":return 128;case"A192GCM":return 192;case"A256GCM":case"A128CBC-HS256":return 256;case"A192CBC-HS384":return 384;case"A256CBC-HS512":return 512;default:throw new D(`Unsupported JWE Algorithm: ${e}`)}}var be=e=>I(new Uint8Array(me(e)>>3));var ve=async e=>{if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:t,keyUsages:a}=function(e){let t,a;switch(e.kty){case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},a=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},a=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},a=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new D('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},a=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},a=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},a=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},a=e.d?["deriveBits"]:[];break;default:throw new D('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"OKP":switch(e.alg){case"EdDSA":t={name:e.crv},a=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},a=e.d?["deriveBits"]:[];break;default:throw new D('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;default:throw new D('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:a}}(e),r=[t,e.ext??!1,e.key_ops??a],i={...e};return delete i.alg,delete i.use,E.subtle.importKey("jwk",i,...r)};async function Ee(e,t){if(!ne(e))throw new TypeError("JWK must be an object");switch(t||(t=e.alg),e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return W(e.k);case"RSA":if(void 0!==e.oth)throw new D('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return ve({...e,alg:t});default:throw new D('Unsupported "kty" (Key Type) Parameter value')}}const Se=(e,t,a)=>{e.startsWith("HS")||"dir"===e||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e)?((e,t)=>{if(!(t instanceof Uint8Array)){if(!ee(t))throw new TypeError(Q(e,t,...te,"Uint8Array"));if("secret"!==t.type)throw new TypeError(`${te.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}})(e,t):((e,t,a)=>{if(!ee(t))throw new TypeError(Q(e,t,...te));if("secret"===t.type)throw new TypeError(`${te.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===a&&"public"===t.type)throw new TypeError(`${te.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===a&&"public"===t.type)throw new TypeError(`${te.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(t.algorithm&&"verify"===a&&"private"===t.type)throw new TypeError(`${te.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(t.algorithm&&"encrypt"===a&&"private"===t.type)throw new TypeError(`${te.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)})(e,t,a)};const xe=async(e,t,a,r,i)=>{if(!(S(a)||a instanceof Uint8Array))throw new TypeError(Z(a,...te,"Uint8Array"));switch(r?G(e,r):r=I(new Uint8Array($(e)>>3)),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return a instanceof Uint8Array&&L(a,parseInt(e.slice(-3),10)),async function(e,t,a,r,i){if(!(a instanceof Uint8Array))throw new TypeError(Z(a,"Uint8Array"));const n=parseInt(e.slice(1,4),10),c=await E.subtle.importKey("raw",a.subarray(n>>3),"AES-CBC",!1,["encrypt"]),o=await E.subtle.importKey("raw",a.subarray(0,n>>3),{hash:"SHA-"+(n<<1),name:"HMAC"},!1,["sign"]),s=new Uint8Array(await E.subtle.encrypt({iv:r,name:"AES-CBC"},c,t)),d=B(i,r,s,k(i.length<<3));return{ciphertext:s,tag:new Uint8Array((await E.subtle.sign("HMAC",o,d)).slice(0,n>>3)),iv:r}}(e,t,a,r,i);case"A128GCM":case"A192GCM":case"A256GCM":return a instanceof Uint8Array&&L(a,parseInt(e.slice(1,4),10)),async function(e,t,a,r,i){let n;a instanceof Uint8Array?n=await E.subtle.importKey("raw",a,"AES-GCM",!1,["encrypt"]):(X(a,e,"encrypt"),n=a);const c=new Uint8Array(await E.subtle.encrypt({additionalData:i,iv:r,name:"AES-GCM",tagLength:128},n,t)),o=c.slice(-16);return{ciphertext:c.slice(0,-16),tag:o,iv:r}}(e,t,a,r,i);default:throw new D("Unsupported JWE Content Encryption Algorithm")}};async function Ke(e,t,a,r,i){switch(Se(e,t,"decrypt"),e){case"dir":if(void 0!==a)throw new j("Encountered unexpected JWE Encrypted Key");return t;case"ECDH-ES":if(void 0!==a)throw new j("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!ne(r.epk))throw new j('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(!le(t))throw new D("ECDH with the provided key is not allowed or not supported by your javascript runtime");const i=await Ee(r.epk,e);let n,c;if(void 0!==r.apu){if("string"!=typeof r.apu)throw new j('JOSE Header "apu" (Agreement PartyUInfo) invalid');try{n=W(r.apu)}catch{throw new j("Failed to base64url decode the apu")}}if(void 0!==r.apv){if("string"!=typeof r.apv)throw new j('JOSE Header "apv" (Agreement PartyVInfo) invalid');try{c=W(r.apv)}catch{throw new j("Failed to base64url decode the apv")}}const o=await pe(i,t,"ECDH-ES"===e?r.enc:e,"ECDH-ES"===e?me(r.enc):parseInt(e.slice(-5,-2),10),n,c);if("ECDH-ES"===e)return o;if(void 0===a)throw new j("JWE Encrypted Key missing");return ye(e.slice(-6),o,a)}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":if(void 0===a)throw new j("JWE Encrypted Key missing");return ge(e,t,a);case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{if(void 0===a)throw new j("JWE Encrypted Key missing");if("number"!=typeof r.p2c)throw new j('JOSE Header "p2c" (PBES2 Count) missing or invalid');const n=i?.maxPBES2Count||1e4;if(r.p2c>n)throw new j('JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds');if("string"!=typeof r.p2s)throw new j('JOSE Header "p2s" (PBES2 Salt) missing or invalid');let c;try{c=W(r.p2s)}catch{throw new j("Failed to base64url decode the p2s")}return we(e,t,a,r.p2c,c)}case"A128KW":case"A192KW":case"A256KW":if(void 0===a)throw new j("JWE Encrypted Key missing");return ye(e,t,a);case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{if(void 0===a)throw new j("JWE Encrypted Key missing");if("string"!=typeof r.iv)throw new j('JOSE Header "iv" (Initialization Vector) missing or invalid');if("string"!=typeof r.tag)throw new j('JOSE Header "tag" (Authentication Tag) missing or invalid');let i,n;try{i=W(r.iv)}catch{throw new j("Failed to base64url decode the iv")}try{n=W(r.tag)}catch{throw new j("Failed to base64url decode the tag")}return async function(e,t,a,r,i){const n=e.slice(0,7);return re(n,t,a,r,i,new Uint8Array(0))}(e,t,a,i,n)}default:throw new D('Invalid or unsupported "alg" (JWE Algorithm) header value')}}function Ae(e,t,a,r,i){if(void 0!==i.crit&&void 0===r?.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!r||void 0===r.crit)return new Set;if(!Array.isArray(r.crit)||0===r.crit.length||r.crit.some((e=>"string"!=typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let n;n=void 0!==a?new Map([...Object.entries(a),...t.entries()]):t;for(const t of r.crit){if(!n.has(t))throw new D(`Extension Header Parameter "${t}" is not recognized`);if(void 0===i[t])throw new e(`Extension Header Parameter "${t}" is missing`);if(n.get(t)&&void 0===r[t])throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}return new Set(r.crit)}const He=(e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some((e=>"string"!=typeof e))))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};async function Be(e,t,a){if(!ne(e))throw new j("Flattened JWE must be an object");if(void 0===e.protected&&void 0===e.header&&void 0===e.unprotected)throw new j("JOSE Header missing");if(void 0!==e.iv&&"string"!=typeof e.iv)throw new j("JWE Initialization Vector incorrect type");if("string"!=typeof e.ciphertext)throw new j("JWE Ciphertext missing or incorrect type");if(void 0!==e.tag&&"string"!=typeof e.tag)throw new j("JWE Authentication Tag incorrect type");if(void 0!==e.protected&&"string"!=typeof e.protected)throw new j("JWE Protected Header incorrect type");if(void 0!==e.encrypted_key&&"string"!=typeof e.encrypted_key)throw new j("JWE Encrypted Key incorrect type");if(void 0!==e.aad&&"string"!=typeof e.aad)throw new j("JWE AAD incorrect type");if(void 0!==e.header&&!ne(e.header))throw new j("JWE Shared Unprotected Header incorrect type");if(void 0!==e.unprotected&&!ne(e.unprotected))throw new j("JWE Per-Recipient Unprotected Header incorrect type");let r;if(e.protected)try{const t=W(e.protected);r=JSON.parse(A.decode(t))}catch{throw new j("JWE Protected Header is invalid")}if(!ie(r,e.header,e.unprotected))throw new j("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");const i={...r,...e.header,...e.unprotected};if(Ae(j,new Map,a?.crit,r,i),void 0!==i.zip)throw new D('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');const{alg:n,enc:c}=i;if("string"!=typeof n||!n)throw new j("missing JWE Algorithm (alg) in JWE Header");if("string"!=typeof c||!c)throw new j("missing JWE Encryption Algorithm (enc) in JWE Header");const o=a&&He("keyManagementAlgorithms",a.keyManagementAlgorithms),s=a&&He("contentEncryptionAlgorithms",a.contentEncryptionAlgorithms);if(o&&!o.has(n)||!o&&n.startsWith("PBES2"))throw new J('"alg" (Algorithm) Header Parameter value not allowed');if(s&&!s.has(c))throw new J('"enc" (Encryption Algorithm) Header Parameter value not allowed');let d;if(void 0!==e.encrypted_key)try{d=W(e.encrypted_key)}catch{throw new j("Failed to base64url decode the encrypted_key")}let y,p,l,u=!1;"function"==typeof t&&(t=await t(r,e),u=!0);try{y=await Ke(n,t,d,i,a)}catch(e){if(e instanceof TypeError||e instanceof j||e instanceof D)throw e;y=be(c)}if(void 0!==e.iv)try{p=W(e.iv)}catch{throw new j("Failed to base64url decode the iv")}if(void 0!==e.tag)try{l=W(e.tag)}catch{throw new j("Failed to base64url decode the tag")}const w=K.encode(e.protected??"");let h,f;h=void 0!==e.aad?B(w,K.encode("."),K.encode(e.aad)):w;try{f=W(e.ciphertext)}catch{throw new j("Failed to base64url decode the ciphertext")}const g={plaintext:await re(c,y,f,p,l,h)};if(void 0!==e.protected&&(g.protectedHeader=r),void 0!==e.aad)try{g.additionalAuthenticatedData=W(e.aad)}catch{throw new j("Failed to base64url decode the aad")}return void 0!==e.unprotected&&(g.sharedUnprotectedHeader=e.unprotected),void 0!==e.header&&(g.unprotectedHeader=e.header),u?{...g,key:t}:g}var Pe=async e=>{if(e instanceof Uint8Array)return{kty:"oct",k:U(e)};if(!S(e))throw new TypeError(Z(e,...te,"Uint8Array"));if(!e.extractable)throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");const{ext:t,key_ops:a,alg:r,use:i,...n}=await E.subtle.exportKey("jwk",e);return n};async function ke(e){return Pe(e)}async function Ce(e,t,a,r,i={}){let n,c,o;switch(Se(e,a,"encrypt"),e){case"dir":o=a;break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!le(a))throw new D("ECDH with the provided key is not allowed or not supported by your javascript runtime");const{apu:s,apv:d}=i;let{epk:y}=i;y||(y=(await async function(e){if(!S(e))throw new TypeError(Z(e,...te));return E.subtle.generateKey(e.algorithm,!0,["deriveBits"])}(a)).privateKey);const{x:p,y:l,crv:u,kty:w}=await ke(y),h=await pe(a,y,"ECDH-ES"===e?t:e,"ECDH-ES"===e?me(t):parseInt(e.slice(-5,-2),10),s,d);if(c={epk:{x:p,crv:u,kty:w}},"EC"===w&&(c.epk.y=l),s&&(c.apu=U(s)),d&&(c.apv=U(d)),"ECDH-ES"===e){o=h;break}o=r||be(t);const f=e.slice(-6);n=await de(f,h,o);break}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":o=r||be(t),n=await(async(e,t,a)=>{if(!S(t))throw new TypeError(Z(t,...te));if(X(t,e,"encrypt","wrapKey"),fe(e,t),t.usages.includes("encrypt"))return new Uint8Array(await E.subtle.encrypt(he(e),t,a));if(t.usages.includes("wrapKey")){const r=await E.subtle.importKey("raw",a,...ce);return new Uint8Array(await E.subtle.wrapKey("raw",r,t,he(e)))}throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation')})(e,a,o);break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{o=r||be(t);const{p2c:s,p2s:d}=i;({encryptedKey:n,...c}=await(async(e,t,a,r=2048,i=I(new Uint8Array(16)))=>{const n=await ue(i,e,r,t);return{encryptedKey:await de(e.slice(-6),n,a),p2c:r,p2s:U(i)}})(e,a,o,s,d));break}case"A128KW":case"A192KW":case"A256KW":o=r||be(t),n=await de(e,a,o);break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{o=r||be(t);const{iv:s}=i;({encryptedKey:n,...c}=await async function(e,t,a,r){const i=e.slice(0,7),n=await xe(i,a,t,r,new Uint8Array(0));return{encryptedKey:n.ciphertext,iv:U(n.iv),tag:U(n.tag)}}(e,a,o,s));break}default:throw new D('Invalid or unsupported "alg" (JWE Algorithm) header value')}return{cek:o,encryptedKey:n,parameters:c}}const Te=Symbol();class Ue{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("plaintext must be an instance of Uint8Array");this._plaintext=e}setKeyManagementParameters(e){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=e,this}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._sharedUnprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._sharedUnprotectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}setContentEncryptionKey(e){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=e,this}setInitializationVector(e){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=e,this}async encrypt(e,t){if(!this._protectedHeader&&!this._unprotectedHeader&&!this._sharedUnprotectedHeader)throw new j("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");if(!ie(this._protectedHeader,this._unprotectedHeader,this._sharedUnprotectedHeader))throw new j("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const a={...this._protectedHeader,...this._unprotectedHeader,...this._sharedUnprotectedHeader};if(Ae(j,new Map,t?.crit,this._protectedHeader,a),void 0!==a.zip)throw new D('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');const{alg:r,enc:i}=a;if("string"!=typeof r||!r)throw new j('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("string"!=typeof i||!i)throw new j('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');let n,c,o,s,d;if(this._cek&&("dir"===r||"ECDH-ES"===r))throw new TypeError(`setContentEncryptionKey cannot be called with JWE "alg" (Algorithm) Header ${r}`);{let a;({cek:c,encryptedKey:n,parameters:a}=await Ce(r,i,e,this._cek,this._keyManagementParameters)),a&&(t&&Te in t?this._unprotectedHeader?this._unprotectedHeader={...this._unprotectedHeader,...a}:this.setUnprotectedHeader(a):this._protectedHeader?this._protectedHeader={...this._protectedHeader,...a}:this.setProtectedHeader(a))}s=this._protectedHeader?K.encode(U(JSON.stringify(this._protectedHeader))):K.encode(""),this._aad?(d=U(this._aad),o=B(s,K.encode("."),K.encode(d))):o=s;const{ciphertext:y,tag:p,iv:l}=await xe(i,this._plaintext,c,this._iv,o),u={ciphertext:U(y)};return l&&(u.iv=U(l)),p&&(u.tag=U(p)),n&&(u.encrypted_key=U(n)),d&&(u.aad=d),this._protectedHeader&&(u.protected=A.decode(s)),this._sharedUnprotectedHeader&&(u.unprotected=this._sharedUnprotectedHeader),this._unprotectedHeader&&(u.header=this._unprotectedHeader),u}}class We{constructor(e,t,a){this.parent=e,this.key=t,this.options=a}setUnprotectedHeader(e){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=e,this}addRecipient(...e){return this.parent.addRecipient(...e)}encrypt(...e){return this.parent.encrypt(...e)}done(){return this.parent}}class _e{constructor(e){this._recipients=[],this._plaintext=e}addRecipient(e,t){const a=new We(this,e,{crit:t?.crit});return this._recipients.push(a),a}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}async encrypt(){if(!this._recipients.length)throw new j("at least one recipient must be added");if(1===this._recipients.length){const[e]=this._recipients,t=await new Ue(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(e.unprotectedHeader).encrypt(e.key,{...e.options}),a={ciphertext:t.ciphertext,iv:t.iv,recipients:[{}],tag:t.tag};return t.aad&&(a.aad=t.aad),t.protected&&(a.protected=t.protected),t.unprotected&&(a.unprotected=t.unprotected),t.encrypted_key&&(a.recipients[0].encrypted_key=t.encrypted_key),t.header&&(a.recipients[0].header=t.header),a}let e;for(let t=0;t<this._recipients.length;t++){const a=this._recipients[t];if(!ie(this._protectedHeader,this._unprotectedHeader,a.unprotectedHeader))throw new j("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const r={...this._protectedHeader,...this._unprotectedHeader,...a.unprotectedHeader},{alg:i}=r;if("string"!=typeof i||!i)throw new j('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("dir"===i||"ECDH-ES"===i)throw new j('"dir" and "ECDH-ES" alg may only be used with a single recipient');if("string"!=typeof r.enc||!r.enc)throw new j('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');if(e){if(e!==r.enc)throw new j('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients')}else e=r.enc;if(Ae(j,new Map,a.options.crit,this._protectedHeader,r),void 0!==r.zip)throw new D('JWE "zip" (Compression Algorithm) Header Parameter is not supported.')}const t=be(e),a={ciphertext:"",iv:"",recipients:[],tag:""};for(let r=0;r<this._recipients.length;r++){const i=this._recipients[r],n={};a.recipients.push(n);const c={...this._protectedHeader,...this._unprotectedHeader,...i.unprotectedHeader}.alg.startsWith("PBES2")?2048+r:void 0;if(0===r){const e=await new Ue(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(t).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(i.unprotectedHeader).setKeyManagementParameters({p2c:c}).encrypt(i.key,{...i.options,[Te]:!0});a.ciphertext=e.ciphertext,a.iv=e.iv,a.tag=e.tag,e.aad&&(a.aad=e.aad),e.protected&&(a.protected=e.protected),e.unprotected&&(a.unprotected=e.unprotected),n.encrypted_key=e.encrypted_key,e.header&&(n.header=e.header);continue}const{encryptedKey:o,parameters:s}=await Ce(i.unprotectedHeader?.alg||this._protectedHeader?.alg||this._unprotectedHeader?.alg,e,i.key,t,{p2c:c});n.encrypted_key=U(o),(i.unprotectedHeader||s)&&(n.header={...i.unprotectedHeader,...s})}return a}}function Je(e,t){const a=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:a,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:a,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:a,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:a,name:"ECDSA",namedCurve:t.namedCurve};case"EdDSA":return{name:t.name};default:throw new D(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}function De(e,t,a){if(S(t))return V(t,e,a),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(Z(t,...te));return E.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[a])}throw new TypeError(Z(t,...te,"Uint8Array"))}const Re=async(e,t,a,r)=>{const i=await De(e,t,"verify");fe(e,i);const n=Je(e,i.algorithm);try{return await E.subtle.verify(n,i,a,r)}catch{return!1}};async function je(e,t,a){if(!ne(e))throw new O("Flattened JWS must be an object");if(void 0===e.protected&&void 0===e.header)throw new O('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==e.protected&&"string"!=typeof e.protected)throw new O("JWS Protected Header incorrect type");if(void 0===e.payload)throw new O("JWS Payload missing");if("string"!=typeof e.signature)throw new O("JWS Signature missing or incorrect type");if(void 0!==e.header&&!ne(e.header))throw new O("JWS Unprotected Header incorrect type");let r={};if(e.protected)try{const t=W(e.protected);r=JSON.parse(A.decode(t))}catch{throw new O("JWS Protected Header is invalid")}if(!ie(r,e.header))throw new O("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const i={...r,...e.header};let n=!0;if(Ae(O,new Map([["b64",!0]]),a?.crit,r,i).has("b64")&&(n=r.b64,"boolean"!=typeof n))throw new O('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:c}=i;if("string"!=typeof c||!c)throw new O('JWS "alg" (Algorithm) Header Parameter missing or invalid');const o=a&&He("algorithms",a.algorithms);if(o&&!o.has(c))throw new J('"alg" (Algorithm) Header Parameter value not allowed');if(n){if("string"!=typeof e.payload)throw new O("JWS Payload must be a string")}else if("string"!=typeof e.payload&&!(e.payload instanceof Uint8Array))throw new O("JWS Payload must be a string or an Uint8Array instance");let s=!1;"function"==typeof t&&(t=await t(r,e),s=!0),Se(c,t,"verify");const d=B(K.encode(e.protected??""),K.encode("."),"string"==typeof e.payload?K.encode(e.payload):e.payload);let y;try{y=W(e.signature)}catch{throw new O("Failed to base64url decode the signature")}if(!await Re(c,t,y,d))throw new M;let p;if(n)try{p=W(e.payload)}catch{throw new O("Failed to base64url decode the payload")}else p="string"==typeof e.payload?K.encode(e.payload):e.payload;const l={payload:p};return void 0!==e.protected&&(l.protectedHeader=r),void 0!==e.header&&(l.unprotectedHeader=e.header),s?{...l,key:t}:l}class Oe{constructor(e){this._flattened=new Ue(e)}setContentEncryptionKey(e){return this._flattened.setContentEncryptionKey(e),this}setInitializationVector(e){return this._flattened.setInitializationVector(e),this}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}setKeyManagementParameters(e){return this._flattened.setKeyManagementParameters(e),this}async encrypt(e,t){const a=await this._flattened.encrypt(e,t);return[a.protected,a.encrypted_key,a.iv,a.ciphertext,a.tag].join(".")}}class Me{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=e}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}async sign(e,t){if(!this._protectedHeader&&!this._unprotectedHeader)throw new O("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!ie(this._protectedHeader,this._unprotectedHeader))throw new O("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const a={...this._protectedHeader,...this._unprotectedHeader};let r=!0;if(Ae(O,new Map([["b64",!0]]),t?.crit,this._protectedHeader,a).has("b64")&&(r=this._protectedHeader.b64,"boolean"!=typeof r))throw new O('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:i}=a;if("string"!=typeof i||!i)throw new O('JWS "alg" (Algorithm) Header Parameter missing or invalid');Se(i,e,"sign");let n,c=this._payload;r&&(c=K.encode(U(c))),n=this._protectedHeader?K.encode(U(JSON.stringify(this._protectedHeader))):K.encode("");const o=B(n,K.encode("."),c),s=await(async(e,t,a)=>{const r=await De(e,t,"sign");fe(e,r);const i=await E.subtle.sign(Je(e,r.algorithm),r,a);return new Uint8Array(i)})(i,e,o),d={signature:U(s),payload:""};return r&&(d.payload=A.decode(c)),this._unprotectedHeader&&(d.header=this._unprotectedHeader),this._protectedHeader&&(d.protected=A.decode(n)),d}}class Ie{constructor(e){this._flattened=new Me(e)}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}async sign(e,t){const a=await this._flattened.sign(e,t);if(void 0===a.payload)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${a.protected}.${a.payload}.${a.signature}`}}class $e{constructor(e,t,a){this.parent=e,this.key=t,this.options=a}setProtectedHeader(e){if(this.protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this.protectedHeader=e,this}setUnprotectedHeader(e){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=e,this}addSignature(...e){return this.parent.addSignature(...e)}sign(...e){return this.parent.sign(...e)}done(){return this.parent}}class Ge{constructor(e){this._signatures=[],this._payload=e}addSignature(e,t){const a=new $e(this,e,t);return this._signatures.push(a),a}async sign(){if(!this._signatures.length)throw new O("at least one signature must be added");const e={signatures:[],payload:""};for(let t=0;t<this._signatures.length;t++){const a=this._signatures[t],r=new Me(this._payload);r.setProtectedHeader(a.protectedHeader),r.setUnprotectedHeader(a.unprotectedHeader);const{payload:i,...n}=await r.sign(a.key,a.options);if(0===t)e.payload=i;else if(e.payload!==i)throw new O("inconsistent use of JWS Unencoded Payload (RFC7797)");e.signatures.push(n)}return e}}const Le=U,Ne=W;function Fe(e){const t=e?.modulusLength??2048;if("number"!=typeof t||t<2048)throw new D("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");return t}async function ze(e,t){return async function(e,t){let a,r;switch(e){case"PS256":case"PS384":case"PS512":a={name:"RSA-PSS",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:Fe(t)},r=["sign","verify"];break;case"RS256":case"RS384":case"RS512":a={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:Fe(t)},r=["sign","verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":a={name:"RSA-OAEP",hash:`SHA-${parseInt(e.slice(-3),10)||1}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:Fe(t)},r=["decrypt","unwrapKey","encrypt","wrapKey"];break;case"ES256":a={name:"ECDSA",namedCurve:"P-256"},r=["sign","verify"];break;case"ES384":a={name:"ECDSA",namedCurve:"P-384"},r=["sign","verify"];break;case"ES512":a={name:"ECDSA",namedCurve:"P-521"},r=["sign","verify"];break;case"EdDSA":{r=["sign","verify"];const e=t?.crv??"Ed25519";switch(e){case"Ed25519":case"Ed448":a={name:e};break;default:throw new D("Invalid or unsupported crv option provided")}break}case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{r=["deriveKey","deriveBits"];const e=t?.crv??"P-256";switch(e){case"P-256":case"P-384":case"P-521":a={name:"ECDH",namedCurve:e};break;case"X25519":case"X448":a={name:e};break;default:throw new D("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448")}break}default:throw new D('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return E.subtle.generateKey(a,t?.extractable??!1,r)}(e,t)}async function qe(e,t){return async function(e,t){let a,r,i;switch(e){case"HS256":case"HS384":case"HS512":a=parseInt(e.slice(-3),10),r={name:"HMAC",hash:`SHA-${a}`,length:a},i=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return a=parseInt(e.slice(-3),10),I(new Uint8Array(a>>3));case"A128KW":case"A192KW":case"A256KW":a=parseInt(e.slice(1,4),10),r={name:"AES-KW",length:a},i=["wrapKey","unwrapKey"];break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":case"A128GCM":case"A192GCM":case"A256GCM":a=parseInt(e.slice(1,4),10),r={name:"AES-GCM",length:a},i=["encrypt","decrypt"];break;default:throw new D('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return E.subtle.generateKey(r,t?.extractable??!1,i)}(e,t)}const Ve="ECDSA",Xe="P-384",Ye="ES384",Ze="SHA-256",Qe="RSA-OAEP-256",et="AES-GCM",tt="A256GCM",at="PBES2-HS512+A256KW",rt=!0;const nt={decodeProtectedHeader:function(e){let t;if("string"==typeof e){const a=e.split(".");3!==a.length&&5!==a.length||([t]=a)}else if("object"==typeof e&&e){if(!("protected"in e))throw new TypeError("Token does not contain a Protected Header");t=e.protected}try{if("string"!=typeof t||!t)throw new Error;const e=JSON.parse(A.decode(Ne(t)));if(!ne(e))throw new Error;return e}catch{throw new TypeError("Invalid Token or Protected Header formatting")}},isEmptyJWSPayload:e=>!e.split(".")[1],inputBuffer(e,t){if(ArrayBuffer.isView(e)&&!t.cty)return e;let a=t.cty||"";return a.includes("text")||"string"==typeof e?t.cty=a||"text/plain":(t.cty=a||"json",e=JSON.stringify(e)),(new TextEncoder).encode(e)},recoverDataFromContentType:(e,{cty:t=e?.protectedHeader?.cty}={})=>(e&&!Object.prototype.hasOwnProperty.call(e,"payload")&&(e.payload=e.plaintext),t&&e?.payload?(e.text=(new TextDecoder).decode(e.payload),t.includes("json")&&(e.json=JSON.parse(e.text)),e):e),generateSigningKey:()=>ze(Ye,{extractable:rt}),async sign(e,t,a={}){let r={alg:Ye,...a},i=this.inputBuffer(t,r);return new Ie(i).setProtectedHeader(r).sign(e)},async verify(e,t,a){let r=await async function(e,t,a){if(e instanceof Uint8Array&&(e=A.decode(e)),"string"!=typeof e)throw new O("Compact JWS must be a string or Uint8Array");const{0:r,1:i,2:n,length:c}=e.split(".");if(3!==c)throw new O("Invalid Compact JWS");const o=await je({payload:i,protected:r,signature:n},t,a),s={payload:o.payload,protectedHeader:o.protectedHeader};return"function"==typeof t?{...s,key:o.key}:s}(t,e).catch((()=>{}));return this.recoverDataFromContentType(r,a)},generateEncryptingKey:()=>ze(Qe,{extractable:rt,modulusLength:4096}),async encrypt(e,t,a={}){let r={alg:this.isSymmetric(e)?"dir":Qe,enc:tt,...a},i=this.inputBuffer(t,r),n=this.keySecret(e);return new Oe(i).setProtectedHeader(r).encrypt(n)},async decrypt(e,t,a){let r=this.keySecret(e),i=await async function(e,t,a){if(e instanceof Uint8Array&&(e=A.decode(e)),"string"!=typeof e)throw new j("Compact JWE must be a string or Uint8Array");const{0:r,1:i,2:n,3:c,4:o,length:s}=e.split(".");if(5!==s)throw new j("Invalid Compact JWE");const d=await Be({ciphertext:c,iv:n||void 0,protected:r,tag:o||void 0,encrypted_key:i||void 0},t,a),y={plaintext:d.plaintext,protectedHeader:d.protectedHeader};return"function"==typeof t?{...y,key:d.key}:y}(t,r);return this.recoverDataFromContentType(i,a),i},async generateSecretKey(e){let t=(new TextEncoder).encode(e),a=await function(e,t){return crypto.subtle.digest(e,t)}(Ze,t);return{type:"secret",text:new Uint8Array(a)}},generateSymmetricKey(e){return e?this.generateSecretKey(e):qe(tt,{extractable:rt})},isSymmetric:e=>"secret"===e.type,keySecret:e=>e.text?e.text:e,async exportRaw(e){let t=await function(e){return crypto.subtle.exportKey("raw",e)}(e);return Le(new Uint8Array(t))},importRaw:async e=>function(e){const t={name:Ve,namedCurve:Xe};return crypto.subtle.importKey("raw",e,t,rt,["verify"])}(Ne(e)),async exportJWK(e){let t=await ke(e),a=e.algorithm;if(a)a.name===Ve&&a.namedCurve===Xe?t.alg=Ye:"RSA-OAEP"===a.name&&a.hash.name===Ze?t.alg=Qe:a.name===et&&256===a.length&&(t.alg=tt);else switch(t.kty){case"EC":t.alg=Ye;break;case"RSA":t.alg=Qe;break;case"oct":t.alg=tt}return t},async importJWK(e){e={ext:!0,...e};let t=await Ee(e);return t instanceof Uint8Array&&(t=await function(e){const t={name:et,length:256};return crypto.subtle.importKey("raw",e,t,!0,["encrypt","decrypt"])}(t)),t},async wrapKey(e,t){let a=await this.exportJWK(e);return this.encrypt(t,a)},async unwrapKey(e,t){let a=await this.decrypt(t,e);return this.importJWK(a.json)}};const ct={isMultiKey:e=>"multi"===(e.type||"multi"),keyTags:e=>Object.keys(e).filter((e=>"type"!==e)),async exportJWK(e){if(!this.isMultiKey(e))return super.exportJWK(e);let t=this.keyTags(e),a=await Promise.all(t.map((async t=>{let a=await this.exportJWK(e[t]);return a.kid=t,a})));return{keys:a}},async importJWK(e){if(!e.keys)return super.importJWK(e);let t={};return await Promise.all(e.keys.map((async e=>t[e.kid]=await this.importJWK(e)))),t},async encrypt(e,t,a={}){if(!this.isMultiKey(e))return super.encrypt(e,t,a);let r={enc:tt,...a},i=this.inputBuffer(t,r),n=new _e(i).setProtectedHeader(r);for(let t of this.keyTags(e)){let a=e[t],r="string"==typeof a,i=r||this.isSymmetric(a),c=r?(new TextEncoder).encode(a):this.keySecret(a),o=r?at:i?"A256GCMKW":Qe;n.addRecipient(c).setUnprotectedHeader({kid:t,alg:o})}return await n.encrypt()},async decrypt(e,t,a){if(!this.isMultiKey(e))return super.decrypt(e,t,a);let r=t,{recipients:i}=r,n=i.map((async({header:t})=>{let{kid:a}=t,i=e[a],n={};if(!i)return Promise.reject("missing");"string"==typeof i&&(i=(new TextEncoder).encode(i),n.keyManagementAlgorithms=[at]);let c=await async function(e,t,a){if(!ne(e))throw new j("General JWE must be an object");if(!Array.isArray(e.recipients)||!e.recipients.every(ne))throw new j("JWE Recipients missing or incorrect type");if(!e.recipients.length)throw new j("JWE Recipients has no members");for(const r of e.recipients)try{return await Be({aad:e.aad,ciphertext:e.ciphertext,encrypted_key:r.encrypted_key,header:r.header,iv:e.iv,protected:e.protected,tag:e.tag,unprotected:e.unprotected},t,a)}catch{}throw new R}(r,this.keySecret(i),n),o=c.unprotectedHeader.kid;return o!==a?function(e,t){let a=`Key ${e} does not match encoded ${t}.`;return Promise.reject(a)}(a,o):c}));return await Promise.any(n).then((e=>(this.recoverDataFromContentType(e,a),e)),(()=>{}))},async sign(e,t,a={}){if(!this.isMultiKey(e))return super.sign(e,t,a);let r=this.inputBuffer(t,a),i=new Ge(r);for(let t of this.keyTags(e)){let r=e[t],n={kid:t,alg:Ye,...a};i.addSignature(r).setProtectedHeader(n)}return i.sign()},verifySubSignature(e,t,a,r){let i=t.protectedHeader??this.decodeProtectedHeader(t),n=t.unprotectedHeader,c=i?.kid||n?.kid,o={...e,signatures:[t]},s={protectedHeader:i,unprotectedHeader:n,kid:c},d=c?[c]:r,y=Promise.any(d.map((async e=>async function(e,t,a){if(!ne(e))throw new O("General JWS must be an object");if(!Array.isArray(e.signatures)||!e.signatures.every(ne))throw new O("JWS Signatures missing or incorrect type");for(const r of e.signatures)try{return await je({header:r.header,payload:e.payload,protected:r.protected,signature:r.signature},t,a)}catch{}throw new M}(o,a[e]).then((t=>({kid:e,...t}))))));return y.catch((()=>s))},async verify(e,t,a={}){if(!this.isMultiKey(e))return super.verify(e,t,a);if(!t.signatures)return;let r=t,i=this.keyTags(e),n=await Promise.all(r.signatures.map((t=>this.verifySubSignature(r,t,e,i))));if(!n.find((e=>e.payload)))return;let[c,...o]=n,s={protectedHeader:{},unprotectedHeader:{},signers:n},d=e=>{let t=c[e],a=s[e];for(let r in t){let i=t[r];o.some((t=>t[e][r]!==i))||(a[r]=i)}};return d("protectedHeader"),d("protectedHeader"),s.payload=n.find((e=>e.payload)).payload,this.recoverDataFromContentType(s,a)}};Object.setPrototypeOf(ct,nt);class ot{constructor({collectionName:e="collection",dbName:t="asyncLocalStorage"}={}){this.collectionName=e,this.dbName=t,this.version=1}get db(){return this._db??=new Promise((e=>{const t=indexedDB.open(this.dbName,this.version);t.onupgradeneeded=e=>e.target.result.createObjectStore(this.collectionName),this.result(e,t)}))}transaction(e="read"){const t=this.collectionName;return this.db.then((a=>a.transaction(t,e).objectStore(t)))}result(e,t){t.onsuccess=t=>e(t.target.result||"")}retrieve(e){return new Promise((t=>{this.transaction("readonly").then((a=>this.result(t,a.get(e))))}))}store(e,t){return new Promise((a=>{this.transaction("readwrite").then((r=>this.result(a,r.put(t,e))))}))}remove(e){return new Promise((t=>{this.transaction("readwrite").then((a=>this.result(t,a.delete(e))))}))}}function st(e,t,a=void 0){let r=e(t.slice(0,16)+"...");return Promise.reject(new Error(r,{cause:a}))}function dt(e){return st((e=>`The tag ${e} is not available.`),e)}class yt{static keySets={};static cached(e){return this.keySets[e]}static clear(e=null){if(!e)return yt.keySets={};delete yt.keySets[e]}constructor(e){this.tag=e,this.memberTags=[],yt.keySets[e]=this}static getUserDeviceSecret=c;static Storage=i;static async create(e){let{time:t,...a}=await this.createKeys(e),{tag:r}=a;return await this.persist(r,a,e,t),r}async destroy(e={}){let{tag:t,memberTags:a,signingKey:r}=this,i=await this.constructor.signForStorage({message:"",tag:t,memberTags:a,signingKey:r,time:Date.now()});await this.constructor.store("EncryptionKey",t,i),await this.constructor.store(this.constructor.collection,t,i),this.constructor.clear(t),e.recursiveMembers&&await Promise.allSettled(this.memberTags.map((async t=>{let a=await yt.ensure(t);await a.destroy(e)})))}decrypt(e,t){let{tag:a,decryptingKey:r}=this,i=e.recipients?{[a]:r}:r;return ct.decrypt(i,e,t)}static async sign(e,{tags:t=[],team:a,member:r,time:i=a&&Date.now(),memberTags:n,signingKey:c,...o}){if(a&&!r){n||(n=(await yt.ensure(a)).memberTags),r=n.find((e=>this.cached(e)))||await Promise.any(n.map((e=>yt.ensure(e)))).then((e=>e.tag))}a&&!t.includes(a)&&(t=[a,...t]),r&&!t.includes(r)&&(t=[...t,r]);let s=await this.produceKey(t,(async e=>{let t=c||(await yt.ensure(e)).signingKey;return c=null,t}),o);return ct.sign(s,e,{iss:a,act:r,iat:i,...o})}static async verify(e,t,a){let r=!e.signatures,i=await this.produceKey(t,(e=>yt.verifyingKey(e)),a,r),n=await ct.verify(i,e,a),c=void 0===a.member?n?.protectedHeader.act:a.member,o=a.notBefore;function s(e){if(a.hardError)return Promise.reject(new Error(e))}if(!n)return s("Incorrect signature.");if(c){if("team"===a.member&&(c=n.protecteHeader.act,!c))return s("No member identified in signature.");if(!t.includes(c)){let r=await yt.verifyingKey(c),i={[c]:r};if(!await ct.verify(i,e,a))return s("Incorrect member signature.");t.push(c),n.signers.find((e=>e.protectedHeader.kid===c)).payload=n.payload}}if(c||"team"===o){let e=n.protectedHeader.iss||n.protectedHeader.kid,t=await this.retrieve(ht.collection,e),a=t?.json;if(c&&!e)return s("No team or main tag identified in signature");if(c&&a&&!a.recipients.find((e=>e.header.kid===c)))return s("Signer is not a member.");"team"===o&&(o=t?.protectedHeader.iat||(await this.retrieve("EncryptionKey",e))?.protectedHeader.iat)}if(o){let{iat:e}=n.protectedHeader;if(e<o)return s("Signature predates required timestamp.")}return(n.signers?.filter((e=>e.payload)).length||1)!==t.length?s("Unverified signer"):n}static async produceKey(e,t,a,r=1===e.length){if(r){let r=e[0];return a.kid=r,t(r)}let i={},n=await Promise.all(e.map((e=>t(e))));return e.forEach(((e,t)=>i[e]=n[t])),i}static verifyingKey(e){return ct.importRaw(e).catch((()=>dt(e)))}static async encryptingKey(e){let t=await this.retrieve("EncryptionKey",e);return t?await ct.importJWK(t.json):dt(e)}static async createKeys(e){let{publicKey:t,privateKey:a}=await ct.generateSigningKey(),{publicKey:r,privateKey:i}=await ct.generateEncryptingKey(),n=await ct.exportRaw(t),c=await ct.exportJWK(r),o=Date.now(),s=await this.signForStorage({message:c,tag:n,signingKey:a,memberTags:e,time:o});return await this.store("EncryptionKey",n,s),{signingKey:a,decryptingKey:i,tag:n,time:o}}static getWrapped(e){return this.retrieve(this.collection,e)}static async ensure(e){let t=this.cached(e),a=await ut.getWrapped(e);return a?t=new ut(e):(a=await ht.getWrapped(e))?t=new ht(e):(a=await lt.getWrapped(e))&&(t=new lt(e)),t?.cached&&t.cached===a&&t.decryptingKey&&t.signingKey?t:a?(t.cached=a,t.unwrap(t.cached).then((e=>Object.assign(t,e)),(e=>(this.clear(t.tag),st((e=>`You do not have access to the private key for ${e}.`),t.tag,e))))):(this.clear(e),dt(e))}static async persist(e,t,a,r=Date.now(),i=a){let{signingKey:n}=t,c=await this.wrap(t,a),o=await this.signForStorage({message:c,tag:e,signingKey:n,memberTags:i,time:r});await this.store(this.collection,e,o)}static async store(e,t,a){return e===ut.collection?ct.isEmptyJWSPayload(a)?wt.remove(t):wt.store(t,a):yt.Storage.store(e,t,a)}static async retrieve(e,t){let a=e===ut.collection?wt.retrieve(t):yt.Storage.retrieve(e,t),r=await a,i=r&&await yt.verifyingKey(t);if(r)return r.signatures&&(i={[t]:i}),await ct.verify(i,r)}}class pt extends yt{static signForStorage({message:e,tag:t,signingKey:a,time:r}){return this.sign(e,{tags:[t],signingKey:a,time:r})}static async wrap(e,t=""){let{decryptingKey:a,signingKey:r,tag:i}=e,n={decryptingKey:a,signingKey:r},c={[t]:await this.getSecret(i,t)};return ct.wrapKey(n,c)}async unwrap(e){let t=e.json.recipients[0].header.kid,a={[t]:await this.constructor.getSecret(this.tag,t)},r=(await ct.decrypt(a,e.json)).json;return await ct.importJWK(r,{decryptingKey:"decrypt",signingKey:"sign"})}static async getSecret(e,t){return yt.getUserDeviceSecret(e,t)}}class lt extends pt{static collection="KeyRecovery"}class ut extends pt{static collection="Device"}const wt=new ot({collectionName:ut.collection});class ht extends yt{static collection="Team";static signForStorage({message:e,tag:t,...a}){return this.sign(e,{team:t,...a})}static async wrap(e,t){let{decryptingKey:a,signingKey:r}=e,i={decryptingKey:a,signingKey:r},n={};return await Promise.all(t.map((e=>yt.encryptingKey(e).then((t=>n[e]=t))))),await ct.wrapKey(i,n)}async unwrap(e){let{recipients:t}=e.json,a=this.memberTags=t.map((e=>e.header.kid)),r=await Promise.all(a.map((e=>lt.getWrapped(e).catch((()=>null))))),i=a.filter(((e,t)=>r[t])),n=a.filter((e=>!i.includes(e))),c=await Promise.any(n.map((e=>yt.ensure(e)))).catch((async e=>{for(let e of i){let t=await yt.ensure(e).catch((()=>null));if(t)return t}return e})),o=await c.decrypt(e.json);return await ct.importJWK(o.json)}async changeMembership({add:e=[],remove:t=[]}={}){let{memberTags:a}=this,r=a.concat(e).filter((e=>!t.includes(e)));await this.constructor.persist(this.tag,this,r,Date.now(),a),this.memberTags=r}}var ft={name:"@kilroy-code/distributed-security",version:"0.0.6",description:"Signed and encrypted document infrastructure based on public key encryption and self-organizing users.",type:"module",exports:{node:"./lib/api.mjs",default:"./index.mjs"},imports:{"#raw":{node:"./lib/raw-node.mjs",default:"./lib/raw-browser.mjs"},"#localStore":{node:"./lib/store-fs.mjs",default:"./lib/store-indexed.mjs"},"#origin":{node:"./lib/origin-node.mjs",default:"./lib/origin-browser.mjs"},"#internals":{node:"./spec/support/internals.mjs",default:"./spec/support/internal-browser-bundle.mjs"}},scripts:{build:"rollup -c",test:"jasmine"},repository:{type:"git",url:"git+https://github.com/kilroy-code/distributed-security.git"},publishConfig:{registry:"https://npm.pkg.github.com"},keywords:["encryption","pki","dao"],author:{name:"Howard Stearns",email:"howard@ki1r0y.com"},license:"MIT",bugs:{url:"https://github.com/kilroy-code/distributed-security/issues"},homepage:"https://github.com/kilroy-code/distributed-security#readme",devDependencies:{"@rollup/plugin-eslint":"^9.0.5","@rollup/plugin-json":"^6.1.0","@rollup/plugin-node-resolve":"^15.2.3","@rollup/plugin-terser":"^0.4.4",eslint:"^8.57.0",jasmine:"^4.5.0","jsonc-eslint-parser":"^2.4.0",rollup:"^4.13.0"},dependencies:{"@kilroy-code/jsonrpc":"^0.0.3",jose:"^5.2.3"}};const{name:gt,version:mt}=ft,bt={set Storage(e){yt.Storage=e},get Storage(){return yt.Storage},set getUserDeviceSecret(e){yt.getUserDeviceSecret=e},ready:{name:gt,version:mt,origin:yt.Storage.origin},async encrypt(e,...t){let a={},r=this.canonicalizeParameters(t,a),i=await yt.produceKey(r,(e=>yt.encryptingKey(e)),a);return ct.encrypt(i,e,a)},async decrypt(e,...t){let a={},[r]=this.canonicalizeParameters(t,a,e);return(await yt.ensure(r)).decrypt(e,a)},async sign(e,...t){let a={},r=this.canonicalizeParameters(t,a);return yt.sign(e,{tags:r,...a})},async verify(e,...t){let a={},r=this.canonicalizeParameters(t,a,e);return yt.verify(e,r,a)},async create(...e){if(!e.length)return await ut.create();let t=e[0].prompt;return t?await lt.create(t):await ht.create(e)},changeMembership:async({tag:e,...t})=>(await yt.ensure(e)).changeMembership(t),async destroy(e){"string"==typeof e&&(e={tag:e});let{tag:t,...a}=e;return(await yt.ensure(t)).destroy(a)},clear(e){yt.clear(e)},decodeProtectedHeader:ct.decodeProtectedHeader,canonicalizeParameters(e,t,a){if(e.length>1)return e;let{tags:r=[],contentType:i,time:n,...c}=e[0]||{},{team:o}=c;if(!r.length)if(e.length&&e[0].length)r=e;else if(a)if(a.signatures)r=a.signatures.map((e=>this.decodeProtectedHeader(e).kid));else if(a.recipients)r=a.recipients.map((e=>e.header.kid));else try{let e=this.decodeProtectedHeader(a).kid;e&&(r=[e])}catch(t){console.error("failure with",{rest:e,token:a,team:o,tags:r,e:t})}return o&&!r.includes(o)&&(r=[o,...r]),i&&(t.cty=i),n&&(t.iat=n),Object.assign(t,c),r}};e.Security=w,w.Storage=e;let vt="secret",Et=vt;async function St(e){Et="other",await e(),Et=vt}function xt(e,t=""){return t+Et}w.getUserDeviceSecret=xt,bt.Storage=e,bt.getUserDeviceSecret=xt,"undefined"!=typeof window&&Object.assign(window,{Security:w,Krypto:nt,MultiKrypto:ct,Storage:e}),describe("Distributed Security",(function(){let t=f();describe("Krypto",(function(){v(nt)})),describe("MultiKrypto",(function(){!function(e){const t=2e4,a=f();describe("falls through to krypto with single keys",(function(){v(e,h)})),describe("multi-way keys",(function(){describe("multi-signature",(function(){let t,r;beforeAll((async function(){t=await e.generateSigningKey(),r=await e.generateSigningKey()})),it("is a multi-signature.",(async function(){let i={a:t.privateKey,b:r.privateKey},n={b:r.publicKey,a:t.publicKey},c=await e.sign(i,a),o=await e.verify(n,c);expect(o).toBeTruthy()})),it('can specify type:"multi" in the signing key for clarify.',(async function(){let i={a:t.privateKey,b:r.privateKey,type:"multi"},n={a:t.publicKey,b:r.publicKey},c=await e.sign(i,a),o=await e.verify(n,c);expect(o).toBeTruthy()})),it('can specify type:"multi" in the verifying key for clarify.',(async function(){let i={a:t.privateKey,b:r.privateKey},n={a:t.publicKey,b:r.publicKey,type:"multi"},c=await e.sign(i,a),o=await e.verify(n,c);expect(o).toBeTruthy()})),it("can specify iss, act, iat in the key, which will appear in the signature.",(async function(){let i=Date.now(),n={a:t.privateKey,b:r.privateKey},c={a:t.publicKey,b:r.publicKey},o=await e.sign(n,a,{iss:"a",act:"b",iat:i}),s=await e.verify(c,o);expect(s).toBeTruthy(),o.signatures.forEach((t=>{let a=e.decodeProtectedHeader(t);expect(a.iss).toBe("a"),expect(a.act).toBe("b"),expect(a.iat).toBe(i)}))})),it("can sign binary and it is recovery as binary from payload property of verfication.",(async function(){let a=new Uint8Array([1],[2],[3]),i=await e.sign({a:t.privateKey,b:r.privateKey},a),n=await e.verify({a:t.publicKey,b:r.publicKey},i);expect(n.payload).toEqual(a)})),it("can sign string type and it is recoverable as string from text property of verification.",(async function(){let a="a string",i=await e.sign({a:t.privateKey,b:r.privateKey},a),n=await e.verify({a:t.publicKey,b:r.publicKey},i);expect(n.text).toEqual(a),expect(n.payload).toEqual((new TextEncoder).encode(a))})),it("can sign a jsonable object and it is recovery as same from json property of result.",(async function(){let a={foo:"a string",bar:!1,baz:["a",2,null]},i=await e.sign({a:t.privateKey,b:r.privateKey},a),n=await e.verify({a:t.publicKey,b:r.publicKey},i);expect(n.json).toEqual(a),expect(n.payload).toEqual((new TextEncoder).encode(JSON.stringify(a)))})),it("can specify a specific cty that will pass through to verify.",(async function(){let a={foo:"a string",bar:!1,baz:["a",2,null]},i="application/foo+json",n=await e.sign({a:t.privateKey,b:r.privateKey},a,{cty:i}),c=await e.verify({a:t.publicKey,b:r.publicKey},n);expect(c.json).toEqual(a),expect(c.protectedHeader.cty).toBe(i),expect(c.payload).toEqual((new TextEncoder).encode(JSON.stringify(a)))})),it("fails verification if the signature is mislabeled.",(async function(){let i={a:r.privateKey,b:t.privateKey},n={a:t.publicKey,b:r.publicKey},c=await e.sign(i,a),o=await e.verify(n,c);expect(o).toBeUndefined()})),it("gives enough information that we can tell if a verifying sub key is missing.",(async function(){let i={a:t.privateKey,b:r.privateKey},n={b:r.publicKey},c=await e.sign(i,a),o=await e.verify(n,c);expect(o.payload).toBeTruthy(),expect(o.text).toBe(a),expect(o.signers[1].payload).toBeTruthy(),expect(o.signers[0].payload).toBeUndefined()})),it("gives enough information that we can tell if a signature sub key is missing.",(async function(){let i={a:t.privateKey},n={a:t.publicKey,b:r.publicKey},c=await e.sign(i,a),o=await e.verify(n,c);expect(o.payload).toBeTruthy(),expect(o.text).toBe(a),expect(o.signers.length).toBe(1),expect(o.signers[0].protectedHeader.kid).toBe("a"),expect(o.signers[0].payload).toBeTruthy()}))})),describe("multi-way encryption",(function(){let r,i,n,c,o,s,d="shh!";beforeAll((async function(){n=await e.generateSymmetricKey(),i=await e.generateEncryptingKey(),r=await e.encrypt({a:n,b:i.publicKey,c:d},a),c=r.recipients;let t=await e.generateEncryptingKey();o={a:i.publicKey,b:t.publicKey},s={a:i.privateKey,b:t.privateKey}}),t),it("works with symmetric members.",(async function(){let t=await e.decrypt({a:n},r);expect(t.text).toBe(a),expect(c[0].header.kid).toBe("a"),expect(c[0].header.alg).toBe("A256GCMKW")})),it("works with keypair members.",(async function(){let t=await e.decrypt({b:i.privateKey},r);expect(t.text).toBe(a),expect(c[1].header.kid).toBe("b"),expect(c[1].header.alg).toBe("RSA-OAEP-256")})),it("works with secret text members.",(async function(){let t=await e.decrypt({c:d},r);expect(t.text).toBe(a),expect(c[2].header.kid).toBe("c"),expect(c[2].header.alg).toBe("PBES2-HS512+A256KW")})),it("handles binary, and decrypts as same.",(async function(){let t=new Uint8Array([21,31]),a=await e.encrypt(o,t),r=await e.decrypt(s,a),i=e.decodeProtectedHeader(a);expect(i.cty).toBeUndefined(),b(r,t)})),it("handles text, and decrypts as same.",(async function(){let t=await e.encrypt(o,a),r=await e.decrypt(s,t),i=e.decodeProtectedHeader(t);expect(i.cty).toBe("text/plain"),expect(r.text).toBe(a)})),it("handles json, and decrypts as same.",(async function(){let t={foo:"bar"},a=await e.encrypt(o,t),r=e.decodeProtectedHeader(a),i=await e.decrypt(s,a);expect(r.cty).toBe("json"),expect(i.json).toEqual(t)})),it("Uses specified headers if supplied, including cty.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await e.encrypt(o,r,{cty:t,iat:a,foo:17}),n=await e.decrypt(s,i),c=e.decodeProtectedHeader(i);expect(c.cty).toBe(t),expect(c.iat).toBe(a),expect(c.foo).toBe(17),expect(n.text).toBe(r)})),it("produces undefined for wrong symmetric key.",(async function(){let t=await e.generateSymmetricKey(),a=await e.decrypt({a:t},r);expect(a).toBeUndefined()})),it("produces undefined for wrong keypair.",(async function(){let t=await e.generateEncryptingKey(),a=await e.decrypt({b:t.privateKey},r);expect(a).toBeUndefined()})),it("produces undefined for wrong secret text.",(async function(){let t=await e.decrypt({c:"shh! "},r);expect(t).toBeUndefined()})),it("produces undefined for mislabeled key.",(async function(){let t=await e.decrypt({a:d},r);expect(t).toBeUndefined()}))}))})),describe("export/wrap",(function(){let r,i;beforeAll((async function(){let t=await e.generateEncryptingKey(),a=await e.generateEncryptingKey(),n=await e.generateEncryptingKey();r={a:t.publicKey,b:a.publicKey},i={c:n.privateKey,b:a.privateKey}}),t),it("exports homogenous member.",(async function(){let t=await e.exportJWK(r),n=await e.importJWK(t),c=await e.encrypt(n,a),o=await e.decrypt(i,c);expect(t.keys[0].kid).toBe("a"),expect(t.keys[1].kid).toBe("b"),expect(o.text).toBe(a)})),it("export heterogenous members.",(async function(){let t=await e.generateEncryptingKey(),a=await e.generateSigningKey(),r=await e.exportJWK({myDecrypt:t.privateKey,mySign:a.privateKey}),i=await e.importJWK(r),n="a smaller message for asymmetric encryption",c=await e.encrypt(t.publicKey,n),o=await e.decrypt(i.myDecrypt,c),s=await e.sign(i.mySign,n);expect(r.keys[0].kid).toBe("myDecrypt"),expect(r.keys[1].kid).toBe("mySign"),expect(o.text).toBe(n),expect(await e.verify(a.publicKey,s)).toBeTruthy()})),it("can wrap/unwrap a simple key.",(async function(){let t=await e.generateSymmetricKey(),n=await e.wrapKey(t,r),c=await e.unwrapKey(n,i),o=await e.encrypt(c,a),s=await e.decrypt(t,o);expect(s.text).toBe(a)})),it("can be wrapped/unwrapped by a symmetric key with homogenous members.",(async function(){let t=await e.generateSymmetricKey(),n=await e.wrapKey(r,t),c=await e.unwrapKey(n,t),o=await e.encrypt(c,a),s=await e.decrypt(i,o);expect(s.text).toBe(a)})),it("can wrap/unwrap a symmetric multikey with homogenous members.",(async function(){let t={x:await e.generateSymmetricKey(),y:await e.generateSymmetricKey()},a=await e.wrapKey(t,r),n=await e.unwrapKey(a,i),c=f(),o=await e.encrypt(n,c),s=await e.decrypt(t,o);expect(s.text).toBe(c)})),it("can wrap/unwrap a heterogeneous multikey.",(async function(){let t=await e.generateEncryptingKey(),a=await e.generateSigningKey(),n=await e.wrapKey({myDecrypt:t.privateKey,mySign:a.privateKey},r),c=await e.unwrapKey(n,i),o="a shorter message",s=await e.encrypt(t.publicKey,o),d=await e.decrypt(c.myDecrypt,s),y=await e.sign(c.mySign,o);expect(d.text).toBe(o),expect(await e.verify(a.publicKey,y)).toBeTruthy()}),t)}))}(ct)})),describe("Security",(function(){const a=25e3;async function r(e){let t,a,r={},[i,n,c]=await Promise.all([e.create(),e.create({prompt:"what?"}),e.create({prompt:"nope!"})]);await St((async function(){t=await e.create(),a=await e.create(t)}));let o=await e.create(i),[s,d]=await Promise.all([e.create(o,a),e.create(a,o)]);return r.device=i,r.otherDevice=t,r.recovery=n,r.otherRecovery=c,r.user=o,r.otherUser=a,r.team=s,r.otherTeam=d,r}async function i(e,t){await e.destroy(t.otherTeam),await e.destroy(t.team),await e.destroy(t.user),await e.destroy(t.device),await e.destroy(t.recovery),await e.destroy(t.otherRecovery),await St((async function(){await e.destroy(t.otherUser),await e.destroy(t.otherDevice)}))}describe("internal machinery",(function(){let n;function c(a,r){describe(a,(function(){let a,i;beforeAll((async function(){i=n[r],a=await yt.ensure(i)})),it("tag is exported verify key, and sign() pairs with it.",(async function(){let e=await ct.importRaw(i),a=await ct.exportRaw(e);expect(typeof i).toBe("string"),expect(a).toBe(i);let r=await yt.ensure(i),n=await yt.sign(t,{tags:[i],signingKey:r.signingKey}),c=await ct.verify(e,n);m(n),expect(c).toBeTruthy()})),it("public encryption tag can be retrieved externally, and vault.decrypt() pairs with it.",(async function(){let r=a.tag,i=await e.retrieve("EncryptionKey",r),n=await w.verify(i,r),c=await ct.importJWK(n.json),o=await ct.encrypt(c,t),s=await a.decrypt(o);expect(s.text).toBe(t)}))}))}beforeAll((async function(){n=await r(bt)}),a),afterAll((async function(){await i(bt,n)}),a),c("DeviceKeySet","device"),c("RecoveryKeySet","recovery"),c("TeamKeySet","user"),describe("local store",(function(){var e;beforeAll((async function(){e=new ot({dbName:"testStore",collectionName:"Foo"}),await new Promise((e=>setTimeout(e,2e3)))})),it("can remove without existing.",(async function(){expect(await e.remove("nonExistant")).toBe("")})),it("can retrieve without existing.",(async function(){expect(await e.retrieve("nonExistant")).toBe("")})),it("retrieves and can remove what is stored.",(async function(){let t="x",a="hello";expect(await e.store(t,a)).not.toBeUndefined(),expect(await e.retrieve(t)).toBe(a),expect(await e.remove(t)).toBe(""),expect(await e.retrieve(t)).toBe("")})),it("can write a lot without getting jumbled.",(async function(){let t,a,r,i=1e3,n=[];for(let e=0;e<i;e++)n.push("y"+e);t=Date.now();let c=await Promise.all(n.map(((t,a)=>e.store(t,a.toString()))));a=Date.now()-t,r=a/i,expect(r).toBeLessThan(5),c.forEach((e=>expect(e).not.toBeUndefined())),t=Date.now();let o=await Promise.all(n.map((t=>e.retrieve(t))));a=Date.now()-t,r=a/i,expect(r).toBeLessThan(3),o.forEach(((e,t)=>expect(e).toBe(t.toString()))),t=Date.now();let s=await Promise.all(n.map((t=>e.remove(t))));a=Date.now()-t,r=a/i,expect(r).toBeLessThan(5),s.forEach((e=>expect(e).toBe(""))),t=Date.now();let d=await Promise.all(n.map((t=>e.retrieve(t))));a=Date.now()-t,r=a/i,expect(r).toBeLessThan(.1),d.forEach((e=>expect(e).toBe("")))}),1e6)}))})),describe("API",(function(){let n;function c(e,a,r,i){describe(e,(function(){let e,c;beforeAll((function(){e=n[a],c=n[r]})),describe("signature",(function(){describe("of one tag",(function(){it("can sign and be verified.",(async function(){let a=await w.sign(t,e);m(a),expect(await w.verify(a,e)).toBeTruthy()})),it("can be verified with the tag included in the signature.",(async function(){let a=await w.sign(t,e);expect(await w.verify(a)).toBeTruthy()})),it("cannot sign for a different key.",(async function(){let a=await w.sign(t,c);expect(await w.verify(a,e)).toBeUndefined()})),it("cannot sign with an unowned key.",(async function(){expect(await w.sign("something",n[i]).catch((()=>{}))).toBeUndefined()})),it("distinguishes between correctly signing false and key failure.",(async function(){let t=await w.sign(!1,e),a=await w.verify(t,e);expect(a.json).toBe(!1)})),it("can sign text and produce verified result with text property.",(async function(){let a=await w.sign(t,e),r=await w.verify(a,e);m(a),expect(r.text).toBe(t)})),it("can sign json and produce verified result with json property.",(async function(){let t={x:1,y:["abc",null,!1]},a=await w.sign(t,e),r=await w.verify(a,e);m(a),expect(r.json).toEqual(t)})),it("can sign binary and produce verified result with payload property.",(async function(){let t=new Uint8Array([1,2,3]),a=await w.sign(t,e),r=await w.verify(a,e);m(a),expect(r.payload).toEqual(t)})),it("uses contentType and time if supplied.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await w.sign(r,{tags:[e],contentType:t,time:a}),n=await w.verify(i,e);m(i),expect(n.text).toEqual(r),expect(n.protectedHeader.cty).toBe(t),expect(n.protectedHeader.iat).toBe(a)}))})),describe("of multiple tags",(function(){it("can sign and be verified.",(async function(){let a=await w.sign(t,e,c),r=await w.verify(a,c,e);expect(r).toBeTruthy(),expect(r.signers[0].payload).toBeTruthy(),expect(r.signers[1].payload).toBeTruthy()})),it("does not attempt to verify unenumerated tags if any are explicit",(async function(){let a=await w.sign(t,e,c),r=await w.verify(a,c);expect(r).toBeTruthy(),expect(r.signers[0].payload).toBeFalsy(),expect(r.signers[1].payload).toBeTruthy()})),it("can be verified with the tag included in the signature.",(async function(){let a=await w.sign(t,e,c),r=await w.verify(a);expect(r).toBeTruthy(),expect(r.signers[0].payload).toBeTruthy(),expect(r.signers[1].payload).toBeTruthy()})),describe("bad verification",(function(){let a;beforeAll((async function(){a=await w.create()})),afterAll((async function(){await w.destroy(a)})),describe("when mixing single and multi-tags",(function(){it("fails with extra signing tag.",(async function(){let a=await w.sign(t,c);expect(await w.verify(a,e)).toBeUndefined()})),it("fails with extra verifying.",(async function(){let a=await w.sign(t,e);expect(await w.verify(a,e,c)).toBeUndefined()}))})),describe("when mixing multi-tag lengths",(function(){it("fails with mismatched signing tag.",(async function(){let r=await w.sign(t,c,a),i=await w.verify(r,e,a);expect(i).toBeUndefined()})),it("fails with extra verifying tag.",(async function(){let r=await w.sign(t,e,a);expect(await w.verify(r,e,c,a)).toBeUndefined()}))}))})),it("distinguishes between correctly signing false and key failure.",(async function(){let t=await w.sign(!1,e,c),a=await w.verify(t,e,c);expect(a.json).toBe(!1)})),it("can sign text and produce verified result with text property.",(async function(){let a=await w.sign(t,e,c),r=await w.verify(a,e,c);expect(r.text).toBe(t)})),it("can sign json and produce verified result with json property.",(async function(){let t={x:1,y:["abc",null,!1]},a=await w.sign(t,e,c),r=await w.verify(a,e,c);expect(r.json).toEqual(t)})),it("can sign binary and produce verified result with payload property.",(async function(){let t=new Uint8Array([1,2,3]),a=await w.sign(t,e,c),r=await w.verify(a,e,c);expect(r.payload).toEqual(t)})),it("uses contentType and time if supplied.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await w.sign(r,{tags:[e,c],contentType:t,time:a}),n=await w.verify(i,e,c);expect(n.text).toEqual(r),expect(n.protectedHeader.cty).toBe(t),expect(n.protectedHeader.iat).toBe(a)}))}))})),describe("encryption",(function(){describe("with a single tag",(function(){it("can decrypt what is encrypted for it.",(async function(){let a=await w.encrypt(t,e),r=await w.decrypt(a,e);m(a),expect(r.text).toBe(t)})),it("can be decrypted using the tag included in the encryption.",(async function(){let a=await w.encrypt(t,e),r=await w.decrypt(a);expect(r.text).toBe(t)})),it("is url-safe base64.",(async function(){m(await w.encrypt(t,e))})),it("specifies kid.",(async function(){let a=nt.decodeProtectedHeader(await w.encrypt(t,e));expect(a.kid).toBe(e)})),it("cannot decrypt what is encrypted for a different key.",(async function(){let t=f(446),a=await w.encrypt(t,c),r=await w.decrypt(a,e).catch((e=>e.message));expect(r.toLowerCase()).toContain("operation")})),it("handles binary, and decrypts as same.",(async function(){let t=new Uint8Array([21,31]),a=await w.encrypt(t,e),r=await w.decrypt(a,e),i=nt.decodeProtectedHeader(a);expect(i.cty).toBeUndefined(),b(r,t)})),it("handles text, and decrypts as same.",(async function(){let a=await w.encrypt(t,e),r=await w.decrypt(a,e),i=nt.decodeProtectedHeader(a);expect(i.cty).toBe("text/plain"),expect(r.text).toBe(t)})),it("handles json, and decrypts as same.",(async function(){let t={foo:"bar"},a=await w.encrypt(t,e),r=await w.decrypt(a,e),i=nt.decodeProtectedHeader(a);expect(i.cty).toBe("json"),expect(r.json).toEqual(t)})),it("uses contentType and time if supplied.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await w.encrypt(r,{tags:[e],contentType:t,time:a}),n=await w.decrypt(i,e),c=nt.decodeProtectedHeader(i);expect(c.cty).toBe(t),expect(c.iat).toBe(a),expect(n.text).toBe(r)}))})),describe("with multiple tags",(function(){it("can be decrypted by any one of them.",(async function(){let a=await w.encrypt(t,e,c),r=await w.decrypt(a,e),i=await w.decrypt(a,c);expect(r.text).toBe(t),expect(i.text).toBe(t)})),it("can be decrypted using the tag included in the encryption.",(async function(){let a=await w.encrypt(t,e,c),r=await w.decrypt(a);expect(r.text).toBe(t)})),it("can be be made with tags you do not own.",(async function(){let a=await w.encrypt(t,e,n[i],c),r=await w.decrypt(a,e),o=await w.decrypt(a,c);expect(r.text).toBe(t),expect(o.text).toBe(t)})),it("cannot be decrypted by a different tag.",(async function(){let a=await w.encrypt(t,e,n[i]),r=await w.decrypt(a,c);expect(r).toBeUndefined()})),it("specifies kid in each recipient.",(async function(){let a=(await w.encrypt(t,e,c)).recipients;expect(a.length).toBe(2),expect(a[0].header.kid).toBe(e),expect(a[1].header.kid).toBe(c)})),it("handles binary, and decrypts as same.",(async function(){let t=new Uint8Array([21,31]),a=await w.encrypt(t,e,c),r=await w.decrypt(a,e),i=nt.decodeProtectedHeader(a);expect(i.cty).toBeUndefined(),b(r,t)})),it("handles text, and decrypts as same.",(async function(){let a=await w.encrypt(t,e,c),r=await w.decrypt(a,e),i=nt.decodeProtectedHeader(a);expect(i.cty).toBe("text/plain"),expect(r.text).toBe(t)})),it("handles json, and decrypts as same.",(async function(){let t={foo:"bar"},a=await w.encrypt(t,e,c),r=await w.decrypt(a,e),i=nt.decodeProtectedHeader(a);expect(i.cty).toBe("json"),expect(r.json).toEqual(t)})),it("uses contentType and time if supplied.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await w.encrypt(r,{tags:[e,c],contentType:t,time:a}),n=await w.decrypt(i,e),o=nt.decodeProtectedHeader(i);expect(o.cty).toBe(t),expect(o.iat).toBe(a),expect(n.text).toBe(r)}))}))}))}))}beforeAll((async function(){console.log(await w.ready),n=await r(w)}),a),afterAll((async function(){await i(w,n)}),a),c("DeviceKeySet","device","user","otherDevice"),c("RecoveryKeySet","recovery","otherRecovery","otherDevice"),c("User TeamKeySet","user","device","otherUser"),c("Team TeamKeySet","team","otherTeam","otherUser"),describe("storage",(function(){it("will only let a current member write new keys.",(async function(){let t=await w.create(),a=n.team,r=await e.retrieve("Team",a),i=(await w.verify(r)).json;function c(){return w.sign(i,{team:a,member:t,time:Date.now()})}await w.changeMembership({tag:a,add:[t]});let o=await c();expect(await e.store("Team",n.team,o)).toBeDefined(),await w.changeMembership({tag:a,remove:[t]});let s=await c();expect(await e.store("Team",a,s).catch((()=>"failed"))).toBe("failed"),expect(await e.store("Team",a,o).catch((()=>"failed"))).toBe("failed"),expect(await e.store("Team",a,r).catch((()=>"failed"))).toBe("failed"),await w.destroy(t)})),it("will only let a current member write new public encryption key.",(async function(){let t=await w.create(),a=n.team,r=await e.retrieve("EncryptionKey",a),i=(await w.verify(r)).json;function c(){return w.sign(i,{team:a,member:t,time:Date.now()})}await w.changeMembership({tag:a,add:[t]});let o=await c();expect(await e.store("EncryptionKey",n.team,o)).toBeDefined(),await w.changeMembership({tag:a,remove:[t]});let s=await c();expect(await e.store("EncryptionKey",a,s).catch((()=>"failed"))).toBe("failed"),expect(await e.store("EncryptionKey",a,o).catch((()=>"failed"))).toBe("failed"),expect(await e.store("EncryptionKey",a,r).catch((()=>"failed"))).toBe("failed"),await w.destroy(t)}),1e4),it("will only let owner of a device write new public device encryption key.",(async function(){let t=await w.create(),a=await w.create(),r=await e.retrieve("EncryptionKey",t),i=(await w.verify(r)).json;function n(e){return w.sign(i,{tags:[e],time:Date.now()})}let c=await n(t);expect(await e.store("EncryptionKey",t,c)).toBeDefined();let o=await n(a);expect(await e.store("EncryptionKey",t,o).catch((()=>"failed"))).toBe("failed"),expect(await e.store("EncryptionKey",t,c)).toBeDefined,expect(await e.store("EncryptionKey",t,r).catch((()=>"failed"))).toBe("failed"),await w.destroy(t),await w.destroy(a)}),1e4)})),describe("auditable signatures",(function(){describe("by an explicit member",(function(){let e,a;beforeAll((async function(){e=await w.sign(t,{team:n.team,member:n.user}),a=await w.verify(e,n.team,n.user)})),it("recognizes a team with a member.",(async function(){expect(a).toBeTruthy(),expect(a.text).toBe(t)})),it("defines iss.",(function(){expect(a.protectedHeader.iss).toBe(n.team)})),it("defines act.",(function(){expect(a.protectedHeader.act).toBe(n.user)}))})),describe("automatically supplies a valid member",(function(){it("if you have access",(async function(){let e=await w.sign(t,{team:n.team}),a=nt.decodeProtectedHeader(e.signatures[0]).act,r=await w.verify(e,n.team,a);expect(r).toBeTruthy(),expect(a).toBeTruthy(),expect(r.protectedHeader.act).toBe(a),expect(r.protectedHeader.iat).toBeTruthy()}))})),describe("with a valid user who is not a member",(function(){let e;beforeAll((async function(){e=await w.create(n.device)})),afterAll((async function(){await w.destroy(e)})),it("verifies as an ordinary dual signature.",(async function(){let a=await w.sign(t,n.team,e),r=await w.verify(a,n.team,e);expect(r.text).toBe(t),expect(r.protectedHeader.iss).toBeUndefined(),expect(r.protectedHeader.act).toBeUndefined()}),1e4),it("does not verify as a dual signature specifying team and member.",(async function(){let a=await w.sign(t,{team:n.team,member:e}),r=await w.verify(a,n.team,e);expect(r).toBeUndefined()}))})),describe("with a past member",(function(){let e,t,a;beforeAll((async function(){a=Date.now()-1,e=await w.create(),await w.changeMembership({tag:n.team,add:[e]}),t=await w.sign("message",{team:n.team,member:e,time:a}),await w.changeMembership({tag:n.team,remove:[e]})})),afterAll((async function(){await w.destroy(e)})),it("fails by default.",(async function(){let a=await w.verify(t,e);expect(a).toBeUndefined()})),it("contains act in signature but verifies if we tell it not to check membership.",(async function(){let a=await w.verify(t,{team:n.team,member:!1});expect(a).toBeTruthy(),expect(a.text).toBe("message"),expect(a.protectedHeader.act).toBe(e),expect(a.protectedHeader.iat).toBeTruthy()})),it('fails if we tell it to check notBefore:"team", even if we tell it not to check membership.',(async function(){let e=await w.verify(t,{team:n.team,member:!1,notBefore:"team"});expect(e).toBeUndefined()}))}))})),describe("miscellaneous",(function(){it("can safely be used when a device is removed, but not after being entirely destroyed.",(async function(){let[e,a]=await Promise.all([w.create(),w.create()]),r=await w.create(e,a),i=await w.create(r),n=await w.encrypt(t,i),c=await w.decrypt(n,i);expect(c.text).toBe(t),c=await w.decrypt(n,i),await w.changeMembership({tag:r,remove:[e]}),expect(c.text).toBe(t),await w.changeMembership({tag:r,add:[e]}),c=await w.decrypt(n,i),expect(c.text).toBe(t),await w.destroy(a),c=await w.decrypt(n,i),expect(c.text).toBe(t),await w.destroy({tag:i,recursiveMembers:!0});let o=await w.decrypt(n,i).then((()=>null),(e=>e.message));expect(o).toBeTruthy()}),a),it("device is useable as soon as it resolves.",(async function(){let e=await w.create();expect(await w.sign("anything",e)).toBeTruthy(),await w.destroy(e)}),1e4),it("team is useable as soon as it resolves.",(async function(){let e=await w.create(n.device);expect(await w.sign("anything",e)).toBeTruthy(),await w.destroy(e)})),it("allows recovery prompts that contain dot.",(async function(){let e=await w.create({prompt:"foo.bar"}),t=await w.create(e),a="red.white",r=await w.encrypt(a,t),i=await w.decrypt(r,t),n=await w.sign(a,t);expect(i.text).toBe(a),expect(await w.verify(n,t)).toBeTruthy(),await w.destroy({tag:t,recursiveMembers:!0})}),1e4),it("supports rotation.",(async function(){let e=await w.create(n.device),t=await w.create(e),a=await w.sign("some purchase order",{team:t,member:e}),r=await w.encrypt("the other set of books",t);expect(await w.verify(a)).toBeTruthy(),expect(await w.verify(a,{team:t,member:!1})).toBeTruthy(),expect(await w.decrypt(r)).toBeTruthy();let i=await w.create(n.device),c=await w.create(n.device);await w.changeMembership({tag:t,remove:[e],add:[i,c]}),await w.destroy(e),expect(await w.sign("bogus PO",{team:t,member:e}).catch((()=>{}))).toBeUndefined();let o=await w.sign("new PO",{team:t,member:i}),s=await w.sign("new PO",{team:t,member:c});expect(await w.verify(o)).toBeTruthy(),expect(await w.verify(s)).toBeTruthy(),expect(await w.verify(a).catch((()=>{}))).toBeUndefined(),expect(await w.verify(a,{team:t,member:!1})).toBeTruthy(),expect(await w.decrypt(r)).toBeTruthy();let d=await w.create(i);await w.destroy(t),expect(await w.sign("bogus PO",{team:t,member:i}).catch((()=>{}))).toBeUndefined(),expect(await w.sign("new new PO",{team:d,member:i})).toBeTruthy(),expect(await w.verify(a,{team:t,member:!1})).toBeTruthy(),expect(await w.verify(o)).toBeTruthy(),expect(await w.verify(s)).toBeTruthy(),expect(await w.decrypt(r).catch((()=>{}))).toBeUndefined()}),15e3)}))}))}))}));
