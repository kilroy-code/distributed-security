const e={origin:new URL(import.meta.url).origin,async store(e,t,a){let r=await this.Security.verify(a,{team:t,notBefore:"team"});if(!r)throw new Error(`Signature ${a} does not match owner of ${t}.`);return r.payload.length?this[e][t]=a:delete this[e][t],null},async retrieve(e,t){return this[e][t]},Team:{},KeyRecovery:{},EncryptionKey:{}};const t=new URL(import.meta.url).origin,a=/(\S{50})(\S{2})(\S{2})(\S+)/;async function r(e){if(404===e.status)return"";if(!e.ok)return Promise.reject(e.statusText);let t=await e.text();return t?JSON.parse(t):t}const i={get origin(){return t},tagPath:function(e,t,r="json"){if(!t)return e;let i=t.match(a);if(!i)return`${e}/${t}`;let[n,c,o,s,d]=i;return`${e}/${o}/${s}/${c}/${d}.${r}`},mkdir:undefined,uri(e,a){return`${t}/db/${this.tagPath(e,a)}`},store(e,t,a,i={}){return fetch(this.uri(e,t),{method:"PUT",body:JSON.stringify(a),headers:{"Content-Type":"application/json",...i.headers||{}}}).then(r)},retrieve(e,t,a={}){return fetch(this.uri(e,t),{cache:"default",headers:{Accept:"application/json",...a.headers||{}}}).then(r)}};var n=e=>e;function c(e,t){return t?e+n(t):e}"undefined"!=typeof window&&(n=window.prompt);const o=new URL(import.meta.url),s=new URL("vault.html",o),d=o.href,y=document.createElement("iframe"),p=new MessageChannel,l=Object.assign({log(...e){console.log(...e)},getUserDeviceSecret:c},i),u=new Promise((e=>{l.ready=e,y.style.display="none",document.body.append(y),y.setAttribute("src",s),p.port1.start(),y.onload=()=>y.contentWindow.postMessage(d,s.origin,[p.port2])})),w=function({target:e=self,receiver:t=e,namespace:a=t,origin:r=e!==t&&e.location.origin,dispatcherLabel:i=a.name||t.name||t.location?.href||t,targetLabel:n=e.name||r||e.location?.href||e,log:c=null,info:o=console.info.bind(console),warn:s=console.warn.bind(console),error:d=console.error.bind(console)}){const y={},p="2.0",l=e.postMessage.bind(e),u=r?e=>l(e,r):l;let w=0;return t.addEventListener("message",(async function(t){c?.(i,"got message",t.data,"from",n,t.origin);let{id:o,method:l,params:w=[],result:h,error:f,jsonrpc:g}=t.data||{};if(t.source&&t.source!==e)return d?.(i,"to",n,"got message from",t.source);if(r&&r!==t.origin)return d?.(i,r,"mismatched origin",n,t.origin);if(g!==p)return s?.(`${i} ignoring non-jsonrpc message ${JSON.stringify(t.data)}.`);if(l){let e,t=null,r=Array.isArray(w)?w:[w];try{e=await a[l](...r)}catch(e){t=function(e){let{name:t,message:a,code:r,data:i}=e;return{name:t,message:a,code:r,data:i}}(e),a[l]||t.message.includes(l)?t.message||(t.message=`${t.name||t.toString()} in ${l}.`):(t.message=`${l} is not defined.`,t.code=-32601)}if(void 0===o)return;let s=t?{id:o,error:t,jsonrpc:p}:{id:o,result:e,jsonrpc:p};return c?.(i,"answering",o,t||e,"to",n),u(s)}let m=y[o];if(delete y[o],!m)return s?.(`${i} ignoring response ${t.data}.`);f?m.reject(f):m.resolve(h)})),o?.(`${i} will dispatch to ${n}`),function(e,...t){let a=++w,r=y[a]={};return new Promise(((o,s)=>{c?.(i,"request",a,e,t,"to",n),Object.assign(r,{resolve:o,reject:s}),u({id:a,method:e,params:t,jsonrpc:p})}))}}({dispatcherLabel:"entry!"+d,namespace:l,target:p.port1,targetLabel:"vault!"+d}),h={sign:(e,...t)=>w("sign",e,...t),verify:(e,...t)=>w("verify",e,...t),encrypt:(e,...t)=>w("encrypt",e,...t),decrypt:(e,...t)=>w("decrypt",e,...t),create:(...e)=>w("create",...e),changeMembership:({tag:e,add:t,remove:a}={})=>w("changeMembership",{tag:e,add:t,remove:a}),destroy:e=>w("destroy",e),clear:(e=null)=>w("clear",e),ready:u,get Storage(){return l},set Storage(e){Object.assign(l,e)},get getUserDeviceSecret(){return l.getUserDeviceSecret},set getUserDeviceSecret(e){l.getUserDeviceSecret=e}},f=10485760;function g(e=f){return Array.from({length:e},((e,t)=>1&t)).join("")}const m=/^[A-Za-z0-9_\-.]+$/;function b(e,t=m){expect(t.test(e)).toBeTruthy()}function v(e,t){expect(new Uint8Array(e.payload)).toEqual(t)}function E(e,t=446){const a=15e3,r=t>1e3?a:5e3,i=g();describe("signing",(function(){let t;beforeAll((async function(){t=await e.generateSigningKey()})),it("with a private key produces a base64URL signature that verifies with the public key.",(async function(){let a=await e.sign(t.privateKey,i);b(a),expect(await e.verify(t.publicKey,a)).toBeTruthy()})),it("returns undefined for verify with the wrong key.",(async function(){let a=await e.sign(t.privateKey,i),r=await e.generateSigningKey();expect(await e.verify(r.publicKey,a)).toBeUndefined()})),it("handles binary, and verifies with that as payload property.",(async function(){let a=new Uint8Array([21,31]),r=await e.sign(t.privateKey,a),i=await e.verify(t.publicKey,r);expect(i.cty).toBeUndefined(),v(i,a)})),it('handles text, setting cty as "text/plain", and verifies with that as the text property and an encoding of that for payload.',(async function(){let a=await e.sign(t.privateKey,i),r=await e.verify(t.publicKey,a);expect(r.protectedHeader.cty).toBe("text/plain"),expect(r.text).toBe(i),expect(r.payload).toEqual((new TextEncoder).encode(i))})),it('handles json, setting cty as "json", and verifies with that as json property, the string of that as the text property, and the encoding of that string for payload.',(async function(){let a={foo:"bar"},r=await e.sign(t.privateKey,a),i=await e.verify(t.publicKey,r);expect(i.protectedHeader.cty).toBe("json"),expect(i.json).toEqual(a),expect(i.text).toBe(JSON.stringify(a)),expect(i.payload).toEqual((new TextEncoder).encode(JSON.stringify(a)))})),it("Uses specified headers if supplied, including cty.",(async function(){let a="text/html",r=Date.now(),i="<something else>",n=await e.sign(t.privateKey,i,{cty:a,iat:r,foo:17}),c=await e.verify(t.publicKey,n);expect(c.protectedHeader.cty).toBe(a),expect(c.protectedHeader.iat).toBe(r),expect(c.protectedHeader.foo).toBe(17),expect(c.text).toEqual(i)}))})),describe("encryption",(function(){let n;function c(t,a,r=a){it(`can work on much larger data with a ${t}.`,(async function(){let t=await a,n=await r,c=await e.encrypt(t,i),o=await e.decrypt(n,c);b(c),expect(o.text).toBe(i)}))}function o(r,i){it(`rejects wrong ${r}.`,(async function(){let[a,r]=await i(),n=g(t),c=await e.encrypt(a,n);await expectAsync(e.decrypt(r,c)).toBeRejected()}),a)}beforeAll((async function(){n=await e.generateEncryptingKey()})),it(`can work up through at least ${t} bytes with an asymmetric keypair.`,(async function(){let a=g(t),r=await e.encrypt(n.publicKey,a),i=await e.decrypt(n.privateKey,r);b(r),expect(i.text).toBe(a)}),r),c("fixed symmetric key",e.generateSymmetricKey()),c("reproducible secret",e.generateSymmetricKey("secret"),e.generateSymmetricKey("secret")),it("handles binary, and decrypts as same.",(async function(){let t=new Uint8Array([21,31]),a=await e.encrypt(n.publicKey,t),r=await e.decrypt(n.privateKey,a),i=e.decodeProtectedHeader(a);expect(i.cty).toBeUndefined(),v(r,t)})),it("handles text, and decrypts as same.",(async function(){let t=await e.encrypt(n.publicKey,i),a=await e.decrypt(n.privateKey,t),r=e.decodeProtectedHeader(t);expect(r.cty).toBe("text/plain"),expect(a.text).toBe(i)})),it("handles json, and decrypts as same.",(async function(){let t={foo:"bar"},a=await e.encrypt(n.publicKey,t),r=e.decodeProtectedHeader(a),i=await e.decrypt(n.privateKey,a);expect(r.cty).toBe("json"),expect(i.json).toEqual(t)})),it("Uses specified headers if supplied, including cty.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await e.encrypt(n.publicKey,r,{cty:t,iat:a,foo:17}),c=await e.decrypt(n.privateKey,i),o=e.decodeProtectedHeader(i);expect(o.cty).toBe(t),expect(o.iat).toBe(a),expect(o.foo).toBe(17),expect(c.text).toBe(r)})),o("asymmetric key",(async()=>[(await e.generateEncryptingKey()).publicKey,(await e.generateEncryptingKey()).privateKey])),o("symmetric key",(async()=>[await e.generateSymmetricKey(),await e.generateSymmetricKey()])),o("secret",(async()=>[await e.generateSymmetricKey("secret"),await e.generateSymmetricKey("secretX")]))})),describe("export/import",(function(){async function t(t){return JSON.stringify(await e.exportJWK(t))}function a(t){return e.importJWK(JSON.parse(t))}describe("of signing keys",(function(){it("works with the private signing key as a 253 byte serialization.",(async function(){let r=await e.generateSigningKey(),n=await t(r.privateKey),c=await a(n),o=await e.sign(c,i);expect(n.length).toBe(253),expect(await e.verify(r.publicKey,o)).toBeTruthy()}));it("works with the public verifying key as a 182 byte serialization.",(async function(){let r=await e.generateSigningKey(),n=await t(r.publicKey),c=await a(n),o=await e.sign(r.privateKey,i);expect(n.length).toBe(182),expect(await e.verify(c,o)).toBeTruthy()}));it("works with public key as a raw verifying key as a base64URL serialization of no more that 132 bytes",(async function(){let t=await e.generateSigningKey(),a=await e.exportRaw(t.publicKey),r=await e.importRaw(a),n=await e.sign(t.privateKey,i);b(a),expect(a.length).toBeLessThanOrEqual(132),expect(await e.verify(r,n)).toBeTruthy()}))})),describe("of encryption keys",(function(){const r=[3169,3173];it(`works with the private key as a ${r[0]}-${r[1]} byte serialization.`,(async function(){let i=await e.generateEncryptingKey(),n=await t(i.privateKey),c=await a(n),o=g(446),s=await e.encrypt(i.publicKey,o),d=await e.decrypt(c,s);expect(n.length).toBeGreaterThanOrEqual(r[0]),expect(n.length).toBeLessThanOrEqual(r[1]),expect(d.text).toBe(o)}));it("works with the public key as a 735 byte serialization.",(async function(){let r=await e.generateEncryptingKey(),i=await t(r.publicKey),n=await a(i),c=g(446),o=await e.encrypt(n,c),s=await e.decrypt(r.privateKey,o);expect(i.length).toBe(735),expect(s.text).toBe(c)}))})),describe("of symmetric key",(function(){it("works as a 79 byte serialization.",(async function(){let r=await e.generateSymmetricKey(),n=await t(r),c=await a(n),o=await e.encrypt(r,i),s=await e.decrypt(c,o);expect(n.length).toBe(79),expect(s.text).toBe(i)}))}))})),it("wraps like export+encrypt.",(async function(){let t=await e.generateSymmetricKey(),a=await e.generateEncryptingKey(),r=await e.exportJWK(t),i=await e.encrypt(a.publicKey,r),n=await e.decrypt(a.privateKey,i),c=await e.importJWK(n.json),o=await e.wrapKey(t,a.publicKey),s=await e.unwrapKey(o,a.privateKey),d="this is a message",y=await e.encrypt(s,d),p=await e.decrypt(c,y);b(o),expect(p.text).toBe(d)}),a)}var S=crypto;const x=e=>e instanceof CryptoKey,K=async(e,t)=>{const a=`SHA-${e.slice(-3)}`;return new Uint8Array(await S.subtle.digest(a,t))},A=new TextEncoder,H=new TextDecoder,B=2**32;function P(...e){const t=e.reduce(((e,{length:t})=>e+t),0),a=new Uint8Array(t);let r=0;for(const t of e)a.set(t,r),r+=t.length;return a}function k(e,t,a){if(t<0||t>=B)throw new RangeError(`value must be >= 0 and <= ${B-1}. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,255&t],a)}function C(e){const t=Math.floor(e/B),a=e%B,r=new Uint8Array(8);return k(r,t,0),k(r,a,4),r}function T(e){const t=new Uint8Array(4);return k(t,e),t}function U(e){return P(T(e.length),e)}const W=e=>(e=>{let t=e;"string"==typeof t&&(t=A.encode(t));const a=[];for(let e=0;e<t.length;e+=32768)a.push(String.fromCharCode.apply(null,t.subarray(e,e+32768)));return btoa(a.join(""))})(e).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),_=e=>{let t=e;t instanceof Uint8Array&&(t=H.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return(e=>{const t=atob(e),a=new Uint8Array(t.length);for(let e=0;e<t.length;e++)a[e]=t.charCodeAt(e);return a})(t)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}};class J extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(e){super(e),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,Error.captureStackTrace?.(this,this.constructor)}}class D extends J{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class R extends J{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class j extends J{constructor(){super(...arguments),this.code="ERR_JWE_DECRYPTION_FAILED",this.message="decryption operation failed"}static get code(){return"ERR_JWE_DECRYPTION_FAILED"}}class O extends J{constructor(){super(...arguments),this.code="ERR_JWE_INVALID"}static get code(){return"ERR_JWE_INVALID"}}class M extends J{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class $ extends J{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}var I=S.getRandomValues.bind(S);function G(e){switch(e){case"A128GCM":case"A128GCMKW":case"A192GCM":case"A192GCMKW":case"A256GCM":case"A256GCMKW":return 96;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return 128;default:throw new R(`Unsupported JWE Algorithm: ${e}`)}}const L=(e,t)=>{if(t.length<<3!==G(e))throw new O("Invalid Initialization Vector length")},N=(e,t)=>{const a=e.byteLength<<3;if(a!==t)throw new O(`Invalid Content Encryption Key length. Expected ${t} bits, got ${a} bits`)};function F(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function z(e,t){return e.name===t}function q(e){return parseInt(e.name.slice(4),10)}function V(e,t){if(t.length&&!t.some((t=>e.usages.includes(t)))){let e="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const a=t.pop();e+=`one of ${t.join(", ")}, or ${a}.`}else 2===t.length?e+=`one of ${t[0]} or ${t[1]}.`:e+=`${t[0]}.`;throw new TypeError(e)}}function X(e,t,...a){switch(t){case"HS256":case"HS384":case"HS512":{if(!z(e.algorithm,"HMAC"))throw F("HMAC");const a=parseInt(t.slice(2),10);if(q(e.algorithm.hash)!==a)throw F(`SHA-${a}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!z(e.algorithm,"RSASSA-PKCS1-v1_5"))throw F("RSASSA-PKCS1-v1_5");const a=parseInt(t.slice(2),10);if(q(e.algorithm.hash)!==a)throw F(`SHA-${a}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!z(e.algorithm,"RSA-PSS"))throw F("RSA-PSS");const a=parseInt(t.slice(2),10);if(q(e.algorithm.hash)!==a)throw F(`SHA-${a}`,"algorithm.hash");break}case"EdDSA":if("Ed25519"!==e.algorithm.name&&"Ed448"!==e.algorithm.name)throw F("Ed25519 or Ed448");break;case"ES256":case"ES384":case"ES512":{if(!z(e.algorithm,"ECDSA"))throw F("ECDSA");const a=function(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}(t);if(e.algorithm.namedCurve!==a)throw F(a,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}V(e,a)}function Y(e,t,...a){switch(t){case"A128GCM":case"A192GCM":case"A256GCM":{if(!z(e.algorithm,"AES-GCM"))throw F("AES-GCM");const a=parseInt(t.slice(1,4),10);if(e.algorithm.length!==a)throw F(a,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!z(e.algorithm,"AES-KW"))throw F("AES-KW");const a=parseInt(t.slice(1,4),10);if(e.algorithm.length!==a)throw F(a,"algorithm.length");break}case"ECDH":switch(e.algorithm.name){case"ECDH":case"X25519":case"X448":break;default:throw F("ECDH, X25519, or X448")}break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!z(e.algorithm,"PBKDF2"))throw F("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!z(e.algorithm,"RSA-OAEP"))throw F("RSA-OAEP");const a=parseInt(t.slice(9),10)||1;if(q(e.algorithm.hash)!==a)throw F(`SHA-${a}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}V(e,a)}function Z(e,t,...a){if(a.length>2){const t=a.pop();e+=`one of type ${a.join(", ")}, or ${t}.`}else 2===a.length?e+=`one of type ${a[0]} or ${a[1]}.`:e+=`of type ${a[0]}.`;return null==t?e+=` Received ${t}`:"function"==typeof t&&t.name?e+=` Received function ${t.name}`:"object"==typeof t&&null!=t&&t.constructor?.name&&(e+=` Received an instance of ${t.constructor.name}`),e}var Q=(e,...t)=>Z("Key must be ",e,...t);function ee(e,t,...a){return Z(`Key for the ${e} algorithm must be `,t,...a)}var te=e=>x(e);const ae=["CryptoKey"];async function re(e,t,a,r,i,n){if(!(t instanceof Uint8Array))throw new TypeError(Q(t,"Uint8Array"));const c=parseInt(e.slice(1,4),10),o=await S.subtle.importKey("raw",t.subarray(c>>3),"AES-CBC",!1,["decrypt"]),s=await S.subtle.importKey("raw",t.subarray(0,c>>3),{hash:"SHA-"+(c<<1),name:"HMAC"},!1,["sign"]),d=P(n,r,a,C(n.length<<3)),y=new Uint8Array((await S.subtle.sign("HMAC",s,d)).slice(0,c>>3));let p,l;try{p=((e,t)=>{if(!(e instanceof Uint8Array))throw new TypeError("First argument must be a buffer");if(!(t instanceof Uint8Array))throw new TypeError("Second argument must be a buffer");if(e.length!==t.length)throw new TypeError("Input buffers must have the same length");const a=e.length;let r=0,i=-1;for(;++i<a;)r|=e[i]^t[i];return 0===r})(i,y)}catch{}if(!p)throw new j;try{l=new Uint8Array(await S.subtle.decrypt({iv:r,name:"AES-CBC"},o,a))}catch{}if(!l)throw new j;return l}const ie=async(e,t,a,r,i,n)=>{if(!(x(t)||t instanceof Uint8Array))throw new TypeError(Q(t,...ae,"Uint8Array"));if(!r)throw new O("JWE Initialization Vector missing");if(!i)throw new O("JWE Authentication Tag missing");switch(L(e,r),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return t instanceof Uint8Array&&N(t,parseInt(e.slice(-3),10)),re(e,t,a,r,i,n);case"A128GCM":case"A192GCM":case"A256GCM":return t instanceof Uint8Array&&N(t,parseInt(e.slice(1,4),10)),async function(e,t,a,r,i,n){let c;t instanceof Uint8Array?c=await S.subtle.importKey("raw",t,"AES-GCM",!1,["decrypt"]):(Y(t,e,"decrypt"),c=t);try{return new Uint8Array(await S.subtle.decrypt({additionalData:n,iv:r,name:"AES-GCM",tagLength:128},c,P(a,i)))}catch{throw new j}}(e,t,a,r,i,n);default:throw new R("Unsupported JWE Content Encryption Algorithm")}},ne=(...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let a;for(const e of t){const t=Object.keys(e);if(a&&0!==a.size)for(const e of t){if(a.has(e))return!1;a.add(e)}else a=new Set(t)}return!0};function ce(e){if("object"!=typeof(t=e)||null===t||"[object Object]"!==Object.prototype.toString.call(e))return!1;var t;if(null===Object.getPrototypeOf(e))return!0;let a=e;for(;null!==Object.getPrototypeOf(a);)a=Object.getPrototypeOf(a);return Object.getPrototypeOf(e)===a}const oe=[{hash:"SHA-256",name:"HMAC"},!0,["sign"]];function se(e,t){if(e.algorithm.length!==parseInt(t.slice(1,4),10))throw new TypeError(`Invalid key size for alg: ${t}`)}function de(e,t,a){if(x(e))return Y(e,t,a),e;if(e instanceof Uint8Array)return S.subtle.importKey("raw",e,"AES-KW",!0,[a]);throw new TypeError(Q(e,...ae,"Uint8Array"))}const ye=async(e,t,a)=>{const r=await de(t,e,"wrapKey");se(r,e);const i=await S.subtle.importKey("raw",a,...oe);return new Uint8Array(await S.subtle.wrapKey("raw",i,r,"AES-KW"))},pe=async(e,t,a)=>{const r=await de(t,e,"unwrapKey");se(r,e);const i=await S.subtle.unwrapKey("raw",a,r,"AES-KW",...oe);return new Uint8Array(await S.subtle.exportKey("raw",i))};async function le(e,t,a,r,i=new Uint8Array(0),n=new Uint8Array(0)){if(!x(e))throw new TypeError(Q(e,...ae));if(Y(e,"ECDH"),!x(t))throw new TypeError(Q(t,...ae));Y(t,"ECDH","deriveBits");const c=P(U(A.encode(a)),U(i),U(n),T(r));let o;o="X25519"===e.algorithm.name?256:"X448"===e.algorithm.name?448:Math.ceil(parseInt(e.algorithm.namedCurve.substr(-3),10)/8)<<3;return async function(e,t,a){const r=Math.ceil((t>>3)/32),i=new Uint8Array(32*r);for(let t=0;t<r;t++){const r=new Uint8Array(4+e.length+a.length);r.set(T(t+1)),r.set(e,4),r.set(a,4+e.length),i.set(await K("sha256",r),32*t)}return i.slice(0,t>>3)}(new Uint8Array(await S.subtle.deriveBits({name:e.algorithm.name,public:e},t,o)),r,c)}function ue(e){if(!x(e))throw new TypeError(Q(e,...ae));return["P-256","P-384","P-521"].includes(e.algorithm.namedCurve)||"X25519"===e.algorithm.name||"X448"===e.algorithm.name}async function we(e,t,a,r){!function(e){if(!(e instanceof Uint8Array)||e.length<8)throw new O("PBES2 Salt Input must be 8 or more octets")}(e);const i=function(e,t){return P(A.encode(e),new Uint8Array([0]),t)}(t,e),n=parseInt(t.slice(13,16),10),c={hash:`SHA-${t.slice(8,11)}`,iterations:a,name:"PBKDF2",salt:i},o={length:n,name:"AES-KW"},s=await function(e,t){if(e instanceof Uint8Array)return S.subtle.importKey("raw",e,"PBKDF2",!1,["deriveBits"]);if(x(e))return Y(e,t,"deriveBits","deriveKey"),e;throw new TypeError(Q(e,...ae,"Uint8Array"))}(r,t);if(s.usages.includes("deriveBits"))return new Uint8Array(await S.subtle.deriveBits(c,s,n));if(s.usages.includes("deriveKey"))return S.subtle.deriveKey(c,s,o,!1,["wrapKey","unwrapKey"]);throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"')}const he=async(e,t,a,r,i)=>{const n=await we(i,e,r,t);return pe(e.slice(-6),n,a)};function fe(e){switch(e){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return"RSA-OAEP";default:throw new R(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}var ge=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:a}=t.algorithm;if("number"!=typeof a||a<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};const me=async(e,t,a)=>{if(!x(t))throw new TypeError(Q(t,...ae));if(Y(t,e,"decrypt","unwrapKey"),ge(e,t),t.usages.includes("decrypt"))return new Uint8Array(await S.subtle.decrypt(fe(e),t,a));if(t.usages.includes("unwrapKey")){const r=await S.subtle.unwrapKey("raw",a,t,fe(e),...oe);return new Uint8Array(await S.subtle.exportKey("raw",r))}throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation')};function be(e){switch(e){case"A128GCM":return 128;case"A192GCM":return 192;case"A256GCM":case"A128CBC-HS256":return 256;case"A192CBC-HS384":return 384;case"A256CBC-HS512":return 512;default:throw new R(`Unsupported JWE Algorithm: ${e}`)}}var ve=e=>I(new Uint8Array(be(e)>>3));var Ee=async e=>{if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:t,keyUsages:a}=function(e){let t,a;switch(e.kty){case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},a=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},a=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},a=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new R('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},a=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},a=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},a=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},a=e.d?["deriveBits"]:[];break;default:throw new R('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"OKP":switch(e.alg){case"EdDSA":t={name:e.crv},a=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},a=e.d?["deriveBits"]:[];break;default:throw new R('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;default:throw new R('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:a}}(e),r=[t,e.ext??!1,e.key_ops??a],i={...e};return delete i.alg,delete i.use,S.subtle.importKey("jwk",i,...r)};async function Se(e,t){if(!ce(e))throw new TypeError("JWK must be an object");switch(t||(t=e.alg),e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return _(e.k);case"RSA":if(void 0!==e.oth)throw new R('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return Ee({...e,alg:t});default:throw new R('Unsupported "kty" (Key Type) Parameter value')}}const xe=(e,t,a)=>{e.startsWith("HS")||"dir"===e||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e)?((e,t)=>{if(!(t instanceof Uint8Array)){if(!te(t))throw new TypeError(ee(e,t,...ae,"Uint8Array"));if("secret"!==t.type)throw new TypeError(`${ae.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}})(e,t):((e,t,a)=>{if(!te(t))throw new TypeError(ee(e,t,...ae));if("secret"===t.type)throw new TypeError(`${ae.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===a&&"public"===t.type)throw new TypeError(`${ae.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===a&&"public"===t.type)throw new TypeError(`${ae.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(t.algorithm&&"verify"===a&&"private"===t.type)throw new TypeError(`${ae.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(t.algorithm&&"encrypt"===a&&"private"===t.type)throw new TypeError(`${ae.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)})(e,t,a)};const Ke=async(e,t,a,r,i)=>{if(!(x(a)||a instanceof Uint8Array))throw new TypeError(Q(a,...ae,"Uint8Array"));switch(r?L(e,r):r=I(new Uint8Array(G(e)>>3)),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return a instanceof Uint8Array&&N(a,parseInt(e.slice(-3),10)),async function(e,t,a,r,i){if(!(a instanceof Uint8Array))throw new TypeError(Q(a,"Uint8Array"));const n=parseInt(e.slice(1,4),10),c=await S.subtle.importKey("raw",a.subarray(n>>3),"AES-CBC",!1,["encrypt"]),o=await S.subtle.importKey("raw",a.subarray(0,n>>3),{hash:"SHA-"+(n<<1),name:"HMAC"},!1,["sign"]),s=new Uint8Array(await S.subtle.encrypt({iv:r,name:"AES-CBC"},c,t)),d=P(i,r,s,C(i.length<<3));return{ciphertext:s,tag:new Uint8Array((await S.subtle.sign("HMAC",o,d)).slice(0,n>>3)),iv:r}}(e,t,a,r,i);case"A128GCM":case"A192GCM":case"A256GCM":return a instanceof Uint8Array&&N(a,parseInt(e.slice(1,4),10)),async function(e,t,a,r,i){let n;a instanceof Uint8Array?n=await S.subtle.importKey("raw",a,"AES-GCM",!1,["encrypt"]):(Y(a,e,"encrypt"),n=a);const c=new Uint8Array(await S.subtle.encrypt({additionalData:i,iv:r,name:"AES-GCM",tagLength:128},n,t)),o=c.slice(-16);return{ciphertext:c.slice(0,-16),tag:o,iv:r}}(e,t,a,r,i);default:throw new R("Unsupported JWE Content Encryption Algorithm")}};async function Ae(e,t,a,r,i){switch(xe(e,t,"decrypt"),e){case"dir":if(void 0!==a)throw new O("Encountered unexpected JWE Encrypted Key");return t;case"ECDH-ES":if(void 0!==a)throw new O("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!ce(r.epk))throw new O('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(!ue(t))throw new R("ECDH with the provided key is not allowed or not supported by your javascript runtime");const i=await Se(r.epk,e);let n,c;if(void 0!==r.apu){if("string"!=typeof r.apu)throw new O('JOSE Header "apu" (Agreement PartyUInfo) invalid');try{n=_(r.apu)}catch{throw new O("Failed to base64url decode the apu")}}if(void 0!==r.apv){if("string"!=typeof r.apv)throw new O('JOSE Header "apv" (Agreement PartyVInfo) invalid');try{c=_(r.apv)}catch{throw new O("Failed to base64url decode the apv")}}const o=await le(i,t,"ECDH-ES"===e?r.enc:e,"ECDH-ES"===e?be(r.enc):parseInt(e.slice(-5,-2),10),n,c);if("ECDH-ES"===e)return o;if(void 0===a)throw new O("JWE Encrypted Key missing");return pe(e.slice(-6),o,a)}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":if(void 0===a)throw new O("JWE Encrypted Key missing");return me(e,t,a);case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{if(void 0===a)throw new O("JWE Encrypted Key missing");if("number"!=typeof r.p2c)throw new O('JOSE Header "p2c" (PBES2 Count) missing or invalid');const n=i?.maxPBES2Count||1e4;if(r.p2c>n)throw new O('JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds');if("string"!=typeof r.p2s)throw new O('JOSE Header "p2s" (PBES2 Salt) missing or invalid');let c;try{c=_(r.p2s)}catch{throw new O("Failed to base64url decode the p2s")}return he(e,t,a,r.p2c,c)}case"A128KW":case"A192KW":case"A256KW":if(void 0===a)throw new O("JWE Encrypted Key missing");return pe(e,t,a);case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{if(void 0===a)throw new O("JWE Encrypted Key missing");if("string"!=typeof r.iv)throw new O('JOSE Header "iv" (Initialization Vector) missing or invalid');if("string"!=typeof r.tag)throw new O('JOSE Header "tag" (Authentication Tag) missing or invalid');let i,n;try{i=_(r.iv)}catch{throw new O("Failed to base64url decode the iv")}try{n=_(r.tag)}catch{throw new O("Failed to base64url decode the tag")}return async function(e,t,a,r,i){const n=e.slice(0,7);return ie(n,t,a,r,i,new Uint8Array(0))}(e,t,a,i,n)}default:throw new R('Invalid or unsupported "alg" (JWE Algorithm) header value')}}function He(e,t,a,r,i){if(void 0!==i.crit&&void 0===r?.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!r||void 0===r.crit)return new Set;if(!Array.isArray(r.crit)||0===r.crit.length||r.crit.some((e=>"string"!=typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let n;n=void 0!==a?new Map([...Object.entries(a),...t.entries()]):t;for(const t of r.crit){if(!n.has(t))throw new R(`Extension Header Parameter "${t}" is not recognized`);if(void 0===i[t])throw new e(`Extension Header Parameter "${t}" is missing`);if(n.get(t)&&void 0===r[t])throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}return new Set(r.crit)}const Be=(e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some((e=>"string"!=typeof e))))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};async function Pe(e,t,a){if(!ce(e))throw new O("Flattened JWE must be an object");if(void 0===e.protected&&void 0===e.header&&void 0===e.unprotected)throw new O("JOSE Header missing");if(void 0!==e.iv&&"string"!=typeof e.iv)throw new O("JWE Initialization Vector incorrect type");if("string"!=typeof e.ciphertext)throw new O("JWE Ciphertext missing or incorrect type");if(void 0!==e.tag&&"string"!=typeof e.tag)throw new O("JWE Authentication Tag incorrect type");if(void 0!==e.protected&&"string"!=typeof e.protected)throw new O("JWE Protected Header incorrect type");if(void 0!==e.encrypted_key&&"string"!=typeof e.encrypted_key)throw new O("JWE Encrypted Key incorrect type");if(void 0!==e.aad&&"string"!=typeof e.aad)throw new O("JWE AAD incorrect type");if(void 0!==e.header&&!ce(e.header))throw new O("JWE Shared Unprotected Header incorrect type");if(void 0!==e.unprotected&&!ce(e.unprotected))throw new O("JWE Per-Recipient Unprotected Header incorrect type");let r;if(e.protected)try{const t=_(e.protected);r=JSON.parse(H.decode(t))}catch{throw new O("JWE Protected Header is invalid")}if(!ne(r,e.header,e.unprotected))throw new O("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");const i={...r,...e.header,...e.unprotected};if(He(O,new Map,a?.crit,r,i),void 0!==i.zip)throw new R('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');const{alg:n,enc:c}=i;if("string"!=typeof n||!n)throw new O("missing JWE Algorithm (alg) in JWE Header");if("string"!=typeof c||!c)throw new O("missing JWE Encryption Algorithm (enc) in JWE Header");const o=a&&Be("keyManagementAlgorithms",a.keyManagementAlgorithms),s=a&&Be("contentEncryptionAlgorithms",a.contentEncryptionAlgorithms);if(o&&!o.has(n)||!o&&n.startsWith("PBES2"))throw new D('"alg" (Algorithm) Header Parameter value not allowed');if(s&&!s.has(c))throw new D('"enc" (Encryption Algorithm) Header Parameter value not allowed');let d;if(void 0!==e.encrypted_key)try{d=_(e.encrypted_key)}catch{throw new O("Failed to base64url decode the encrypted_key")}let y,p,l,u=!1;"function"==typeof t&&(t=await t(r,e),u=!0);try{y=await Ae(n,t,d,i,a)}catch(e){if(e instanceof TypeError||e instanceof O||e instanceof R)throw e;y=ve(c)}if(void 0!==e.iv)try{p=_(e.iv)}catch{throw new O("Failed to base64url decode the iv")}if(void 0!==e.tag)try{l=_(e.tag)}catch{throw new O("Failed to base64url decode the tag")}const w=A.encode(e.protected??"");let h,f;h=void 0!==e.aad?P(w,A.encode("."),A.encode(e.aad)):w;try{f=_(e.ciphertext)}catch{throw new O("Failed to base64url decode the ciphertext")}const g={plaintext:await ie(c,y,f,p,l,h)};if(void 0!==e.protected&&(g.protectedHeader=r),void 0!==e.aad)try{g.additionalAuthenticatedData=_(e.aad)}catch{throw new O("Failed to base64url decode the aad")}return void 0!==e.unprotected&&(g.sharedUnprotectedHeader=e.unprotected),void 0!==e.header&&(g.unprotectedHeader=e.header),u?{...g,key:t}:g}var ke=async e=>{if(e instanceof Uint8Array)return{kty:"oct",k:W(e)};if(!x(e))throw new TypeError(Q(e,...ae,"Uint8Array"));if(!e.extractable)throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");const{ext:t,key_ops:a,alg:r,use:i,...n}=await S.subtle.exportKey("jwk",e);return n};async function Ce(e){return ke(e)}async function Te(e,t,a,r,i={}){let n,c,o;switch(xe(e,a,"encrypt"),e){case"dir":o=a;break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!ue(a))throw new R("ECDH with the provided key is not allowed or not supported by your javascript runtime");const{apu:s,apv:d}=i;let{epk:y}=i;y||(y=(await async function(e){if(!x(e))throw new TypeError(Q(e,...ae));return S.subtle.generateKey(e.algorithm,!0,["deriveBits"])}(a)).privateKey);const{x:p,y:l,crv:u,kty:w}=await Ce(y),h=await le(a,y,"ECDH-ES"===e?t:e,"ECDH-ES"===e?be(t):parseInt(e.slice(-5,-2),10),s,d);if(c={epk:{x:p,crv:u,kty:w}},"EC"===w&&(c.epk.y=l),s&&(c.apu=W(s)),d&&(c.apv=W(d)),"ECDH-ES"===e){o=h;break}o=r||ve(t);const f=e.slice(-6);n=await ye(f,h,o);break}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":o=r||ve(t),n=await(async(e,t,a)=>{if(!x(t))throw new TypeError(Q(t,...ae));if(Y(t,e,"encrypt","wrapKey"),ge(e,t),t.usages.includes("encrypt"))return new Uint8Array(await S.subtle.encrypt(fe(e),t,a));if(t.usages.includes("wrapKey")){const r=await S.subtle.importKey("raw",a,...oe);return new Uint8Array(await S.subtle.wrapKey("raw",r,t,fe(e)))}throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation')})(e,a,o);break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{o=r||ve(t);const{p2c:s,p2s:d}=i;({encryptedKey:n,...c}=await(async(e,t,a,r=2048,i=I(new Uint8Array(16)))=>{const n=await we(i,e,r,t);return{encryptedKey:await ye(e.slice(-6),n,a),p2c:r,p2s:W(i)}})(e,a,o,s,d));break}case"A128KW":case"A192KW":case"A256KW":o=r||ve(t),n=await ye(e,a,o);break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{o=r||ve(t);const{iv:s}=i;({encryptedKey:n,...c}=await async function(e,t,a,r){const i=e.slice(0,7),n=await Ke(i,a,t,r,new Uint8Array(0));return{encryptedKey:n.ciphertext,iv:W(n.iv),tag:W(n.tag)}}(e,a,o,s));break}default:throw new R('Invalid or unsupported "alg" (JWE Algorithm) header value')}return{cek:o,encryptedKey:n,parameters:c}}const Ue=Symbol();class We{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("plaintext must be an instance of Uint8Array");this._plaintext=e}setKeyManagementParameters(e){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=e,this}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._sharedUnprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._sharedUnprotectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}setContentEncryptionKey(e){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=e,this}setInitializationVector(e){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=e,this}async encrypt(e,t){if(!this._protectedHeader&&!this._unprotectedHeader&&!this._sharedUnprotectedHeader)throw new O("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");if(!ne(this._protectedHeader,this._unprotectedHeader,this._sharedUnprotectedHeader))throw new O("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const a={...this._protectedHeader,...this._unprotectedHeader,...this._sharedUnprotectedHeader};if(He(O,new Map,t?.crit,this._protectedHeader,a),void 0!==a.zip)throw new R('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');const{alg:r,enc:i}=a;if("string"!=typeof r||!r)throw new O('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("string"!=typeof i||!i)throw new O('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');let n,c,o,s,d;if(this._cek&&("dir"===r||"ECDH-ES"===r))throw new TypeError(`setContentEncryptionKey cannot be called with JWE "alg" (Algorithm) Header ${r}`);{let a;({cek:c,encryptedKey:n,parameters:a}=await Te(r,i,e,this._cek,this._keyManagementParameters)),a&&(t&&Ue in t?this._unprotectedHeader?this._unprotectedHeader={...this._unprotectedHeader,...a}:this.setUnprotectedHeader(a):this._protectedHeader?this._protectedHeader={...this._protectedHeader,...a}:this.setProtectedHeader(a))}s=this._protectedHeader?A.encode(W(JSON.stringify(this._protectedHeader))):A.encode(""),this._aad?(d=W(this._aad),o=P(s,A.encode("."),A.encode(d))):o=s;const{ciphertext:y,tag:p,iv:l}=await Ke(i,this._plaintext,c,this._iv,o),u={ciphertext:W(y)};return l&&(u.iv=W(l)),p&&(u.tag=W(p)),n&&(u.encrypted_key=W(n)),d&&(u.aad=d),this._protectedHeader&&(u.protected=H.decode(s)),this._sharedUnprotectedHeader&&(u.unprotected=this._sharedUnprotectedHeader),this._unprotectedHeader&&(u.header=this._unprotectedHeader),u}}class _e{constructor(e,t,a){this.parent=e,this.key=t,this.options=a}setUnprotectedHeader(e){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=e,this}addRecipient(...e){return this.parent.addRecipient(...e)}encrypt(...e){return this.parent.encrypt(...e)}done(){return this.parent}}class Je{constructor(e){this._recipients=[],this._plaintext=e}addRecipient(e,t){const a=new _e(this,e,{crit:t?.crit});return this._recipients.push(a),a}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}async encrypt(){if(!this._recipients.length)throw new O("at least one recipient must be added");if(1===this._recipients.length){const[e]=this._recipients,t=await new We(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(e.unprotectedHeader).encrypt(e.key,{...e.options}),a={ciphertext:t.ciphertext,iv:t.iv,recipients:[{}],tag:t.tag};return t.aad&&(a.aad=t.aad),t.protected&&(a.protected=t.protected),t.unprotected&&(a.unprotected=t.unprotected),t.encrypted_key&&(a.recipients[0].encrypted_key=t.encrypted_key),t.header&&(a.recipients[0].header=t.header),a}let e;for(let t=0;t<this._recipients.length;t++){const a=this._recipients[t];if(!ne(this._protectedHeader,this._unprotectedHeader,a.unprotectedHeader))throw new O("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const r={...this._protectedHeader,...this._unprotectedHeader,...a.unprotectedHeader},{alg:i}=r;if("string"!=typeof i||!i)throw new O('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("dir"===i||"ECDH-ES"===i)throw new O('"dir" and "ECDH-ES" alg may only be used with a single recipient');if("string"!=typeof r.enc||!r.enc)throw new O('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');if(e){if(e!==r.enc)throw new O('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients')}else e=r.enc;if(He(O,new Map,a.options.crit,this._protectedHeader,r),void 0!==r.zip)throw new R('JWE "zip" (Compression Algorithm) Header Parameter is not supported.')}const t=ve(e),a={ciphertext:"",iv:"",recipients:[],tag:""};for(let r=0;r<this._recipients.length;r++){const i=this._recipients[r],n={};a.recipients.push(n);const c={...this._protectedHeader,...this._unprotectedHeader,...i.unprotectedHeader}.alg.startsWith("PBES2")?2048+r:void 0;if(0===r){const e=await new We(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(t).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(i.unprotectedHeader).setKeyManagementParameters({p2c:c}).encrypt(i.key,{...i.options,[Ue]:!0});a.ciphertext=e.ciphertext,a.iv=e.iv,a.tag=e.tag,e.aad&&(a.aad=e.aad),e.protected&&(a.protected=e.protected),e.unprotected&&(a.unprotected=e.unprotected),n.encrypted_key=e.encrypted_key,e.header&&(n.header=e.header);continue}const{encryptedKey:o,parameters:s}=await Te(i.unprotectedHeader?.alg||this._protectedHeader?.alg||this._unprotectedHeader?.alg,e,i.key,t,{p2c:c});n.encrypted_key=W(o),(i.unprotectedHeader||s)&&(n.header={...i.unprotectedHeader,...s})}return a}}function De(e,t){const a=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:a,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:a,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:a,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:a,name:"ECDSA",namedCurve:t.namedCurve};case"EdDSA":return{name:t.name};default:throw new R(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}function Re(e,t,a){if(x(t))return X(t,e,a),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(Q(t,...ae));return S.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[a])}throw new TypeError(Q(t,...ae,"Uint8Array"))}const je=async(e,t,a,r)=>{const i=await Re(e,t,"verify");ge(e,i);const n=De(e,i.algorithm);try{return await S.subtle.verify(n,i,a,r)}catch{return!1}};async function Oe(e,t,a){if(!ce(e))throw new M("Flattened JWS must be an object");if(void 0===e.protected&&void 0===e.header)throw new M('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==e.protected&&"string"!=typeof e.protected)throw new M("JWS Protected Header incorrect type");if(void 0===e.payload)throw new M("JWS Payload missing");if("string"!=typeof e.signature)throw new M("JWS Signature missing or incorrect type");if(void 0!==e.header&&!ce(e.header))throw new M("JWS Unprotected Header incorrect type");let r={};if(e.protected)try{const t=_(e.protected);r=JSON.parse(H.decode(t))}catch{throw new M("JWS Protected Header is invalid")}if(!ne(r,e.header))throw new M("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const i={...r,...e.header};let n=!0;if(He(M,new Map([["b64",!0]]),a?.crit,r,i).has("b64")&&(n=r.b64,"boolean"!=typeof n))throw new M('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:c}=i;if("string"!=typeof c||!c)throw new M('JWS "alg" (Algorithm) Header Parameter missing or invalid');const o=a&&Be("algorithms",a.algorithms);if(o&&!o.has(c))throw new D('"alg" (Algorithm) Header Parameter value not allowed');if(n){if("string"!=typeof e.payload)throw new M("JWS Payload must be a string")}else if("string"!=typeof e.payload&&!(e.payload instanceof Uint8Array))throw new M("JWS Payload must be a string or an Uint8Array instance");let s=!1;"function"==typeof t&&(t=await t(r,e),s=!0),xe(c,t,"verify");const d=P(A.encode(e.protected??""),A.encode("."),"string"==typeof e.payload?A.encode(e.payload):e.payload);let y;try{y=_(e.signature)}catch{throw new M("Failed to base64url decode the signature")}if(!await je(c,t,y,d))throw new $;let p;if(n)try{p=_(e.payload)}catch{throw new M("Failed to base64url decode the payload")}else p="string"==typeof e.payload?A.encode(e.payload):e.payload;const l={payload:p};return void 0!==e.protected&&(l.protectedHeader=r),void 0!==e.header&&(l.unprotectedHeader=e.header),s?{...l,key:t}:l}class Me{constructor(e){this._flattened=new We(e)}setContentEncryptionKey(e){return this._flattened.setContentEncryptionKey(e),this}setInitializationVector(e){return this._flattened.setInitializationVector(e),this}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}setKeyManagementParameters(e){return this._flattened.setKeyManagementParameters(e),this}async encrypt(e,t){const a=await this._flattened.encrypt(e,t);return[a.protected,a.encrypted_key,a.iv,a.ciphertext,a.tag].join(".")}}class $e{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=e}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}async sign(e,t){if(!this._protectedHeader&&!this._unprotectedHeader)throw new M("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!ne(this._protectedHeader,this._unprotectedHeader))throw new M("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const a={...this._protectedHeader,...this._unprotectedHeader};let r=!0;if(He(M,new Map([["b64",!0]]),t?.crit,this._protectedHeader,a).has("b64")&&(r=this._protectedHeader.b64,"boolean"!=typeof r))throw new M('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:i}=a;if("string"!=typeof i||!i)throw new M('JWS "alg" (Algorithm) Header Parameter missing or invalid');xe(i,e,"sign");let n,c=this._payload;r&&(c=A.encode(W(c))),n=this._protectedHeader?A.encode(W(JSON.stringify(this._protectedHeader))):A.encode("");const o=P(n,A.encode("."),c),s=await(async(e,t,a)=>{const r=await Re(e,t,"sign");ge(e,r);const i=await S.subtle.sign(De(e,r.algorithm),r,a);return new Uint8Array(i)})(i,e,o),d={signature:W(s),payload:""};return r&&(d.payload=H.decode(c)),this._unprotectedHeader&&(d.header=this._unprotectedHeader),this._protectedHeader&&(d.protected=H.decode(n)),d}}class Ie{constructor(e){this._flattened=new $e(e)}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}async sign(e,t){const a=await this._flattened.sign(e,t);if(void 0===a.payload)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${a.protected}.${a.payload}.${a.signature}`}}class Ge{constructor(e,t,a){this.parent=e,this.key=t,this.options=a}setProtectedHeader(e){if(this.protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this.protectedHeader=e,this}setUnprotectedHeader(e){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=e,this}addSignature(...e){return this.parent.addSignature(...e)}sign(...e){return this.parent.sign(...e)}done(){return this.parent}}class Le{constructor(e){this._signatures=[],this._payload=e}addSignature(e,t){const a=new Ge(this,e,t);return this._signatures.push(a),a}async sign(){if(!this._signatures.length)throw new M("at least one signature must be added");const e={signatures:[],payload:""};for(let t=0;t<this._signatures.length;t++){const a=this._signatures[t],r=new $e(this._payload);r.setProtectedHeader(a.protectedHeader),r.setUnprotectedHeader(a.unprotectedHeader);const{payload:i,...n}=await r.sign(a.key,a.options);if(0===t)e.payload=i;else if(e.payload!==i)throw new M("inconsistent use of JWS Unencoded Payload (RFC7797)");e.signatures.push(n)}return e}}const Ne=W,Fe=_;function ze(e){const t=e?.modulusLength??2048;if("number"!=typeof t||t<2048)throw new R("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");return t}async function qe(e,t){return async function(e,t){let a,r;switch(e){case"PS256":case"PS384":case"PS512":a={name:"RSA-PSS",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:ze(t)},r=["sign","verify"];break;case"RS256":case"RS384":case"RS512":a={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:ze(t)},r=["sign","verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":a={name:"RSA-OAEP",hash:`SHA-${parseInt(e.slice(-3),10)||1}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:ze(t)},r=["decrypt","unwrapKey","encrypt","wrapKey"];break;case"ES256":a={name:"ECDSA",namedCurve:"P-256"},r=["sign","verify"];break;case"ES384":a={name:"ECDSA",namedCurve:"P-384"},r=["sign","verify"];break;case"ES512":a={name:"ECDSA",namedCurve:"P-521"},r=["sign","verify"];break;case"EdDSA":{r=["sign","verify"];const e=t?.crv??"Ed25519";switch(e){case"Ed25519":case"Ed448":a={name:e};break;default:throw new R("Invalid or unsupported crv option provided")}break}case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{r=["deriveKey","deriveBits"];const e=t?.crv??"P-256";switch(e){case"P-256":case"P-384":case"P-521":a={name:"ECDH",namedCurve:e};break;case"X25519":case"X448":a={name:e};break;default:throw new R("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448")}break}default:throw new R('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return S.subtle.generateKey(a,t?.extractable??!1,r)}(e,t)}async function Ve(e,t){return async function(e,t){let a,r,i;switch(e){case"HS256":case"HS384":case"HS512":a=parseInt(e.slice(-3),10),r={name:"HMAC",hash:`SHA-${a}`,length:a},i=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return a=parseInt(e.slice(-3),10),I(new Uint8Array(a>>3));case"A128KW":case"A192KW":case"A256KW":a=parseInt(e.slice(1,4),10),r={name:"AES-KW",length:a},i=["wrapKey","unwrapKey"];break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":case"A128GCM":case"A192GCM":case"A256GCM":a=parseInt(e.slice(1,4),10),r={name:"AES-GCM",length:a},i=["encrypt","decrypt"];break;default:throw new R('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return S.subtle.generateKey(r,t?.extractable??!1,i)}(e,t)}const Xe="ECDSA",Ye="P-384",Ze="ES384",Qe="SHA-256",et="RSA-OAEP-256",tt="AES-GCM",at="A256GCM",rt="PBES2-HS512+A256KW",nt=!0;const ct={decodeProtectedHeader:function(e){let t;if("string"==typeof e){const a=e.split(".");3!==a.length&&5!==a.length||([t]=a)}else if("object"==typeof e&&e){if(!("protected"in e))throw new TypeError("Token does not contain a Protected Header");t=e.protected}try{if("string"!=typeof t||!t)throw new Error;const e=JSON.parse(H.decode(Fe(t)));if(!ce(e))throw new Error;return e}catch{throw new TypeError("Invalid Token or Protected Header formatting")}},isEmptyJWSPayload:e=>!e.split(".")[1],hashText(e){let t=(new TextEncoder).encode(e);return this.hashBuffer(t)},async hashBuffer(e){let t=await function(e,t){return crypto.subtle.digest(e,t)}(Qe,e);return new Uint8Array(t)},base64url:async e=>Ne(e),inputBuffer(e,t){if(ArrayBuffer.isView(e))return e;let a=t.cty||"";return a.includes("text")||"string"==typeof e?t.cty=a||"text/plain":(t.cty=a||"json",e=JSON.stringify(e)),(new TextEncoder).encode(e)},recoverDataFromContentType:(e,{cty:t=e?.protectedHeader?.cty}={})=>(e&&!Object.prototype.hasOwnProperty.call(e,"payload")&&(e.payload=e.plaintext),t&&e?.payload?(e.text=(new TextDecoder).decode(e.payload),t.includes("json")&&(e.json=JSON.parse(e.text)),e):e),generateSigningKey:()=>qe(Ze,{extractable:nt}),async sign(e,t,a={}){let r={alg:Ze,...a},i=this.inputBuffer(t,r);return new Ie(i).setProtectedHeader(r).sign(e)},async verify(e,t,a){let r=await async function(e,t,a){if(e instanceof Uint8Array&&(e=H.decode(e)),"string"!=typeof e)throw new M("Compact JWS must be a string or Uint8Array");const{0:r,1:i,2:n,length:c}=e.split(".");if(3!==c)throw new M("Invalid Compact JWS");const o=await Oe({payload:i,protected:r,signature:n},t,a),s={payload:o.payload,protectedHeader:o.protectedHeader};return"function"==typeof t?{...s,key:o.key}:s}(t,e).catch((()=>{}));return this.recoverDataFromContentType(r,a)},generateEncryptingKey:()=>qe(et,{extractable:nt,modulusLength:4096}),async encrypt(e,t,a={}){let r={alg:this.isSymmetric(e)?"dir":et,enc:at,...a},i=this.inputBuffer(t,r),n=this.keySecret(e);return new Me(i).setProtectedHeader(r).encrypt(n)},async decrypt(e,t,a={}){let r=this.keySecret(e),i=await async function(e,t,a){if(e instanceof Uint8Array&&(e=H.decode(e)),"string"!=typeof e)throw new O("Compact JWE must be a string or Uint8Array");const{0:r,1:i,2:n,3:c,4:o,length:s}=e.split(".");if(5!==s)throw new O("Invalid Compact JWE");const d=await Pe({ciphertext:c,iv:n||void 0,protected:r,tag:o||void 0,encrypted_key:i||void 0},t,a),y={plaintext:d.plaintext,protectedHeader:d.protectedHeader};return"function"==typeof t?{...y,key:d.key}:y}(t,r);return this.recoverDataFromContentType(i,a),i},async generateSecretKey(e){return{type:"secret",text:await this.hashText(e)}},generateSymmetricKey(e){return e?this.generateSecretKey(e):Ve(at,{extractable:nt})},isSymmetric:e=>"secret"===e.type,keySecret:e=>e.text?e.text:e,async exportRaw(e){let t=await function(e){return crypto.subtle.exportKey("raw",e)}(e);return this.base64url(new Uint8Array(t))},importRaw:async e=>function(e){const t={name:Xe,namedCurve:Ye};return crypto.subtle.importKey("raw",e,t,nt,["verify"])}(Fe(e)),async exportJWK(e){let t=await Ce(e),a=e.algorithm;if(a)a.name===Xe&&a.namedCurve===Ye?t.alg=Ze:"RSA-OAEP"===a.name&&a.hash.name===Qe?t.alg=et:a.name===tt&&256===a.length&&(t.alg=at);else switch(t.kty){case"EC":t.alg=Ze;break;case"RSA":t.alg=et;break;case"oct":t.alg=at}return t},async importJWK(e){e={ext:!0,...e};let t=await Se(e);return t instanceof Uint8Array&&(t=await function(e){const t={name:tt,length:256};return crypto.subtle.importKey("raw",e,t,!0,["encrypt","decrypt"])}(t)),t},async wrapKey(e,t,a={}){let r=await this.exportJWK(e);return this.encrypt(t,r,a)},async unwrapKey(e,t){let a=await this.decrypt(t,e);return this.importJWK(a.json)}};const ot={isMultiKey:e=>"multi"===(e.type||"multi"),keyTags:e=>Object.keys(e).filter((e=>"type"!==e)),async exportJWK(e){if(!this.isMultiKey(e))return super.exportJWK(e);let t=this.keyTags(e),a=await Promise.all(t.map((async t=>{let a=await this.exportJWK(e[t]);return a.kid=t,a})));return{keys:a}},async importJWK(e){if(!e.keys)return super.importJWK(e);let t={};return await Promise.all(e.keys.map((async e=>t[e.kid]=await this.importJWK(e)))),t},async encrypt(e,t,a={}){if(!this.isMultiKey(e))return super.encrypt(e,t,a);let r={enc:at,...a},i=this.inputBuffer(t,r),n=new Je(i).setProtectedHeader(r);for(let t of this.keyTags(e)){let a=e[t],r="string"==typeof a,i=r||this.isSymmetric(a),c=r?(new TextEncoder).encode(a):this.keySecret(a),o=r?rt:i?"A256GCMKW":et;n.addRecipient(c).setUnprotectedHeader({kid:t,alg:o})}return await n.encrypt()},async decrypt(e,t,a){if(!this.isMultiKey(e))return super.decrypt(e,t,a);let r=t,{recipients:i}=r,n=i.map((async({header:t})=>{let{kid:a}=t,i=e[a],n={};if(!i)return Promise.reject("missing");"string"==typeof i&&(i=(new TextEncoder).encode(i),n.keyManagementAlgorithms=[rt]);let c=await async function(e,t,a){if(!ce(e))throw new O("General JWE must be an object");if(!Array.isArray(e.recipients)||!e.recipients.every(ce))throw new O("JWE Recipients missing or incorrect type");if(!e.recipients.length)throw new O("JWE Recipients has no members");for(const r of e.recipients)try{return await Pe({aad:e.aad,ciphertext:e.ciphertext,encrypted_key:r.encrypted_key,header:r.header,iv:e.iv,protected:e.protected,tag:e.tag,unprotected:e.unprotected},t,a)}catch{}throw new j}(r,this.keySecret(i),n),o=c.unprotectedHeader.kid;return o!==a?function(e,t){let a=`Key ${e} does not match encoded ${t}.`;return Promise.reject(a)}(a,o):c}));return await Promise.any(n).then((e=>(this.recoverDataFromContentType(e,a),e)),(()=>{}))},async sign(e,t,a={}){if(!this.isMultiKey(e))return super.sign(e,t,a);let r=this.inputBuffer(t,a),i=new Le(r);for(let t of this.keyTags(e)){let r=e[t],n={kid:t,alg:Ze,...a};i.addSignature(r).setProtectedHeader(n)}return i.sign()},verifySubSignature(e,t,a,r){let i=t.protectedHeader??this.decodeProtectedHeader(t),n=t.unprotectedHeader,c=i?.kid||n?.kid,o={...e,signatures:[t]},s={protectedHeader:i,unprotectedHeader:n,kid:c},d=c?[c]:r,y=Promise.any(d.map((async e=>async function(e,t,a){if(!ce(e))throw new M("General JWS must be an object");if(!Array.isArray(e.signatures)||!e.signatures.every(ce))throw new M("JWS Signatures missing or incorrect type");for(const r of e.signatures)try{return await Oe({header:r.header,payload:e.payload,protected:r.protected,signature:r.signature},t,a)}catch{}throw new $}(o,a[e]).then((t=>({kid:e,...t}))))));return y.catch((()=>s))},async verify(e,t,a={}){if(!this.isMultiKey(e))return super.verify(e,t,a);if(!t.signatures)return;let r=t,i=this.keyTags(e),n=await Promise.all(r.signatures.map((t=>this.verifySubSignature(r,t,e,i))));if(!n.find((e=>e.payload)))return;let[c,...o]=n,s={protectedHeader:{},unprotectedHeader:{},signers:n},d=e=>{let t=c[e],a=s[e];for(let r in t){let i=t[r];o.some((t=>t[e][r]!==i))||(a[r]=i)}};return d("protectedHeader"),d("protectedHeader"),s.payload=n.find((e=>e.payload)).payload,this.recoverDataFromContentType(s,a)}};Object.setPrototypeOf(ot,ct);class st{constructor({collectionName:e="collection",dbName:t="asyncLocalStorage"}={}){this.collectionName=e,this.dbName=t,this.version=1}get db(){return this._db??=new Promise((e=>{const t=indexedDB.open(this.dbName,this.version);t.onupgradeneeded=e=>e.target.result.createObjectStore(this.collectionName),this.result(e,t)}))}transaction(e="read"){const t=this.collectionName;return this.db.then((a=>a.transaction(t,e).objectStore(t)))}result(e,t){t.onsuccess=t=>e(t.target.result||"")}retrieve(e){return new Promise((t=>{this.transaction("readonly").then((a=>this.result(t,a.get(e))))}))}store(e,t){return new Promise((a=>{this.transaction("readwrite").then((r=>this.result(a,r.put(t,e))))}))}remove(e){return new Promise((t=>{this.transaction("readwrite").then((a=>this.result(t,a.delete(e))))}))}}function dt(e,t,a=void 0){let r=e(t.slice(0,16)+"...");return Promise.reject(new Error(r,{cause:a}))}function yt(e){return dt((e=>`The tag ${e} is not available.`),e)}class pt{static keySets={};static cached(e){return pt.keySets[e]}static clear(e=null){if(!e)return pt.keySets={};delete pt.keySets[e]}constructor(e){this.tag=e,this.memberTags=[],pt.keySets[e]=this}static getUserDeviceSecret=c;static Storage=i;static async create(e){let{time:t,...a}=await this.createKeys(e),{tag:r}=a;return await this.persist(r,a,e,t),r}async destroy(e={}){let{tag:t,memberTags:a,signingKey:r}=this,i=await this.constructor.signForStorage({...e,message:"",tag:t,memberTags:a,signingKey:r,time:Date.now(),recovery:!0});await this.constructor.store("EncryptionKey",t,i),await this.constructor.store(this.constructor.collection,t,i),this.constructor.clear(t),e.recursiveMembers&&await Promise.allSettled(this.memberTags.map((async t=>{let a=await pt.ensure(t,{...e,recovery:!0});await a.destroy(e)})))}decrypt(e,t){let{tag:a,decryptingKey:r}=this,i=e.recipients?{[a]:r}:r;return ot.decrypt(i,e,t)}static async sign(e,{tags:t=[],team:a,member:r,subject:i="hash",time:n=a&&Date.now(),memberTags:c,signingKey:o,...s}){if(a&&!r){c||(c=(await pt.ensure(a)).memberTags),r=c.find((e=>this.cached(e)))||await this.ensure1(c).then((e=>e.tag))}a&&!t.includes(a)&&(t=[a,...t]),r&&!t.includes(r)&&(t=[...t,r]);let d=await this.produceKey(t,(async e=>{let t=o||(await pt.ensure(e,s)).signingKey;return o=null,t}),s),y=ot.inputBuffer(e,s);if("hash"===i){const e=await ot.hashBuffer(y);i=await ot.base64url(e)}else i||(i=void 0);return ot.sign(d,y,{iss:a,act:r,iat:n,sub:i,...s})}static async verify(e,t,a){let r=!e.signatures,i=await this.produceKey(t,(e=>pt.verifyingKey(e)),a,r),n=await ot.verify(i,e,a),c=void 0===a.member?n?.protectedHeader.act:a.member,o=a.notBefore;function s(e){if(a.hardError)return Promise.reject(new Error(e))}if(!n)return s("Incorrect signature.");if(c){if("team"===a.member&&(c=n.protecteHeader.act,!c))return s("No member identified in signature.");if(!t.includes(c)){let r=await pt.verifyingKey(c),i={[c]:r};if(!await ot.verify(i,e,a))return s("Incorrect member signature.");t.push(c),n.signers.find((e=>e.protectedHeader.kid===c)).payload=n.payload}}if(c||"team"===o){let e=n.protectedHeader.iss||n.protectedHeader.kid,t=await this.retrieve(ft.collection,e),a=t?.json;if(c&&!e)return s("No team or main tag identified in signature");if(c&&a&&!a.recipients.find((e=>e.header.kid===c)))return s("Signer is not a member.");"team"===o&&(o=t?.protectedHeader.iat||(await this.retrieve("EncryptionKey",e))?.protectedHeader.iat)}if(o){let{iat:e}=n.protectedHeader;if(e<o)return s("Signature predates required timestamp.")}return(n.signers?.filter((e=>e.payload)).length||1)!==t.length?s("Unverified signer"):n}static async produceKey(e,t,a,r=1===e.length){if(r){let r=e[0];return a.kid=r,t(r)}let i={},n=await Promise.all(e.map((e=>t(e))));return e.forEach(((e,t)=>i[e]=n[t])),i}static verifyingKey(e){return ot.importRaw(e).catch((()=>yt(e)))}static async encryptingKey(e){let t=await this.retrieve("EncryptionKey",e);return t?await ot.importJWK(t.json):yt(e)}static async createKeys(e){let{publicKey:t,privateKey:a}=await ot.generateSigningKey(),{publicKey:r,privateKey:i}=await ot.generateEncryptingKey(),n=await ot.exportRaw(t),c=await ot.exportJWK(r),o=Date.now(),s=await this.signForStorage({message:c,tag:n,signingKey:a,memberTags:e,time:o,recovery:!0});return await this.store("EncryptionKey",n,s),{signingKey:a,decryptingKey:i,tag:n,time:o}}static getWrapped(e){return this.retrieve(this.collection,e)}static async ensure(e,{device:t=!0,team:a=!0,recovery:r=!1}={}){let i=this.cached(e),n=t&&await wt.getWrapped(e);return n?i||=new wt(e):a&&(n=await ft.getWrapped(e))?i||=new ft(e):r&&(n=await ut.getWrapped(e))&&(i||=new ut(e)),i?.cached&&i.cached.protectedHeader.iat===n.protectedHeader.iat&&i.cached.text===n.text&&i.decryptingKey&&i.signingKey?i:n?(i.cached=n,i.unwrap(i.cached).then((e=>Object.assign(i,e)),(e=>(this.clear(i.tag),dt((e=>`You do not have access to the private key for ${e}.`),i.tag,e))))):(this.clear(e),yt(e))}static ensure1(e){return Promise.any(e.map((e=>pt.ensure(e)))).catch((async t=>{for(let t of e){let e=await pt.ensure(t,{device:!1,team:!1,recovery:!0}).catch((()=>null));if(e)return e}throw t}))}static async persist(e,t,a,r=Date.now(),i=a){let{signingKey:n}=t,c=await this.wrap(t,a),o=await this.signForStorage({message:c,tag:e,signingKey:n,memberTags:i,time:r,recovery:!0});await this.store(this.collection,e,o)}static async store(e,t,a){return e===wt.collection?ot.isEmptyJWSPayload(a)?ht.remove(t):ht.store(t,a):pt.Storage.store(e,t,a)}static async retrieve(e,t){let a=e===wt.collection?ht.retrieve(t):pt.Storage.retrieve(e,t),r=await a,i=r&&await pt.verifyingKey(t);if(r)return r.signatures&&(i={[t]:i}),await ot.verify(i,r)}}class lt extends pt{static signForStorage({message:e,tag:t,signingKey:a,time:r}){return this.sign(e,{tags:[t],signingKey:a,time:r})}static async wrappingKey(e,t){let a=await this.getSecret(e,t);return ot.generateSecretKey(a)}static async wrap(e,t=""){let{decryptingKey:a,signingKey:r,tag:i}=e,n={decryptingKey:a,signingKey:r},c=await this.wrappingKey(i,t);return ot.wrapKey(n,c,{prompt:t})}async unwrap(e){let t=e.json||e.text,a=ot.decodeProtectedHeader(t).prompt,r=await this.constructor.wrappingKey(this.tag,a),i=(await ot.decrypt(r,t)).json;return await ot.importJWK(i,{decryptingKey:"decrypt",signingKey:"sign"})}static async getSecret(e,t){return pt.getUserDeviceSecret(e,t)}}class ut extends lt{static collection="KeyRecovery"}class wt extends lt{static collection="Device"}const ht=new st({collectionName:wt.collection});class ft extends pt{static collection="Team";static signForStorage({message:e,tag:t,...a}){return this.sign(e,{team:t,...a})}static async wrap(e,t){let{decryptingKey:a,signingKey:r}=e,i={decryptingKey:a,signingKey:r},n={};return await Promise.all(t.map((e=>pt.encryptingKey(e).then((t=>n[e]=t))))),await ot.wrapKey(i,n)}async unwrap(e){let{recipients:t}=e.json,a=this.memberTags=t.map((e=>e.header.kid)),r=await this.constructor.ensure1(a),i=await r.decrypt(e.json);return await ot.importJWK(i.json)}async changeMembership({add:e=[],remove:t=[]}={}){let{memberTags:a}=this,r=a.concat(e).filter((e=>!t.includes(e)));await this.constructor.persist(this.tag,this,r,Date.now(),a),this.memberTags=r}}const gt={get KeySet(){return pt},set Storage(e){pt.Storage=e},get Storage(){return pt.Storage},set getUserDeviceSecret(e){pt.getUserDeviceSecret=e},get getUserDeviceSecret(){return pt.getUserDeviceSecret},ready:{name:"@ki1r0y/distributed-security",version:"1.0.7",origin:pt.Storage.origin},async encrypt(e,...t){let a={},r=this.canonicalizeParameters(t,a),i=await pt.produceKey(r,(e=>pt.encryptingKey(e)),a);return ot.encrypt(i,e,a)},async decrypt(e,...t){let a={},[r]=this.canonicalizeParameters(t,a,e),{recovery:i,...n}=a;return(await pt.ensure(r,{recovery:i})).decrypt(e,n)},async sign(e,...t){let a={},r=this.canonicalizeParameters(t,a);return pt.sign(e,{tags:r,...a})},async verify(e,...t){let a={},r=this.canonicalizeParameters(t,a,e);return pt.verify(e,r,a)},async create(...e){if(!e.length)return await wt.create();let t=e[0].prompt;return t?await ut.create(t):await ft.create(e)},changeMembership:async({tag:e,recovery:t=!1,...a})=>(await pt.ensure(e,{recovery:t,...a})).changeMembership(a),async destroy(e){"string"==typeof e&&(e={tag:e});let{tag:t,recovery:a=!0,...r}=e,i={recovery:a,...r};return(await pt.ensure(t,i)).destroy(i)},clear(e){pt.clear(e)},decodeProtectedHeader:ot.decodeProtectedHeader,canonicalizeParameters(e,t,a){if(e.length>1||void 0!==e[0]?.length)return e;let{tags:r=[],contentType:i,time:n,...c}=e[0]||{},{team:o}=c;if(!r.length)if(e.length&&e[0].length)r=e;else if(a)if(a.signatures)r=a.signatures.map((e=>this.decodeProtectedHeader(e).kid));else if(a.recipients)r=a.recipients.map((e=>e.header.kid));else{let e=this.decodeProtectedHeader(a).kid;e&&(r=[e])}return o&&!r.includes(o)&&(r=[o,...r]),i&&(t.cty=i),n&&(t.iat=n),Object.assign(t,c),r}};let mt="secret",bt=mt;async function vt(e){bt="other",await e(),bt=mt}function Et(e,t=""){return t+bt}"undefined"!=typeof window&&Object.assign(window,{Security:h,Krypto:ct,MultiKrypto:ot,Storage:e});const St="undefined"==typeof window?(await import("node:crypto")).default.subtle:window.crypto.subtle;async function xt(e){const t=(new TextEncoder).encode(e),a=await St.digest("SHA-256",t),r=new Uint8Array(a),i=Array.from(r,(e=>String.fromCodePoint(e))).join("");return btoa(i).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}describe("Distributed Security",(function(){let t=g(),a=h.Storage,r=h.getUserDeviceSecret;beforeAll((function(){e.Security=h,h.Storage=e,h.getUserDeviceSecret=Et,gt.Storage=e,gt.getUserDeviceSecret=Et})),afterAll((function(){h.Storage=a,h.getUserDeviceSecret=r})),describe("Krypto",(function(){E(ct)})),describe("MultiKrypto",(function(){!function(e){const t=2e4,a=g();describe("falls through to krypto with single keys",(function(){E(e,f)})),describe("multi-way keys",(function(){describe("multi-signature",(function(){let t,r;beforeAll((async function(){t=await e.generateSigningKey(),r=await e.generateSigningKey()})),it("is a multi-signature.",(async function(){let i={a:t.privateKey,b:r.privateKey},n={b:r.publicKey,a:t.publicKey},c=await e.sign(i,a),o=await e.verify(n,c);expect(o).toBeTruthy()})),it('can specify type:"multi" in the signing key for clarify.',(async function(){let i={a:t.privateKey,b:r.privateKey,type:"multi"},n={a:t.publicKey,b:r.publicKey},c=await e.sign(i,a),o=await e.verify(n,c);expect(o).toBeTruthy()})),it('can specify type:"multi" in the verifying key for clarify.',(async function(){let i={a:t.privateKey,b:r.privateKey},n={a:t.publicKey,b:r.publicKey,type:"multi"},c=await e.sign(i,a),o=await e.verify(n,c);expect(o).toBeTruthy()})),it("can specify iss, act, iat in the key, which will appear in the signature.",(async function(){let i=Date.now(),n={a:t.privateKey,b:r.privateKey},c={a:t.publicKey,b:r.publicKey},o=await e.sign(n,a,{iss:"a",act:"b",iat:i}),s=await e.verify(c,o);expect(s).toBeTruthy(),o.signatures.forEach((t=>{let a=e.decodeProtectedHeader(t);expect(a.iss).toBe("a"),expect(a.act).toBe("b"),expect(a.iat).toBe(i)}))})),it("can sign binary and it is recovery as binary from payload property of verfication.",(async function(){let a=new Uint8Array([1],[2],[3]),i=await e.sign({a:t.privateKey,b:r.privateKey},a),n=await e.verify({a:t.publicKey,b:r.publicKey},i);expect(n.payload).toEqual(a)})),it("can sign string type and it is recoverable as string from text property of verification.",(async function(){let a="a string",i=await e.sign({a:t.privateKey,b:r.privateKey},a),n=await e.verify({a:t.publicKey,b:r.publicKey},i);expect(n.text).toEqual(a),expect(n.payload).toEqual((new TextEncoder).encode(a))})),it("can sign a jsonable object and it is recovery as same from json property of result.",(async function(){let a={foo:"a string",bar:!1,baz:["a",2,null]},i=await e.sign({a:t.privateKey,b:r.privateKey},a),n=await e.verify({a:t.publicKey,b:r.publicKey},i);expect(n.json).toEqual(a),expect(n.payload).toEqual((new TextEncoder).encode(JSON.stringify(a)))})),it("can specify a specific cty that will pass through to verify.",(async function(){let a={foo:"a string",bar:!1,baz:["a",2,null]},i="application/foo+json",n=await e.sign({a:t.privateKey,b:r.privateKey},a,{cty:i}),c=await e.verify({a:t.publicKey,b:r.publicKey},n);expect(c.json).toEqual(a),expect(c.protectedHeader.cty).toBe(i),expect(c.payload).toEqual((new TextEncoder).encode(JSON.stringify(a)))})),it("fails verification if the signature is mislabeled.",(async function(){let i={a:r.privateKey,b:t.privateKey},n={a:t.publicKey,b:r.publicKey},c=await e.sign(i,a),o=await e.verify(n,c);expect(o).toBeUndefined()})),it("gives enough information that we can tell if a verifying sub key is missing.",(async function(){let i={a:t.privateKey,b:r.privateKey},n={b:r.publicKey},c=await e.sign(i,a),o=await e.verify(n,c);expect(o.payload).toBeTruthy(),expect(o.text).toBe(a),expect(o.signers[1].payload).toBeTruthy(),expect(o.signers[0].payload).toBeUndefined()})),it("gives enough information that we can tell if a signature sub key is missing.",(async function(){let i={a:t.privateKey},n={a:t.publicKey,b:r.publicKey},c=await e.sign(i,a),o=await e.verify(n,c);expect(o.payload).toBeTruthy(),expect(o.text).toBe(a),expect(o.signers.length).toBe(1),expect(o.signers[0].protectedHeader.kid).toBe("a"),expect(o.signers[0].payload).toBeTruthy()}))})),describe("multi-way encryption",(function(){let r,i,n,c,o,s,d="shh!";beforeAll((async function(){n=await e.generateSymmetricKey(),i=await e.generateEncryptingKey(),r=await e.encrypt({a:n,b:i.publicKey,c:d},a),c=r.recipients;let t=await e.generateEncryptingKey();o={a:i.publicKey,b:t.publicKey},s={a:i.privateKey,b:t.privateKey}}),t),it("works with symmetric members.",(async function(){let t=await e.decrypt({a:n},r);expect(t.text).toBe(a),expect(c[0].header.kid).toBe("a"),expect(c[0].header.alg).toBe("A256GCMKW")})),it("works with keypair members.",(async function(){let t=await e.decrypt({b:i.privateKey},r);expect(t.text).toBe(a),expect(c[1].header.kid).toBe("b"),expect(c[1].header.alg).toBe("RSA-OAEP-256")})),it("works with secret text members.",(async function(){let t=await e.decrypt({c:d},r);expect(t.text).toBe(a),expect(c[2].header.kid).toBe("c"),expect(c[2].header.alg).toBe("PBES2-HS512+A256KW")})),it("handles binary, and decrypts as same.",(async function(){let t=new Uint8Array([21,31]),a=await e.encrypt(o,t),r=await e.decrypt(s,a),i=e.decodeProtectedHeader(a);expect(i.cty).toBeUndefined(),v(r,t)})),it("handles text, and decrypts as same.",(async function(){let t=await e.encrypt(o,a),r=await e.decrypt(s,t),i=e.decodeProtectedHeader(t);expect(i.cty).toBe("text/plain"),expect(r.text).toBe(a)})),it("handles json, and decrypts as same.",(async function(){let t={foo:"bar"},a=await e.encrypt(o,t),r=e.decodeProtectedHeader(a),i=await e.decrypt(s,a);expect(r.cty).toBe("json"),expect(i.json).toEqual(t)})),it("Uses specified headers if supplied, including cty.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await e.encrypt(o,r,{cty:t,iat:a,foo:17}),n=await e.decrypt(s,i),c=e.decodeProtectedHeader(i);expect(c.cty).toBe(t),expect(c.iat).toBe(a),expect(c.foo).toBe(17),expect(n.text).toBe(r)})),it("produces undefined for wrong symmetric key.",(async function(){let t=await e.generateSymmetricKey(),a=await e.decrypt({a:t},r);expect(a).toBeUndefined()})),it("produces undefined for wrong keypair.",(async function(){let t=await e.generateEncryptingKey(),a=await e.decrypt({b:t.privateKey},r);expect(a).toBeUndefined()})),it("produces undefined for wrong secret text.",(async function(){let t=await e.decrypt({c:"shh! "},r);expect(t).toBeUndefined()})),it("produces undefined for mislabeled key.",(async function(){let t=await e.decrypt({a:d},r);expect(t).toBeUndefined()}))}))})),describe("export/wrap",(function(){let r,i;beforeAll((async function(){let t=await e.generateEncryptingKey(),a=await e.generateEncryptingKey(),n=await e.generateEncryptingKey();r={a:t.publicKey,b:a.publicKey},i={c:n.privateKey,b:a.privateKey}}),t),it("exports homogenous member.",(async function(){let t=await e.exportJWK(r),n=await e.importJWK(t),c=await e.encrypt(n,a),o=await e.decrypt(i,c);expect(t.keys[0].kid).toBe("a"),expect(t.keys[1].kid).toBe("b"),expect(o.text).toBe(a)})),it("export heterogenous members.",(async function(){let t=await e.generateEncryptingKey(),a=await e.generateSigningKey(),r=await e.exportJWK({myDecrypt:t.privateKey,mySign:a.privateKey}),i=await e.importJWK(r),n="a smaller message for asymmetric encryption",c=await e.encrypt(t.publicKey,n),o=await e.decrypt(i.myDecrypt,c),s=await e.sign(i.mySign,n);expect(r.keys[0].kid).toBe("myDecrypt"),expect(r.keys[1].kid).toBe("mySign"),expect(o.text).toBe(n),expect(await e.verify(a.publicKey,s)).toBeTruthy()}),1e4),it("can wrap/unwrap a simple key.",(async function(){let t=await e.generateSymmetricKey(),n=await e.wrapKey(t,r),c=await e.unwrapKey(n,i),o=await e.encrypt(c,a),s=await e.decrypt(t,o);expect(s.text).toBe(a)})),it("can be wrapped/unwrapped by a symmetric key with homogenous members.",(async function(){let t=await e.generateSymmetricKey(),n=await e.wrapKey(r,t),c=await e.unwrapKey(n,t),o=await e.encrypt(c,a),s=await e.decrypt(i,o);expect(s.text).toBe(a)})),it("can wrap/unwrap a symmetric multikey with homogenous members.",(async function(){let t={x:await e.generateSymmetricKey(),y:await e.generateSymmetricKey()},a=await e.wrapKey(t,r),n=await e.unwrapKey(a,i),c=g(),o=await e.encrypt(n,c),s=await e.decrypt(t,o);expect(s.text).toBe(c)})),it("can wrap/unwrap a heterogeneous multikey.",(async function(){let t=await e.generateEncryptingKey(),a=await e.generateSigningKey(),n=await e.wrapKey({myDecrypt:t.privateKey,mySign:a.privateKey},r),c=await e.unwrapKey(n,i),o="a shorter message",s=await e.encrypt(t.publicKey,o),d=await e.decrypt(c.myDecrypt,s),y=await e.sign(c.mySign,o);expect(d.text).toBe(o),expect(await e.verify(a.publicKey,y)).toBeTruthy()}),t)}))}(ot)})),describe("Security",(function(){const a=6e4;async function r(e){let t,a,r={},[i,n,c]=await Promise.all([e.create(),e.create({prompt:"what?"}),e.create({prompt:"nope!"})]);await vt((async function(){t=await e.create(),a=await e.create(t)}));let o=await e.create(i),[s,d]=await Promise.all([e.create(o,a),e.create(a,o)]);return r.device=i,r.otherDevice=t,r.recovery=n,r.otherRecovery=c,r.user=o,r.otherUser=a,r.team=s,r.otherTeam=d,r}async function i(e,t){await e.destroy(t.otherTeam),await e.destroy(t.team),await e.destroy(t.user),await e.destroy(t.device),await e.destroy(t.recovery),await e.destroy(t.otherRecovery),await vt((async function(){await e.destroy(t.otherUser),await e.destroy(t.otherDevice)}))}describe("internal machinery",(function(){let n;function c(a,r,i={}){describe(a,(function(){let a,c;beforeAll((async function(){c=n[r],a=await pt.ensure(c,{recovery:!0})})),it("tag is exported verify key, and sign() pairs with it.",(async function(){let e=await ot.importRaw(c),a=await ot.exportRaw(e);expect(typeof c).toBe("string"),expect(a).toBe(c);let r=await pt.ensure(c,{recovery:!0}),n=await pt.sign(t,{tags:[c],signingKey:r.signingKey,...i}),o=await ot.verify(e,n);b(n),expect(o).toBeTruthy()})),it("public encryption tag can be retrieved externally, and vault.decrypt() pairs with it.",(async function(){let r=a.tag,n=await e.retrieve("EncryptionKey",r),c=await h.verify(n,r),o=await ot.importJWK(c.json),s=await ot.encrypt(o,t),d=await a.decrypt(s,i);expect(d.text).toBe(t)}))}))}beforeAll((async function(){n=await r(gt)}),a),afterAll((async function(){await i(gt,n)}),a),c("DeviceKeySet","device"),c("RecoveryKeySet","recovery",{recovery:!0}),c("TeamKeySet","user"),describe("local store",(function(){var e;beforeAll((async function(){e=new st({dbName:"testStore",collectionName:"Foo"}),await new Promise((e=>setTimeout(e,2e3)))})),it("can remove without existing.",(async function(){expect(await e.remove("nonExistant")).toBe("")})),it("can retrieve without existing.",(async function(){expect(await e.retrieve("nonExistant")).toBe("")})),it("retrieves and can remove what is stored.",(async function(){let t="x",a="hello";expect(await e.store(t,a)).not.toBeUndefined(),expect(await e.retrieve(t)).toBe(a),expect(await e.remove(t)).toBe(""),expect(await e.retrieve(t)).toBe("")})),it("can write a lot without getting jumbled.",(async function(){let t,a,r,i=1e3,n=[];for(let e=0;e<i;e++)n.push("y"+e);t=Date.now();let c=await Promise.all(n.map(((t,a)=>e.store(t,a.toString()))));a=Date.now()-t,r=a/i,expect(r).toBeLessThan(60),c.forEach((e=>expect(e).not.toBeUndefined())),t=Date.now();let o=await Promise.all(n.map((t=>e.retrieve(t))));a=Date.now()-t,r=a/i,expect(r).toBeLessThan(3),o.forEach(((e,t)=>expect(e).toBe(t.toString()))),t=Date.now();let s=await Promise.all(n.map((t=>e.remove(t))));a=Date.now()-t,r=a/i,expect(r).toBeLessThan(8),s.forEach((e=>expect(e).toBe(""))),t=Date.now();let d=await Promise.all(n.map((t=>e.retrieve(t))));a=Date.now()-t,r=a/i,expect(r).toBeLessThan(.1),d.forEach((e=>expect(e).toBe("")))}),15e5)}))})),describe("API",(function(){let n;function c(e,a,r,i,c={}){describe(e,(function(){let e,o;beforeAll((function(){e=n[a],o=n[r]})),describe("signature",(function(){describe("of one tag",(function(){it("can sign and be verified.",(async function(){let a=await h.sign(t,{tags:[e],...c});b(a),expect(await h.verify(a,e)).toBeTruthy()})),it("can be verified with the tag included in the signature.",(async function(){let a=await h.sign(t,{tags:[e],...c});expect(await h.verify(a)).toBeTruthy()})),it("cannot sign for a different key.",(async function(){let a=await h.sign(t,{tags:[o],...c});expect(await h.verify(a,e)).toBeUndefined()})),it("cannot sign with an unowned key.",(async function(){expect(await h.sign("something",{tags:n[i],...c}).catch((()=>{}))).toBeUndefined()})),it("distinguishes between correctly signing false and key failure.",(async function(){let t=await h.sign(!1,{tags:[e],...c}),a=await h.verify(t,e);expect(a.json).toBe(!1)})),it("can sign text and produce verified result with text property.",(async function(){let a=await h.sign(t,{tags:[e],...c}),r=await h.verify(a,e);b(a),expect(r.text).toBe(t)})),it("can sign json and produce verified result with json property.",(async function(){let t={x:1,y:["abc",null,!1]},a=await h.sign(t,{tags:[e],...c}),r=await h.verify(a,e);b(a),expect(r.json).toEqual(t)})),it("can sign binary and produce verified result with payload property.",(async function(){let t=new Uint8Array([1,2,3]),a=await h.sign(t,{tags:[e],...c}),r=await h.verify(a,e);b(a),expect(r.payload).toEqual(t)})),it("uses contentType and time if supplied.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await h.sign(r,{tags:[e],contentType:t,time:a,...c}),n=await h.verify(i,e);b(i),expect(n.text).toEqual(r),expect(n.protectedHeader.cty).toBe(t),expect(n.protectedHeader.iat).toBe(a)})),describe('includes payload hash as "sub" header',(function(){it("by default.",(async function(){let t=await h.sign("foo",{tags:[e],...c}),a=await h.verify(t);expect(a.protectedHeader.sub).toBe(await xt("foo"))})),it("unless specified otherwise.",(async function(){let t=await h.sign("foo",{subject:"bar",tags:[e],...c}),a=await h.verify(t),r=await h.sign("foo",{subject:!1,tags:[e],...c}),i=await h.verify(r);expect(a.protectedHeader.sub).toBe("bar"),expect(i.protectedHeader.sub).toBeUndefined()}))}))})),describe("of multiple tags",(function(){it("can sign and be verified.",(async function(){let a=await h.sign(t,{tags:[e,o],...c}),r=await h.verify(a,o,e);expect(r).toBeTruthy(),expect(r.signers[0].payload).toBeTruthy(),expect(r.signers[1].payload).toBeTruthy()})),it("does not attempt to verify unenumerated tags if any are explicit",(async function(){let a=await h.sign(t,{tags:[e,o],...c}),r=await h.verify(a,o);expect(r).toBeTruthy(),expect(r.signers[0].payload).toBeFalsy(),expect(r.signers[1].payload).toBeTruthy()})),it("can be verified with the tag included in the signature.",(async function(){let a=await h.sign(t,{tags:[e,o],...c}),r=await h.verify(a);expect(r).toBeTruthy(),expect(r.signers[0].payload).toBeTruthy(),expect(r.signers[1].payload).toBeTruthy()})),describe("bad verification",(function(){let a;beforeAll((async function(){a=await h.create()})),afterAll((async function(){await h.destroy(a)})),describe("when mixing single and multi-tags",(function(){it("fails with extra signing tag.",(async function(){let a=await h.sign(t,{tags:[o],...c});expect(await h.verify(a,e)).toBeUndefined()})),it("fails with extra verifying.",(async function(){let a=await h.sign(t,{tags:[e],...c});expect(await h.verify(a,e,o)).toBeUndefined()}))})),describe("when mixing multi-tag lengths",(function(){it("fails with mismatched signing tag.",(async function(){let r=await h.sign(t,{tags:[o,a],...c}),i=await h.verify(r,e,a);expect(i).toBeUndefined()})),it("fails with extra verifying tag.",(async function(){let r=await h.sign(t,{tags:[e,a],...c});expect(await h.verify(r,e,o,a)).toBeUndefined()}))}))})),it("distinguishes between correctly signing false and key failure.",(async function(){let t=await h.sign(!1,{tags:[e,o],...c}),a=await h.verify(t,e,o);expect(a.json).toBe(!1)})),it("can sign text and produce verified result with text property.",(async function(){let a=await h.sign(t,{tags:[e,o],...c}),r=await h.verify(a,e,o);expect(r.text).toBe(t)})),it("can sign json and produce verified result with json property.",(async function(){let t={x:1,y:["abc",null,!1]},a=await h.sign(t,{tags:[e,o],...c}),r=await h.verify(a,e,o);expect(r.json).toEqual(t)})),it("can sign binary and produce verified result with payload property.",(async function(){let t=new Uint8Array([1,2,3]),a=await h.sign(t,{tags:[e,o],...c}),r=await h.verify(a,e,o);expect(r.payload).toEqual(t)})),it("uses contentType and time if supplied.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await h.sign(r,{tags:[e,o],contentType:t,time:a,...c}),n=await h.verify(i,e,o);expect(n.text).toEqual(r),expect(n.protectedHeader.cty).toBe(t),expect(n.protectedHeader.iat).toBe(a)})),describe('includes payload hash as "sub" header',(function(){it("by default.",(async function(){let t=await h.sign("foo",{tags:[e,o],...c}),a=await h.verify(t);expect(a.protectedHeader.sub).toBe(await xt("foo"))})),it("unless specified otherwise.",(async function(){let t=await h.sign("foo",{tags:[e,o],subject:"bar",...c}),a=await h.verify(t),r=await h.sign("foo",{tags:[e,o],subject:!1,...c}),i=await h.verify(r);expect(a.protectedHeader.sub).toBe("bar"),expect(i.protectedHeader.sub).toBeUndefined()}))}))}))})),describe("encryption",(function(){describe("with a single tag",(function(){it("can decrypt what is encrypted for it.",(async function(){let a=await h.encrypt(t,e),r=await h.decrypt(a,{tags:[e],...c});b(a),expect(r.text).toBe(t)})),it("can be decrypted using the tag included in the encryption.",(async function(){let a=await h.encrypt(t,e),r=await h.decrypt(a,c);expect(r.text).toBe(t)})),it("is url-safe base64.",(async function(){b(await h.encrypt(t,e))})),it("specifies kid.",(async function(){let a=ct.decodeProtectedHeader(await h.encrypt(t,e));expect(a.kid).toBe(e)})),it("cannot decrypt what is encrypted for a different key.",(async function(){let t=g(446),a=await h.encrypt(t,o),r=await h.decrypt(a,{tags:[e],...c}).catch((e=>e.message));expect(r.toLowerCase()).toContain("operation")})),it("handles binary, and decrypts as same.",(async function(){let t=new Uint8Array([21,31]),a=await h.encrypt(t,e),r=await h.decrypt(a,{tags:[e],...c}),i=ct.decodeProtectedHeader(a);expect(i.cty).toBeUndefined(),v(r,t)})),it("handles text, and decrypts as same.",(async function(){let a=await h.encrypt(t,e),r=await h.decrypt(a,{tags:[e],...c}),i=ct.decodeProtectedHeader(a);expect(i.cty).toBe("text/plain"),expect(r.text).toBe(t)})),it("handles json, and decrypts as same.",(async function(){let t={foo:"bar"},a=await h.encrypt(t,e),r=await h.decrypt(a,{tags:[e],...c}),i=ct.decodeProtectedHeader(a);expect(i.cty).toBe("json"),expect(r.json).toEqual(t)})),it("uses contentType and time if supplied.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await h.encrypt(r,{tags:[e],contentType:t,time:a}),n=await h.decrypt(i,{tags:[e],...c}),o=ct.decodeProtectedHeader(i);expect(o.cty).toBe(t),expect(o.iat).toBe(a),expect(n.text).toBe(r)}))})),describe("with multiple tags",(function(){it("can be decrypted by any one of them.",(async function(){let a=await h.encrypt(t,e,o),r=await h.decrypt(a,{tags:[e],...c}),i=await h.decrypt(a,{tags:[o],...c});expect(r.text).toBe(t),expect(i.text).toBe(t)})),it("can be decrypted using the tag included in the encryption.",(async function(){let a=await h.encrypt(t,e,o),r=await h.decrypt(a,c);expect(r.text).toBe(t)})),it("can be be made with tags you do not own.",(async function(){let a=await h.encrypt(t,e,n[i],o),r=await h.decrypt(a,{tags:[e],...c}),s=await h.decrypt(a,{tags:[o],...c});expect(r.text).toBe(t),expect(s.text).toBe(t)})),it("cannot be decrypted by a different tag.",(async function(){let a=await h.encrypt(t,e,n[i]),r=await h.decrypt(a,{tags:[o],...c});expect(r).toBeUndefined()})),it("specifies kid in each recipient.",(async function(){let a=(await h.encrypt(t,e,o)).recipients;expect(a.length).toBe(2),expect(a[0].header.kid).toBe(e),expect(a[1].header.kid).toBe(o)})),it("handles binary, and decrypts as same.",(async function(){let t=new Uint8Array([21,31]),a=await h.encrypt(t,e,o),r=await h.decrypt(a,{tags:[e],...c}),i=ct.decodeProtectedHeader(a);expect(i.cty).toBeUndefined(),v(r,t)})),it("handles text, and decrypts as same.",(async function(){let a=await h.encrypt(t,e,o),r=await h.decrypt(a,{tags:[e],...c}),i=ct.decodeProtectedHeader(a);expect(i.cty).toBe("text/plain"),expect(r.text).toBe(t)})),it("handles json, and decrypts as same.",(async function(){let t={foo:"bar"},a=await h.encrypt(t,e,o),r=await h.decrypt(a,{tags:[e],...c}),i=ct.decodeProtectedHeader(a);expect(i.cty).toBe("json"),expect(r.json).toEqual(t)})),it("uses contentType and time if supplied.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await h.encrypt(r,{tags:[e,o],contentType:t,time:a}),n=await h.decrypt(i,{tags:[e],...c}),s=ct.decodeProtectedHeader(i);expect(s.cty).toBe(t),expect(s.iat).toBe(a),expect(n.text).toBe(r)}))}))}))}))}beforeAll((async function(){console.log(await h.ready),n=await r(h)}),a),afterAll((async function(){await i(h,n)}),a),c("DeviceKeySet","device","user","otherDevice"),c("RecoveryKeySet","recovery","otherRecovery","otherDevice",{recovery:!0}),c("User TeamKeySet","user","device","otherUser"),c("Team TeamKeySet","team","otherTeam","otherUser"),describe("storage",(function(){it("will only let a current member write new keys.",(async function(){let t=await h.create(),a=n.team,r=await e.retrieve("Team",a),i=await h.verify(r),c=i?.json;if(!i)throw new Error(`Unable to verify '${r?.text}'`);function o(){return h.sign(c,{team:a,member:t,time:Date.now()})}await h.changeMembership({tag:a,add:[t]});let s=await o();expect(await e.store("Team",n.team,s)).toBeDefined(),await h.changeMembership({tag:a,remove:[t]});let d=await o();expect(await e.store("Team",a,d).catch((()=>"failed"))).toBe("failed"),expect(await e.store("Team",a,s).catch((()=>"failed"))).toBe("failed"),expect(await e.store("Team",a,r).catch((()=>"failed"))).toBe("failed"),await h.destroy(t)})),it("will only let a current member write new public encryption key.",(async function(){let t=await h.create(),a=n.team,r=await e.retrieve("EncryptionKey",a),i=(await h.verify(r)).json;function c(){return h.sign(i,{team:a,member:t,time:Date.now()})}await h.changeMembership({tag:a,add:[t]});let o=await c();expect(await e.store("EncryptionKey",n.team,o)).toBeDefined(),await h.changeMembership({tag:a,remove:[t]});let s=await c();expect(await e.store("EncryptionKey",a,s).catch((()=>"failed"))).toBe("failed"),expect(await e.store("EncryptionKey",a,o).catch((()=>"failed"))).toBe("failed"),expect(await e.store("EncryptionKey",a,r).catch((()=>"failed"))).toBe("failed"),await h.destroy(t)}),1e4),it("will only let owner of a device write new public device encryption key.",(async function(){let t=await h.create(),a=await h.create(),r=await e.retrieve("EncryptionKey",t),i=(await h.verify(r)).json;function n(e){return h.sign(i,{tags:[e],time:Date.now()})}let c=await n(t);expect(await e.store("EncryptionKey",t,c)).toBeDefined();let o=await n(a);expect(await e.store("EncryptionKey",t,o).catch((()=>"failed"))).toBe("failed"),expect(await e.store("EncryptionKey",t,c)).toBeDefined,expect(await e.store("EncryptionKey",t,r).catch((()=>"failed"))).toBe("failed"),await h.destroy(t),await h.destroy(a)}),1e4)})),describe("auditable signatures",(function(){describe("by an explicit member",(function(){let e,a;beforeAll((async function(){e=await h.sign(t,{team:n.team,member:n.user}),a=await h.verify(e,n.team,n.user)})),it("recognizes a team with a member.",(async function(){expect(a).toBeTruthy(),expect(a.text).toBe(t)})),it("defines iss.",(function(){expect(a.protectedHeader.iss).toBe(n.team)})),it("defines act.",(function(){expect(a.protectedHeader.act).toBe(n.user)}))})),describe("automatically supplies a valid member",(function(){it("if you have access",(async function(){let e=await h.sign(t,{team:n.team}),a=ct.decodeProtectedHeader(e.signatures[0]).act,r=await h.verify(e,n.team,a);expect(r).toBeTruthy(),expect(a).toBeTruthy(),expect(r.protectedHeader.act).toBe(a),expect(r.protectedHeader.iat).toBeTruthy()}))})),describe("with a valid user who is not a member",(function(){let e;beforeAll((async function(){e=await h.create(n.device)})),afterAll((async function(){await h.destroy(e)})),it("verifies as an ordinary dual signature.",(async function(){let a=await h.sign(t,n.team,e),r=await h.verify(a,n.team,e);expect(r.text).toBe(t),expect(r.protectedHeader.iss).toBeUndefined(),expect(r.protectedHeader.act).toBeUndefined()}),1e4),it("does not verify as a dual signature specifying team and member.",(async function(){let a=await h.sign(t,{team:n.team,member:e}),r=await h.verify(a,n.team,e);expect(r).toBeUndefined()}))}),1e4),describe("with a past member",(function(){let e,t,a;beforeAll((async function(){a=Date.now()-1,e=await h.create(),await h.changeMembership({tag:n.team,add:[e]}),t=await h.sign("message",{team:n.team,member:e,time:a}),await h.changeMembership({tag:n.team,remove:[e]})})),afterAll((async function(){await h.destroy(e)})),it("fails by default.",(async function(){let a=await h.verify(t,e);expect(a).toBeUndefined()})),it("contains act in signature but verifies if we tell it not to check membership.",(async function(){let a=await h.verify(t,{team:n.team,member:!1});expect(a).toBeTruthy(),expect(a.text).toBe("message"),expect(a.protectedHeader.act).toBe(e),expect(a.protectedHeader.iat).toBeTruthy()})),it('fails if we tell it to check notBefore:"team", even if we tell it not to check membership.',(async function(){let e=await h.verify(t,{team:n.team,member:!1,notBefore:"team"});expect(e).toBeUndefined()}))}))})),describe("miscellaneous",(function(){it("can safely be used when a device is removed, but not after being entirely destroyed.",(async function(){let[e,a]=await Promise.all([h.create(),h.create()]),r=await h.create(e,a),i=await h.create(r),n=await h.encrypt(t,i),c=await h.decrypt(n,i);expect(c.text).toBe(t),c=await h.decrypt(n,i),await h.changeMembership({tag:r,remove:[e]}),expect(c.text).toBe(t),await h.changeMembership({tag:r,add:[e]}),c=await h.decrypt(n,i),expect(c.text).toBe(t),await h.destroy(a),c=await h.decrypt(n,i),expect(c.text).toBe(t),await h.destroy({tag:i,recursiveMembers:!0});let o=await h.decrypt(n,i).then((()=>null),(e=>e.message));expect(o).toBeTruthy()}),a),it("device is useable as soon as it resolves.",(async function(){let e=await h.create();expect(await h.sign("anything",e)).toBeTruthy(),await h.destroy(e)}),1e4),it("team is useable as soon as it resolves.",(async function(){let e=await h.create(n.device);expect(await h.sign("anything",e)).toBeTruthy(),await h.destroy(e)})),it("allows recovery prompts that contain dot (and confirm that a team can have a single recovery tag as member).",(async function(){let e=await h.create({prompt:"foo.bar"}),t=await h.create(e),a="red.white",r=await h.encrypt(a,t),i=await h.decrypt(r,t),n=await h.sign(a,t),c=await h.verify(n,t);expect(i.text).toBe(a),expect(c).toBeTruthy(),await h.destroy({tag:t,recursiveMembers:!0})}),1e4),it("supports rotation.",(async function(){let e=await h.create(n.device),t=await h.create(e),a=await h.sign("some purchase order",{team:t,member:e}),r=await h.encrypt("the other set of books",t);expect(await h.verify(a)).toBeTruthy(),expect(await h.verify(a,{team:t,member:!1})).toBeTruthy(),expect(await h.decrypt(r)).toBeTruthy();let i=await h.create(n.device),c=await h.create(n.device);await h.changeMembership({tag:t,remove:[e],add:[i,c]}),await h.destroy(e),expect(await h.sign("bogus PO",{team:t,member:e}).catch((()=>{}))).toBeUndefined();let o=await h.sign("new PO",{team:t,member:i}),s=await h.sign("new PO",{team:t,member:c});expect(await h.verify(o)).toBeTruthy(),expect(await h.verify(s)).toBeTruthy(),expect(await h.verify(a).catch((()=>{}))).toBeUndefined(),expect(await h.verify(a,{team:t,member:!1})).toBeTruthy(),expect(await h.decrypt(r)).toBeTruthy();let d=await h.create(i);await h.destroy(t),expect(await h.sign("bogus PO",{team:t,member:i}).catch((()=>{}))).toBeUndefined(),expect(await h.sign("new new PO",{team:d,member:i})).toBeTruthy(),expect(await h.verify(a,{team:t,member:!1})).toBeTruthy(),expect(await h.verify(o)).toBeTruthy(),expect(await h.verify(s)).toBeTruthy(),expect(await h.decrypt(r).catch((()=>{}))).toBeUndefined()}),15e3)}))}))}))}));
