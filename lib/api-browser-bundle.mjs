var e=crypto;const t=e=>e instanceof CryptoKey,r=async(t,r)=>{const a=`SHA-${t.slice(-3)}`;return new Uint8Array(await e.subtle.digest(a,r))},a=new TextEncoder,n=new TextDecoder,i=2**32;function s(...e){const t=e.reduce(((e,{length:t})=>e+t),0),r=new Uint8Array(t);let a=0;for(const t of e)r.set(t,a),a+=t.length;return r}function o(e,t,r){if(t<0||t>=i)throw new RangeError(`value must be >= 0 and <= ${i-1}. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,255&t],r)}function c(e){const t=Math.floor(e/i),r=e%i,a=new Uint8Array(8);return o(a,t,0),o(a,r,4),a}function d(e){const t=new Uint8Array(4);return o(t,e),t}function p(e){return s(d(e.length),e)}const h=e=>(e=>{let t=e;"string"==typeof t&&(t=a.encode(t));const r=[];for(let e=0;e<t.length;e+=32768)r.push(String.fromCharCode.apply(null,t.subarray(e,e+32768)));return btoa(r.join(""))})(e).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),l=e=>{let t=e;t instanceof Uint8Array&&(t=n.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return(e=>{const t=atob(e),r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);return r})(t)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}};class y extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(e){super(e),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,Error.captureStackTrace?.(this,this.constructor)}}class u extends y{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class w extends y{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class g extends y{constructor(){super(...arguments),this.code="ERR_JWE_DECRYPTION_FAILED",this.message="decryption operation failed"}static get code(){return"ERR_JWE_DECRYPTION_FAILED"}}class f extends y{constructor(){super(...arguments),this.code="ERR_JWE_INVALID"}static get code(){return"ERR_JWE_INVALID"}}class m extends y{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class E extends y{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}var A=e.getRandomValues.bind(e);function S(e){switch(e){case"A128GCM":case"A128GCMKW":case"A192GCM":case"A192GCMKW":case"A256GCM":case"A256GCMKW":return 96;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return 128;default:throw new w(`Unsupported JWE Algorithm: ${e}`)}}const H=(e,t)=>{if(t.length<<3!==S(e))throw new f("Invalid Initialization Vector length")},b=(e,t)=>{const r=e.byteLength<<3;if(r!==t)throw new f(`Invalid Content Encryption Key length. Expected ${t} bits, got ${r} bits`)};function v(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function K(e,t){return e.name===t}function P(e){return parseInt(e.name.slice(4),10)}function C(e,t){if(t.length&&!t.some((t=>e.usages.includes(t)))){let e="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const r=t.pop();e+=`one of ${t.join(", ")}, or ${r}.`}else 2===t.length?e+=`one of ${t[0]} or ${t[1]}.`:e+=`${t[0]}.`;throw new TypeError(e)}}function _(e,t,...r){switch(t){case"HS256":case"HS384":case"HS512":{if(!K(e.algorithm,"HMAC"))throw v("HMAC");const r=parseInt(t.slice(2),10);if(P(e.algorithm.hash)!==r)throw v(`SHA-${r}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!K(e.algorithm,"RSASSA-PKCS1-v1_5"))throw v("RSASSA-PKCS1-v1_5");const r=parseInt(t.slice(2),10);if(P(e.algorithm.hash)!==r)throw v(`SHA-${r}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!K(e.algorithm,"RSA-PSS"))throw v("RSA-PSS");const r=parseInt(t.slice(2),10);if(P(e.algorithm.hash)!==r)throw v(`SHA-${r}`,"algorithm.hash");break}case"EdDSA":if("Ed25519"!==e.algorithm.name&&"Ed448"!==e.algorithm.name)throw v("Ed25519 or Ed448");break;case"ES256":case"ES384":case"ES512":{if(!K(e.algorithm,"ECDSA"))throw v("ECDSA");const r=function(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}(t);if(e.algorithm.namedCurve!==r)throw v(r,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}C(e,r)}function W(e,t,...r){switch(t){case"A128GCM":case"A192GCM":case"A256GCM":{if(!K(e.algorithm,"AES-GCM"))throw v("AES-GCM");const r=parseInt(t.slice(1,4),10);if(e.algorithm.length!==r)throw v(r,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!K(e.algorithm,"AES-KW"))throw v("AES-KW");const r=parseInt(t.slice(1,4),10);if(e.algorithm.length!==r)throw v(r,"algorithm.length");break}case"ECDH":switch(e.algorithm.name){case"ECDH":case"X25519":case"X448":break;default:throw v("ECDH, X25519, or X448")}break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!K(e.algorithm,"PBKDF2"))throw v("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!K(e.algorithm,"RSA-OAEP"))throw v("RSA-OAEP");const r=parseInt(t.slice(9),10)||1;if(P(e.algorithm.hash)!==r)throw v(`SHA-${r}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}C(e,r)}function k(e,t,...r){if(r.length>2){const t=r.pop();e+=`one of type ${r.join(", ")}, or ${t}.`}else 2===r.length?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;return null==t?e+=` Received ${t}`:"function"==typeof t&&t.name?e+=` Received function ${t.name}`:"object"==typeof t&&null!=t&&t.constructor?.name&&(e+=` Received an instance of ${t.constructor.name}`),e}var U=(e,...t)=>k("Key must be ",e,...t);function J(e,t,...r){return k(`Key for the ${e} algorithm must be `,t,...r)}var R=e=>t(e);const T=["CryptoKey"];async function D(t,r,a,n,i,o){if(!(r instanceof Uint8Array))throw new TypeError(U(r,"Uint8Array"));const d=parseInt(t.slice(1,4),10),p=await e.subtle.importKey("raw",r.subarray(d>>3),"AES-CBC",!1,["decrypt"]),h=await e.subtle.importKey("raw",r.subarray(0,d>>3),{hash:"SHA-"+(d<<1),name:"HMAC"},!1,["sign"]),l=s(o,n,a,c(o.length<<3)),y=new Uint8Array((await e.subtle.sign("HMAC",h,l)).slice(0,d>>3));let u,w;try{u=((e,t)=>{if(!(e instanceof Uint8Array))throw new TypeError("First argument must be a buffer");if(!(t instanceof Uint8Array))throw new TypeError("Second argument must be a buffer");if(e.length!==t.length)throw new TypeError("Input buffers must have the same length");const r=e.length;let a=0,n=-1;for(;++n<r;)a|=e[n]^t[n];return 0===a})(i,y)}catch{}if(!u)throw new g;try{w=new Uint8Array(await e.subtle.decrypt({iv:n,name:"AES-CBC"},p,a))}catch{}if(!w)throw new g;return w}const O=async(r,a,n,i,o,c)=>{if(!(t(a)||a instanceof Uint8Array))throw new TypeError(U(a,...T,"Uint8Array"));if(!i)throw new f("JWE Initialization Vector missing");if(!o)throw new f("JWE Authentication Tag missing");switch(H(r,i),r){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return a instanceof Uint8Array&&b(a,parseInt(r.slice(-3),10)),D(r,a,n,i,o,c);case"A128GCM":case"A192GCM":case"A256GCM":return a instanceof Uint8Array&&b(a,parseInt(r.slice(1,4),10)),async function(t,r,a,n,i,o){let c;r instanceof Uint8Array?c=await e.subtle.importKey("raw",r,"AES-GCM",!1,["decrypt"]):(W(r,t,"decrypt"),c=r);try{return new Uint8Array(await e.subtle.decrypt({additionalData:o,iv:n,name:"AES-GCM",tagLength:128},c,s(a,i)))}catch{throw new g}}(r,a,n,i,o,c);default:throw new w("Unsupported JWE Content Encryption Algorithm")}},x=(...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let r;for(const e of t){const t=Object.keys(e);if(r&&0!==r.size)for(const e of t){if(r.has(e))return!1;r.add(e)}else r=new Set(t)}return!0};function M(e){if("object"!=typeof(t=e)||null===t||"[object Object]"!==Object.prototype.toString.call(e))return!1;var t;if(null===Object.getPrototypeOf(e))return!0;let r=e;for(;null!==Object.getPrototypeOf(r);)r=Object.getPrototypeOf(r);return Object.getPrototypeOf(e)===r}const j=[{hash:"SHA-256",name:"HMAC"},!0,["sign"]];function I(e,t){if(e.algorithm.length!==parseInt(t.slice(1,4),10))throw new TypeError(`Invalid key size for alg: ${t}`)}function B(r,a,n){if(t(r))return W(r,a,n),r;if(r instanceof Uint8Array)return e.subtle.importKey("raw",r,"AES-KW",!0,[n]);throw new TypeError(U(r,...T,"Uint8Array"))}const $=async(t,r,a)=>{const n=await B(r,t,"wrapKey");I(n,t);const i=await e.subtle.importKey("raw",a,...j);return new Uint8Array(await e.subtle.wrapKey("raw",i,n,"AES-KW"))},G=async(t,r,a)=>{const n=await B(r,t,"unwrapKey");I(n,t);const i=await e.subtle.unwrapKey("raw",a,n,"AES-KW",...j);return new Uint8Array(await e.subtle.exportKey("raw",i))};async function F(n,i,o,c,h=new Uint8Array(0),l=new Uint8Array(0)){if(!t(n))throw new TypeError(U(n,...T));if(W(n,"ECDH"),!t(i))throw new TypeError(U(i,...T));W(i,"ECDH","deriveBits");const y=s(p(a.encode(o)),p(h),p(l),d(c));let u;u="X25519"===n.algorithm.name?256:"X448"===n.algorithm.name?448:Math.ceil(parseInt(n.algorithm.namedCurve.substr(-3),10)/8)<<3;return async function(e,t,a){const n=Math.ceil((t>>3)/32),i=new Uint8Array(32*n);for(let t=0;t<n;t++){const n=new Uint8Array(4+e.length+a.length);n.set(d(t+1)),n.set(e,4),n.set(a,4+e.length),i.set(await r("sha256",n),32*t)}return i.slice(0,t>>3)}(new Uint8Array(await e.subtle.deriveBits({name:n.algorithm.name,public:n},i,u)),c,y)}function N(e){if(!t(e))throw new TypeError(U(e,...T));return["P-256","P-384","P-521"].includes(e.algorithm.namedCurve)||"X25519"===e.algorithm.name||"X448"===e.algorithm.name}async function L(r,n,i,o){!function(e){if(!(e instanceof Uint8Array)||e.length<8)throw new f("PBES2 Salt Input must be 8 or more octets")}(r);const c=function(e,t){return s(a.encode(e),new Uint8Array([0]),t)}(n,r),d=parseInt(n.slice(13,16),10),p={hash:`SHA-${n.slice(8,11)}`,iterations:i,name:"PBKDF2",salt:c},h={length:d,name:"AES-KW"},l=await function(r,a){if(r instanceof Uint8Array)return e.subtle.importKey("raw",r,"PBKDF2",!1,["deriveBits"]);if(t(r))return W(r,a,"deriveBits","deriveKey"),r;throw new TypeError(U(r,...T,"Uint8Array"))}(o,n);if(l.usages.includes("deriveBits"))return new Uint8Array(await e.subtle.deriveBits(p,l,d));if(l.usages.includes("deriveKey"))return e.subtle.deriveKey(p,l,h,!1,["wrapKey","unwrapKey"]);throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"')}const z=async(e,t,r,a,n)=>{const i=await L(n,e,a,t);return G(e.slice(-6),i,r)};function V(e){switch(e){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return"RSA-OAEP";default:throw new w(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}var X=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if("number"!=typeof r||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};const Y=async(r,a,n)=>{if(!t(a))throw new TypeError(U(a,...T));if(W(a,r,"decrypt","unwrapKey"),X(r,a),a.usages.includes("decrypt"))return new Uint8Array(await e.subtle.decrypt(V(r),a,n));if(a.usages.includes("unwrapKey")){const t=await e.subtle.unwrapKey("raw",n,a,V(r),...j);return new Uint8Array(await e.subtle.exportKey("raw",t))}throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation')};function q(e){switch(e){case"A128GCM":return 128;case"A192GCM":return 192;case"A256GCM":case"A128CBC-HS256":return 256;case"A192CBC-HS384":return 384;case"A256CBC-HS512":return 512;default:throw new w(`Unsupported JWE Algorithm: ${e}`)}}var Q=e=>A(new Uint8Array(q(e)>>3));var Z=async t=>{if(!t.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:r,keyUsages:a}=function(e){let t,r;switch(e.kty){case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new w('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new w('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"OKP":switch(e.alg){case"EdDSA":t={name:e.crv},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new w('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;default:throw new w('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}(t),n=[r,t.ext??!1,t.key_ops??a],i={...t};return delete i.alg,delete i.use,e.subtle.importKey("jwk",i,...n)};async function ee(e,t){if(!M(e))throw new TypeError("JWK must be an object");switch(t||(t=e.alg),e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return l(e.k);case"RSA":if(void 0!==e.oth)throw new w('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return Z({...e,alg:t});default:throw new w('Unsupported "kty" (Key Type) Parameter value')}}const te=(e,t,r)=>{e.startsWith("HS")||"dir"===e||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e)?((e,t)=>{if(!(t instanceof Uint8Array)){if(!R(t))throw new TypeError(J(e,t,...T,"Uint8Array"));if("secret"!==t.type)throw new TypeError(`${T.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}})(e,t):((e,t,r)=>{if(!R(t))throw new TypeError(J(e,t,...T));if("secret"===t.type)throw new TypeError(`${T.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===r&&"public"===t.type)throw new TypeError(`${T.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===r&&"public"===t.type)throw new TypeError(`${T.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(t.algorithm&&"verify"===r&&"private"===t.type)throw new TypeError(`${T.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(t.algorithm&&"encrypt"===r&&"private"===t.type)throw new TypeError(`${T.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)})(e,t,r)};const re=async(r,a,n,i,o)=>{if(!(t(n)||n instanceof Uint8Array))throw new TypeError(U(n,...T,"Uint8Array"));switch(i?H(r,i):i=A(new Uint8Array(S(r)>>3)),r){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return n instanceof Uint8Array&&b(n,parseInt(r.slice(-3),10)),async function(t,r,a,n,i){if(!(a instanceof Uint8Array))throw new TypeError(U(a,"Uint8Array"));const o=parseInt(t.slice(1,4),10),d=await e.subtle.importKey("raw",a.subarray(o>>3),"AES-CBC",!1,["encrypt"]),p=await e.subtle.importKey("raw",a.subarray(0,o>>3),{hash:"SHA-"+(o<<1),name:"HMAC"},!1,["sign"]),h=new Uint8Array(await e.subtle.encrypt({iv:n,name:"AES-CBC"},d,r)),l=s(i,n,h,c(i.length<<3));return{ciphertext:h,tag:new Uint8Array((await e.subtle.sign("HMAC",p,l)).slice(0,o>>3)),iv:n}}(r,a,n,i,o);case"A128GCM":case"A192GCM":case"A256GCM":return n instanceof Uint8Array&&b(n,parseInt(r.slice(1,4),10)),async function(t,r,a,n,i){let s;a instanceof Uint8Array?s=await e.subtle.importKey("raw",a,"AES-GCM",!1,["encrypt"]):(W(a,t,"encrypt"),s=a);const o=new Uint8Array(await e.subtle.encrypt({additionalData:i,iv:n,name:"AES-GCM",tagLength:128},s,r)),c=o.slice(-16);return{ciphertext:o.slice(0,-16),tag:c,iv:n}}(r,a,n,i,o);default:throw new w("Unsupported JWE Content Encryption Algorithm")}};async function ae(e,t,r,a,n){switch(te(e,t,"decrypt"),e){case"dir":if(void 0!==r)throw new f("Encountered unexpected JWE Encrypted Key");return t;case"ECDH-ES":if(void 0!==r)throw new f("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!M(a.epk))throw new f('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(!N(t))throw new w("ECDH with the provided key is not allowed or not supported by your javascript runtime");const n=await ee(a.epk,e);let i,s;if(void 0!==a.apu){if("string"!=typeof a.apu)throw new f('JOSE Header "apu" (Agreement PartyUInfo) invalid');try{i=l(a.apu)}catch{throw new f("Failed to base64url decode the apu")}}if(void 0!==a.apv){if("string"!=typeof a.apv)throw new f('JOSE Header "apv" (Agreement PartyVInfo) invalid');try{s=l(a.apv)}catch{throw new f("Failed to base64url decode the apv")}}const o=await F(n,t,"ECDH-ES"===e?a.enc:e,"ECDH-ES"===e?q(a.enc):parseInt(e.slice(-5,-2),10),i,s);if("ECDH-ES"===e)return o;if(void 0===r)throw new f("JWE Encrypted Key missing");return G(e.slice(-6),o,r)}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":if(void 0===r)throw new f("JWE Encrypted Key missing");return Y(e,t,r);case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{if(void 0===r)throw new f("JWE Encrypted Key missing");if("number"!=typeof a.p2c)throw new f('JOSE Header "p2c" (PBES2 Count) missing or invalid');const i=n?.maxPBES2Count||1e4;if(a.p2c>i)throw new f('JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds');if("string"!=typeof a.p2s)throw new f('JOSE Header "p2s" (PBES2 Salt) missing or invalid');let s;try{s=l(a.p2s)}catch{throw new f("Failed to base64url decode the p2s")}return z(e,t,r,a.p2c,s)}case"A128KW":case"A192KW":case"A256KW":if(void 0===r)throw new f("JWE Encrypted Key missing");return G(e,t,r);case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{if(void 0===r)throw new f("JWE Encrypted Key missing");if("string"!=typeof a.iv)throw new f('JOSE Header "iv" (Initialization Vector) missing or invalid');if("string"!=typeof a.tag)throw new f('JOSE Header "tag" (Authentication Tag) missing or invalid');let n,i;try{n=l(a.iv)}catch{throw new f("Failed to base64url decode the iv")}try{i=l(a.tag)}catch{throw new f("Failed to base64url decode the tag")}return async function(e,t,r,a,n){const i=e.slice(0,7);return O(i,t,r,a,n,new Uint8Array(0))}(e,t,r,n,i)}default:throw new w('Invalid or unsupported "alg" (JWE Algorithm) header value')}}function ne(e,t,r,a,n){if(void 0!==n.crit&&void 0===a?.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!a||void 0===a.crit)return new Set;if(!Array.isArray(a.crit)||0===a.crit.length||a.crit.some((e=>"string"!=typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let i;i=void 0!==r?new Map([...Object.entries(r),...t.entries()]):t;for(const t of a.crit){if(!i.has(t))throw new w(`Extension Header Parameter "${t}" is not recognized`);if(void 0===n[t])throw new e(`Extension Header Parameter "${t}" is missing`);if(i.get(t)&&void 0===a[t])throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}return new Set(a.crit)}const ie=(e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some((e=>"string"!=typeof e))))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};async function se(e,t,r){if(!M(e))throw new f("Flattened JWE must be an object");if(void 0===e.protected&&void 0===e.header&&void 0===e.unprotected)throw new f("JOSE Header missing");if(void 0!==e.iv&&"string"!=typeof e.iv)throw new f("JWE Initialization Vector incorrect type");if("string"!=typeof e.ciphertext)throw new f("JWE Ciphertext missing or incorrect type");if(void 0!==e.tag&&"string"!=typeof e.tag)throw new f("JWE Authentication Tag incorrect type");if(void 0!==e.protected&&"string"!=typeof e.protected)throw new f("JWE Protected Header incorrect type");if(void 0!==e.encrypted_key&&"string"!=typeof e.encrypted_key)throw new f("JWE Encrypted Key incorrect type");if(void 0!==e.aad&&"string"!=typeof e.aad)throw new f("JWE AAD incorrect type");if(void 0!==e.header&&!M(e.header))throw new f("JWE Shared Unprotected Header incorrect type");if(void 0!==e.unprotected&&!M(e.unprotected))throw new f("JWE Per-Recipient Unprotected Header incorrect type");let i;if(e.protected)try{const t=l(e.protected);i=JSON.parse(n.decode(t))}catch{throw new f("JWE Protected Header is invalid")}if(!x(i,e.header,e.unprotected))throw new f("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");const o={...i,...e.header,...e.unprotected};if(ne(f,new Map,r?.crit,i,o),void 0!==o.zip)throw new w('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');const{alg:c,enc:d}=o;if("string"!=typeof c||!c)throw new f("missing JWE Algorithm (alg) in JWE Header");if("string"!=typeof d||!d)throw new f("missing JWE Encryption Algorithm (enc) in JWE Header");const p=r&&ie("keyManagementAlgorithms",r.keyManagementAlgorithms),h=r&&ie("contentEncryptionAlgorithms",r.contentEncryptionAlgorithms);if(p&&!p.has(c)||!p&&c.startsWith("PBES2"))throw new u('"alg" (Algorithm) Header Parameter value not allowed');if(h&&!h.has(d))throw new u('"enc" (Encryption Algorithm) Header Parameter value not allowed');let y;if(void 0!==e.encrypted_key)try{y=l(e.encrypted_key)}catch{throw new f("Failed to base64url decode the encrypted_key")}let g,m,E,A=!1;"function"==typeof t&&(t=await t(i,e),A=!0);try{g=await ae(c,t,y,o,r)}catch(e){if(e instanceof TypeError||e instanceof f||e instanceof w)throw e;g=Q(d)}if(void 0!==e.iv)try{m=l(e.iv)}catch{throw new f("Failed to base64url decode the iv")}if(void 0!==e.tag)try{E=l(e.tag)}catch{throw new f("Failed to base64url decode the tag")}const S=a.encode(e.protected??"");let H,b;H=void 0!==e.aad?s(S,a.encode("."),a.encode(e.aad)):S;try{b=l(e.ciphertext)}catch{throw new f("Failed to base64url decode the ciphertext")}const v={plaintext:await O(d,g,b,m,E,H)};if(void 0!==e.protected&&(v.protectedHeader=i),void 0!==e.aad)try{v.additionalAuthenticatedData=l(e.aad)}catch{throw new f("Failed to base64url decode the aad")}return void 0!==e.unprotected&&(v.sharedUnprotectedHeader=e.unprotected),void 0!==e.header&&(v.unprotectedHeader=e.header),A?{...v,key:t}:v}var oe=async r=>{if(r instanceof Uint8Array)return{kty:"oct",k:h(r)};if(!t(r))throw new TypeError(U(r,...T,"Uint8Array"));if(!r.extractable)throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");const{ext:a,key_ops:n,alg:i,use:s,...o}=await e.subtle.exportKey("jwk",r);return o};async function ce(e){return oe(e)}async function de(r,a,n,i,s={}){let o,c,d;switch(te(r,n,"encrypt"),r){case"dir":d=n;break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!N(n))throw new w("ECDH with the provided key is not allowed or not supported by your javascript runtime");const{apu:p,apv:l}=s;let{epk:y}=s;y||(y=(await async function(r){if(!t(r))throw new TypeError(U(r,...T));return e.subtle.generateKey(r.algorithm,!0,["deriveBits"])}(n)).privateKey);const{x:u,y:g,crv:f,kty:m}=await ce(y),E=await F(n,y,"ECDH-ES"===r?a:r,"ECDH-ES"===r?q(a):parseInt(r.slice(-5,-2),10),p,l);if(c={epk:{x:u,crv:f,kty:m}},"EC"===m&&(c.epk.y=g),p&&(c.apu=h(p)),l&&(c.apv=h(l)),"ECDH-ES"===r){d=E;break}d=i||Q(a);const A=r.slice(-6);o=await $(A,E,d);break}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":d=i||Q(a),o=await(async(r,a,n)=>{if(!t(a))throw new TypeError(U(a,...T));if(W(a,r,"encrypt","wrapKey"),X(r,a),a.usages.includes("encrypt"))return new Uint8Array(await e.subtle.encrypt(V(r),a,n));if(a.usages.includes("wrapKey")){const t=await e.subtle.importKey("raw",n,...j);return new Uint8Array(await e.subtle.wrapKey("raw",t,a,V(r)))}throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation')})(r,n,d);break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{d=i||Q(a);const{p2c:e,p2s:t}=s;({encryptedKey:o,...c}=await(async(e,t,r,a=2048,n=A(new Uint8Array(16)))=>{const i=await L(n,e,a,t);return{encryptedKey:await $(e.slice(-6),i,r),p2c:a,p2s:h(n)}})(r,n,d,e,t));break}case"A128KW":case"A192KW":case"A256KW":d=i||Q(a),o=await $(r,n,d);break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{d=i||Q(a);const{iv:e}=s;({encryptedKey:o,...c}=await async function(e,t,r,a){const n=e.slice(0,7),i=await re(n,r,t,a,new Uint8Array(0));return{encryptedKey:i.ciphertext,iv:h(i.iv),tag:h(i.tag)}}(r,n,d,e));break}default:throw new w('Invalid or unsupported "alg" (JWE Algorithm) header value')}return{cek:d,encryptedKey:o,parameters:c}}const pe=Symbol();class he{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("plaintext must be an instance of Uint8Array");this._plaintext=e}setKeyManagementParameters(e){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=e,this}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._sharedUnprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._sharedUnprotectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}setContentEncryptionKey(e){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=e,this}setInitializationVector(e){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=e,this}async encrypt(e,t){if(!this._protectedHeader&&!this._unprotectedHeader&&!this._sharedUnprotectedHeader)throw new f("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");if(!x(this._protectedHeader,this._unprotectedHeader,this._sharedUnprotectedHeader))throw new f("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const r={...this._protectedHeader,...this._unprotectedHeader,...this._sharedUnprotectedHeader};if(ne(f,new Map,t?.crit,this._protectedHeader,r),void 0!==r.zip)throw new w('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');const{alg:i,enc:o}=r;if("string"!=typeof i||!i)throw new f('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("string"!=typeof o||!o)throw new f('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');let c,d,p,l,y;if(this._cek&&("dir"===i||"ECDH-ES"===i))throw new TypeError(`setContentEncryptionKey cannot be called with JWE "alg" (Algorithm) Header ${i}`);{let r;({cek:d,encryptedKey:c,parameters:r}=await de(i,o,e,this._cek,this._keyManagementParameters)),r&&(t&&pe in t?this._unprotectedHeader?this._unprotectedHeader={...this._unprotectedHeader,...r}:this.setUnprotectedHeader(r):this._protectedHeader?this._protectedHeader={...this._protectedHeader,...r}:this.setProtectedHeader(r))}l=this._protectedHeader?a.encode(h(JSON.stringify(this._protectedHeader))):a.encode(""),this._aad?(y=h(this._aad),p=s(l,a.encode("."),a.encode(y))):p=l;const{ciphertext:u,tag:g,iv:m}=await re(o,this._plaintext,d,this._iv,p),E={ciphertext:h(u)};return m&&(E.iv=h(m)),g&&(E.tag=h(g)),c&&(E.encrypted_key=h(c)),y&&(E.aad=y),this._protectedHeader&&(E.protected=n.decode(l)),this._sharedUnprotectedHeader&&(E.unprotected=this._sharedUnprotectedHeader),this._unprotectedHeader&&(E.header=this._unprotectedHeader),E}}class le{constructor(e,t,r){this.parent=e,this.key=t,this.options=r}setUnprotectedHeader(e){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=e,this}addRecipient(...e){return this.parent.addRecipient(...e)}encrypt(...e){return this.parent.encrypt(...e)}done(){return this.parent}}class ye{constructor(e){this._recipients=[],this._plaintext=e}addRecipient(e,t){const r=new le(this,e,{crit:t?.crit});return this._recipients.push(r),r}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}async encrypt(){if(!this._recipients.length)throw new f("at least one recipient must be added");if(1===this._recipients.length){const[e]=this._recipients,t=await new he(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(e.unprotectedHeader).encrypt(e.key,{...e.options}),r={ciphertext:t.ciphertext,iv:t.iv,recipients:[{}],tag:t.tag};return t.aad&&(r.aad=t.aad),t.protected&&(r.protected=t.protected),t.unprotected&&(r.unprotected=t.unprotected),t.encrypted_key&&(r.recipients[0].encrypted_key=t.encrypted_key),t.header&&(r.recipients[0].header=t.header),r}let e;for(let t=0;t<this._recipients.length;t++){const r=this._recipients[t];if(!x(this._protectedHeader,this._unprotectedHeader,r.unprotectedHeader))throw new f("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const a={...this._protectedHeader,...this._unprotectedHeader,...r.unprotectedHeader},{alg:n}=a;if("string"!=typeof n||!n)throw new f('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("dir"===n||"ECDH-ES"===n)throw new f('"dir" and "ECDH-ES" alg may only be used with a single recipient');if("string"!=typeof a.enc||!a.enc)throw new f('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');if(e){if(e!==a.enc)throw new f('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients')}else e=a.enc;if(ne(f,new Map,r.options.crit,this._protectedHeader,a),void 0!==a.zip)throw new w('JWE "zip" (Compression Algorithm) Header Parameter is not supported.')}const t=Q(e),r={ciphertext:"",iv:"",recipients:[],tag:""};for(let a=0;a<this._recipients.length;a++){const n=this._recipients[a],i={};r.recipients.push(i);const s={...this._protectedHeader,...this._unprotectedHeader,...n.unprotectedHeader}.alg.startsWith("PBES2")?2048+a:void 0;if(0===a){const e=await new he(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(t).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(n.unprotectedHeader).setKeyManagementParameters({p2c:s}).encrypt(n.key,{...n.options,[pe]:!0});r.ciphertext=e.ciphertext,r.iv=e.iv,r.tag=e.tag,e.aad&&(r.aad=e.aad),e.protected&&(r.protected=e.protected),e.unprotected&&(r.unprotected=e.unprotected),i.encrypted_key=e.encrypted_key,e.header&&(i.header=e.header);continue}const{encryptedKey:o,parameters:c}=await de(n.unprotectedHeader?.alg||this._protectedHeader?.alg||this._unprotectedHeader?.alg,e,n.key,t,{p2c:s});i.encrypted_key=h(o),(n.unprotectedHeader||c)&&(i.header={...n.unprotectedHeader,...c})}return r}}function ue(e,t){const r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case"EdDSA":return{name:t.name};default:throw new w(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}function we(r,a,n){if(t(a))return _(a,r,n),a;if(a instanceof Uint8Array){if(!r.startsWith("HS"))throw new TypeError(U(a,...T));return e.subtle.importKey("raw",a,{hash:`SHA-${r.slice(-3)}`,name:"HMAC"},!1,[n])}throw new TypeError(U(a,...T,"Uint8Array"))}const ge=async(t,r,a,n)=>{const i=await we(t,r,"verify");X(t,i);const s=ue(t,i.algorithm);try{return await e.subtle.verify(s,i,a,n)}catch{return!1}};async function fe(e,t,r){if(!M(e))throw new m("Flattened JWS must be an object");if(void 0===e.protected&&void 0===e.header)throw new m('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==e.protected&&"string"!=typeof e.protected)throw new m("JWS Protected Header incorrect type");if(void 0===e.payload)throw new m("JWS Payload missing");if("string"!=typeof e.signature)throw new m("JWS Signature missing or incorrect type");if(void 0!==e.header&&!M(e.header))throw new m("JWS Unprotected Header incorrect type");let i={};if(e.protected)try{const t=l(e.protected);i=JSON.parse(n.decode(t))}catch{throw new m("JWS Protected Header is invalid")}if(!x(i,e.header))throw new m("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const o={...i,...e.header};let c=!0;if(ne(m,new Map([["b64",!0]]),r?.crit,i,o).has("b64")&&(c=i.b64,"boolean"!=typeof c))throw new m('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:d}=o;if("string"!=typeof d||!d)throw new m('JWS "alg" (Algorithm) Header Parameter missing or invalid');const p=r&&ie("algorithms",r.algorithms);if(p&&!p.has(d))throw new u('"alg" (Algorithm) Header Parameter value not allowed');if(c){if("string"!=typeof e.payload)throw new m("JWS Payload must be a string")}else if("string"!=typeof e.payload&&!(e.payload instanceof Uint8Array))throw new m("JWS Payload must be a string or an Uint8Array instance");let h=!1;"function"==typeof t&&(t=await t(i,e),h=!0),te(d,t,"verify");const y=s(a.encode(e.protected??""),a.encode("."),"string"==typeof e.payload?a.encode(e.payload):e.payload);let w;try{w=l(e.signature)}catch{throw new m("Failed to base64url decode the signature")}if(!await ge(d,t,w,y))throw new E;let g;if(c)try{g=l(e.payload)}catch{throw new m("Failed to base64url decode the payload")}else g="string"==typeof e.payload?a.encode(e.payload):e.payload;const f={payload:g};return void 0!==e.protected&&(f.protectedHeader=i),void 0!==e.header&&(f.unprotectedHeader=e.header),h?{...f,key:t}:f}class me{constructor(e){this._flattened=new he(e)}setContentEncryptionKey(e){return this._flattened.setContentEncryptionKey(e),this}setInitializationVector(e){return this._flattened.setInitializationVector(e),this}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}setKeyManagementParameters(e){return this._flattened.setKeyManagementParameters(e),this}async encrypt(e,t){const r=await this._flattened.encrypt(e,t);return[r.protected,r.encrypted_key,r.iv,r.ciphertext,r.tag].join(".")}}class Ee{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=e}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}async sign(t,r){if(!this._protectedHeader&&!this._unprotectedHeader)throw new m("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!x(this._protectedHeader,this._unprotectedHeader))throw new m("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const i={...this._protectedHeader,...this._unprotectedHeader};let o=!0;if(ne(m,new Map([["b64",!0]]),r?.crit,this._protectedHeader,i).has("b64")&&(o=this._protectedHeader.b64,"boolean"!=typeof o))throw new m('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:c}=i;if("string"!=typeof c||!c)throw new m('JWS "alg" (Algorithm) Header Parameter missing or invalid');te(c,t,"sign");let d,p=this._payload;o&&(p=a.encode(h(p))),d=this._protectedHeader?a.encode(h(JSON.stringify(this._protectedHeader))):a.encode("");const l=s(d,a.encode("."),p),y=await(async(t,r,a)=>{const n=await we(t,r,"sign");X(t,n);const i=await e.subtle.sign(ue(t,n.algorithm),n,a);return new Uint8Array(i)})(c,t,l),u={signature:h(y),payload:""};return o&&(u.payload=n.decode(p)),this._unprotectedHeader&&(u.header=this._unprotectedHeader),this._protectedHeader&&(u.protected=n.decode(d)),u}}class Ae{constructor(e){this._flattened=new Ee(e)}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}async sign(e,t){const r=await this._flattened.sign(e,t);if(void 0===r.payload)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${r.protected}.${r.payload}.${r.signature}`}}class Se{constructor(e,t,r){this.parent=e,this.key=t,this.options=r}setProtectedHeader(e){if(this.protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this.protectedHeader=e,this}setUnprotectedHeader(e){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=e,this}addSignature(...e){return this.parent.addSignature(...e)}sign(...e){return this.parent.sign(...e)}done(){return this.parent}}class He{constructor(e){this._signatures=[],this._payload=e}addSignature(e,t){const r=new Se(this,e,t);return this._signatures.push(r),r}async sign(){if(!this._signatures.length)throw new m("at least one signature must be added");const e={signatures:[],payload:""};for(let t=0;t<this._signatures.length;t++){const r=this._signatures[t],a=new Ee(this._payload);a.setProtectedHeader(r.protectedHeader),a.setUnprotectedHeader(r.unprotectedHeader);const{payload:n,...i}=await a.sign(r.key,r.options);if(0===t)e.payload=n;else if(e.payload!==n)throw new m("inconsistent use of JWS Unencoded Payload (RFC7797)");e.signatures.push(i)}return e}}const be=h,ve=l;function Ke(e){const t=e?.modulusLength??2048;if("number"!=typeof t||t<2048)throw new w("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");return t}async function Pe(t,r){return async function(t,r){let a,n;switch(t){case"PS256":case"PS384":case"PS512":a={name:"RSA-PSS",hash:`SHA-${t.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:Ke(r)},n=["sign","verify"];break;case"RS256":case"RS384":case"RS512":a={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${t.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:Ke(r)},n=["sign","verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":a={name:"RSA-OAEP",hash:`SHA-${parseInt(t.slice(-3),10)||1}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:Ke(r)},n=["decrypt","unwrapKey","encrypt","wrapKey"];break;case"ES256":a={name:"ECDSA",namedCurve:"P-256"},n=["sign","verify"];break;case"ES384":a={name:"ECDSA",namedCurve:"P-384"},n=["sign","verify"];break;case"ES512":a={name:"ECDSA",namedCurve:"P-521"},n=["sign","verify"];break;case"EdDSA":{n=["sign","verify"];const e=r?.crv??"Ed25519";switch(e){case"Ed25519":case"Ed448":a={name:e};break;default:throw new w("Invalid or unsupported crv option provided")}break}case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{n=["deriveKey","deriveBits"];const e=r?.crv??"P-256";switch(e){case"P-256":case"P-384":case"P-521":a={name:"ECDH",namedCurve:e};break;case"X25519":case"X448":a={name:e};break;default:throw new w("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448")}break}default:throw new w('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return e.subtle.generateKey(a,r?.extractable??!1,n)}(t,r)}async function Ce(t,r){return async function(t,r){let a,n,i;switch(t){case"HS256":case"HS384":case"HS512":a=parseInt(t.slice(-3),10),n={name:"HMAC",hash:`SHA-${a}`,length:a},i=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return a=parseInt(t.slice(-3),10),A(new Uint8Array(a>>3));case"A128KW":case"A192KW":case"A256KW":a=parseInt(t.slice(1,4),10),n={name:"AES-KW",length:a},i=["wrapKey","unwrapKey"];break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":case"A128GCM":case"A192GCM":case"A256GCM":a=parseInt(t.slice(1,4),10),n={name:"AES-GCM",length:a},i=["encrypt","decrypt"];break;default:throw new w('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return e.subtle.generateKey(n,r?.extractable??!1,i)}(t,r)}const _e="ECDSA",We="P-384",ke="ES384",Ue="SHA-256",Je="RSA-OAEP-256",Re="AES-GCM",Te="A256GCM",De="PBES2-HS512+A256KW",Oe=!0;const xe={decodeProtectedHeader:function(e){let t;if("string"==typeof e){const r=e.split(".");3!==r.length&&5!==r.length||([t]=r)}else if("object"==typeof e&&e){if(!("protected"in e))throw new TypeError("Token does not contain a Protected Header");t=e.protected}try{if("string"!=typeof t||!t)throw new Error;const e=JSON.parse(n.decode(ve(t)));if(!M(e))throw new Error;return e}catch{throw new TypeError("Invalid Token or Protected Header formatting")}},isEmptyJWSPayload:e=>!e.split(".")[1],inputBuffer(e,t){if(ArrayBuffer.isView(e)&&!t.cty)return e;let r=t.cty||"";return r.includes("text")||"string"==typeof e?t.cty=r||"text/plain":(t.cty=r||"json",e=JSON.stringify(e)),(new TextEncoder).encode(e)},recoverDataFromContentType:(e,{cty:t=e?.protectedHeader?.cty}={})=>(e&&!Object.prototype.hasOwnProperty.call(e,"payload")&&(e.payload=e.plaintext),t&&e?.payload?(e.text=(new TextDecoder).decode(e.payload),t.includes("json")&&(e.json=JSON.parse(e.text)),e):e),generateSigningKey:()=>Pe(ke,{extractable:Oe}),async sign(e,t,r={}){let a={alg:ke,...r},n=this.inputBuffer(t,a);return new Ae(n).setProtectedHeader(a).sign(e)},async verify(e,t,r){let a=await async function(e,t,r){if(e instanceof Uint8Array&&(e=n.decode(e)),"string"!=typeof e)throw new m("Compact JWS must be a string or Uint8Array");const{0:a,1:i,2:s,length:o}=e.split(".");if(3!==o)throw new m("Invalid Compact JWS");const c=await fe({payload:i,protected:a,signature:s},t,r),d={payload:c.payload,protectedHeader:c.protectedHeader};return"function"==typeof t?{...d,key:c.key}:d}(t,e).catch((()=>{}));return this.recoverDataFromContentType(a,r)},generateEncryptingKey:()=>Pe(Je,{extractable:Oe,modulusLength:4096}),async encrypt(e,t,r={}){let a={alg:this.isSymmetric(e)?"dir":Je,enc:Te,...r},n=this.inputBuffer(t,a),i=this.keySecret(e);return new me(n).setProtectedHeader(a).encrypt(i)},async decrypt(e,t,r){let a=this.keySecret(e),i=await async function(e,t,r){if(e instanceof Uint8Array&&(e=n.decode(e)),"string"!=typeof e)throw new f("Compact JWE must be a string or Uint8Array");const{0:a,1:i,2:s,3:o,4:c,length:d}=e.split(".");if(5!==d)throw new f("Invalid Compact JWE");const p=await se({ciphertext:o,iv:s||void 0,protected:a,tag:c||void 0,encrypted_key:i||void 0},t,r),h={plaintext:p.plaintext,protectedHeader:p.protectedHeader};return"function"==typeof t?{...h,key:p.key}:h}(t,a);return this.recoverDataFromContentType(i,r),i},async generateSecretKey(e){let t=(new TextEncoder).encode(e),r=await function(e,t){return crypto.subtle.digest(e,t)}(Ue,t);return{type:"secret",text:new Uint8Array(r)}},generateSymmetricKey(e){return e?this.generateSecretKey(e):Ce(Te,{extractable:Oe})},isSymmetric:e=>"secret"===e.type,keySecret:e=>e.text?e.text:e,async exportRaw(e){let t=await function(e){return crypto.subtle.exportKey("raw",e)}(e);return be(new Uint8Array(t))},importRaw:async e=>function(e){const t={name:_e,namedCurve:We};return crypto.subtle.importKey("raw",e,t,Oe,["verify"])}(ve(e)),async exportJWK(e){let t=await ce(e),r=e.algorithm;if(r)r.name===_e&&r.namedCurve===We?t.alg=ke:"RSA-OAEP"===r.name&&r.hash.name===Ue?t.alg=Je:r.name===Re&&256===r.length&&(t.alg=Te);else switch(t.kty){case"EC":t.alg=ke;break;case"RSA":t.alg=Je;break;case"oct":t.alg=Te}return t},async importJWK(e){e=Object.assign({ext:!0},e);let t=await ee(e);return t instanceof Uint8Array&&(t=await function(e){const t={name:Re,length:256};return crypto.subtle.importKey("raw",e,t,!0,["encrypt","decrypt"])}(t)),t},async wrapKey(e,t){let r=await this.exportJWK(e);return this.encrypt(t,r)},async unwrapKey(e,t){let r=await this.decrypt(t,e);return this.importJWK(r.json)}};const Me={isMultiKey:e=>"multi"===(e.type||"multi"),keyTags:e=>Object.keys(e).filter((e=>"type"!==e)),async exportJWK(e){if(!this.isMultiKey(e))return super.exportJWK(e);let t=this.keyTags(e),r=await Promise.all(t.map((async t=>{let r=await this.exportJWK(e[t]);return r.kid=t,r})));return{keys:r}},async importJWK(e){if(!e.keys)return super.importJWK(e);let t={};return await Promise.all(e.keys.map((async e=>t[e.kid]=await this.importJWK(e)))),t},async encrypt(e,t,r={}){if(!this.isMultiKey(e))return super.encrypt(e,t,r);let a=Object.assign({enc:Te},r),n=this.inputBuffer(t,a),i=new ye(n).setProtectedHeader(a);for(let t of this.keyTags(e)){let r=e[t],a="string"==typeof r,n=a||this.isSymmetric(r),s=a?(new TextEncoder).encode(r):this.keySecret(r),o=a?De:n?"A256GCMKW":Je;i.addRecipient(s).setUnprotectedHeader({kid:t,alg:o})}return await i.encrypt()},async decrypt(e,t,r){if(!this.isMultiKey(e))return super.decrypt(e,t,r);let a=t,{recipients:n}=a,i=n.map((async({header:t})=>{let{kid:r}=t,n=e[r],i={};if(!n)return Promise.reject("missing");"string"==typeof n&&(n=(new TextEncoder).encode(n),i.keyManagementAlgorithms=[De]);let s=await async function(e,t,r){if(!M(e))throw new f("General JWE must be an object");if(!Array.isArray(e.recipients)||!e.recipients.every(M))throw new f("JWE Recipients missing or incorrect type");if(!e.recipients.length)throw new f("JWE Recipients has no members");for(const a of e.recipients)try{return await se({aad:e.aad,ciphertext:e.ciphertext,encrypted_key:a.encrypted_key,header:a.header,iv:e.iv,protected:e.protected,tag:e.tag,unprotected:e.unprotected},t,r)}catch{}throw new g}(a,this.keySecret(n),i),o=s.unprotectedHeader.kid;return o!==r?function(e,t){let r=`Key ${e} does not match encoded ${t}.`;return Promise.reject(r)}(r,o):s}));return await Promise.any(i).then((e=>(this.recoverDataFromContentType(e,r),e)),(()=>{}))},async sign(e,t,r={}){if(!this.isMultiKey(e))return super.sign(e,t,r);let a=this.inputBuffer(t,r),n=new He(a);for(let t of this.keyTags(e)){let a=e[t],i=Object.assign({kid:t,alg:ke},r);n.addSignature(a).setProtectedHeader(i)}return n.sign()},verifySubSignature(e,t,r,a){let n=t.protectedHeader??this.decodeProtectedHeader(t),i=t.unprotectedHeader,s=n?.kid||i?.kid,o=Object.assign({},e,{signatures:[t]}),c={protectedHeader:n,unprotectedHeader:i,kid:s},d=s?[s]:a,p=Promise.any(d.map((async e=>async function(e,t,r){if(!M(e))throw new m("General JWS must be an object");if(!Array.isArray(e.signatures)||!e.signatures.every(M))throw new m("JWS Signatures missing or incorrect type");for(const a of e.signatures)try{return await fe({header:a.header,payload:e.payload,protected:a.protected,signature:a.signature},t,r)}catch{}throw new E}(o,r[e]).then((t=>Object.assign({kid:e},t))))));return p.catch((()=>c))},async verify(e,t,r={}){if(!this.isMultiKey(e))return super.verify(e,t,r);if(!t.signatures)return;let a=t,n=this.keyTags(e),i=await Promise.all(a.signatures.map((t=>this.verifySubSignature(a,t,e,n))));if(!i.find((e=>e.payload)))return;let[s,...o]=i,c={protectedHeader:{},unprotectedHeader:{},signers:i},d=e=>{let t=s[e],r=c[e];for(let a in t){let n=t[a];o.some((t=>t[e][a]!==n))||(r[a]=n)}};return d("protectedHeader"),d("protectedHeader"),c.payload=i.find((e=>e.payload)).payload,this.recoverDataFromContentType(c,r)}};Object.setPrototypeOf(Me,xe);function je(e,t,r=void 0){let a=e(t.slice(0,16)+"...");return Promise.reject(new Error(a,{cause:r}))}function Ie(e){return je((e=>`The tag ${e} is not available.`),e)}class Be{static keySets={};static cached(e){return this.keySets[e]}static clear(e=null){if(!e)return Be.keySets={};delete Be.keySets[e]}constructor(e){this.tag=e,this.memberTags=[],Be.keySets[e]=this}static async create(e){let{time:t,...r}=await this.createKeys(e),{tag:a}=r;return await this.persist(a,r,e,t),a}async destroy(e={}){let{tag:t,memberTags:r,signingKey:a}=this,n=await this.constructor.signForStorage({message:"",tag:t,memberTags:r,signingKey:a,time:Date.now()});await this.constructor.store("EncryptionKey",t,n),await this.constructor.store(this.constructor.collection,t,n),this.constructor.clear(t),e.recursiveMembers&&await Promise.allSettled(this.memberTags.map((async t=>{let r=await Be.ensure(t);await r.destroy(e)})))}decrypt(e,t){let{tag:r,decryptingKey:a}=this,n=e.recipients?{[r]:a}:a;return Me.decrypt(n,e,t)}static async sign(e,{tags:t=[],team:r,member:a,time:n=r&&Date.now(),memberTags:i,signingKey:s,...o}){if(r&&!a){i||(i=(await Be.ensure(r)).memberTags),a=i.find((e=>this.cached(e)))||await Promise.any(i.map((e=>Be.ensure(e)))).then((e=>e.tag))}r&&!t.includes(r)&&(t=[r,...t]),a&&!t.includes(a)&&(t=[...t,a]);let c=await this.produceKey(t,(async e=>{let t=s||(await Be.ensure(e)).signingKey;return s=null,t}),o);return Me.sign(c,e,{iss:r,act:a,iat:n,...o})}static async verify(e,t,r){r.team&&!t.includes(r.team)&&(t=[r.team,...t]);let a=!e.signatures,n=await this.produceKey(t,(e=>Be.verifyingKey(e)),r,a),i=await Me.verify(n,e,r),s=void 0===r.member?i?.protectedHeader.act:r.member,o=r.notBefore;if(i){if(s){if("team"===r.member&&(s=i.protecteHeader.act,!s))return;if(!t.includes(s)){let a=await Be.verifyingKey(s),n={[s]:a};if(!await Me.verify(n,e,r))return;t.push(s),i.signers.find((e=>e.protectedHeader.kid===s)).payload=i.payload}}if(s||"team"===o){let e=i.protectedHeader.iss||i.protectedHeader.kid,t=await this.retrieve(Le.collection,e),r=t?.json;if(s&&!e)return;if(s&&r&&!r.recipients.find((e=>e.header.kid===s)))return;"team"===o&&(o=t?.protectedHeader.iat)}if(o){let{iat:e}=i.protectedHeader;if(e<o)return}if((i.signers?.filter((e=>e.payload)).length||1)===t.length)return i}}static async produceKey(e,t,r,a=1===e.length){if(a){let a=e[0];return r.kid=a,t(a)}let n={},i=await Promise.all(e.map((e=>t(e))));return e.forEach(((e,t)=>n[e]=i[t])),n}static verifyingKey(e){return Me.importRaw(e).catch((()=>Ie(e)))}static async encryptingKey(e){let t=await this.retrieve("EncryptionKey",e);return t?await Me.importJWK(t.json):Ie(e)}static async createKeys(e){let{publicKey:t,privateKey:r}=await Me.generateSigningKey(),{publicKey:a,privateKey:n}=await Me.generateEncryptingKey(),i=await Me.exportRaw(t),s=await Me.exportJWK(a),o=Date.now(),c=await this.signForStorage({message:s,tag:i,signingKey:r,memberTags:e,time:o});return await this.store("EncryptionKey",i,c),{signingKey:r,decryptingKey:n,tag:i,time:o}}static getWrapped(e){return this.retrieve(this.collection,e)}static async ensure(e){let t=this.cached(e),r=await Fe.getWrapped(e);return r?t=new Fe(e):(r=await Le.getWrapped(e))?t=new Le(e):(r=await Ge.getWrapped(e))&&(t=new Ge(e)),t?.cached&&t.cached===r&&t.decryptingKey&&t.signingKey?t:r?(t.cached=r,t.unwrap(t.cached).then((e=>Object.assign(t,e)),(e=>(this.clear(t.tag),je((e=>`You do not have access to the private key for ${e}.`),t.tag,e))))):(this.clear(e),Ie(e))}static async persist(e,t,r,a=Date.now(),n=r){let{signingKey:i}=t,s=await this.wrap(t,r),o=await this.signForStorage({message:s,tag:e,signingKey:i,memberTags:n,time:a});await this.store(this.collection,e,o)}static async store(e,t,r){return e===Fe.collection?Me.isEmptyJWSPayload(r)?Ne.remove(t):Ne.store(t,r):Be.Storage.store(e,t,r)}static async retrieve(e,t){let r=e===Fe.collection?Ne.retrieve(t):Be.Storage.retrieve(e,t),a=await r,n=a&&await Be.verifyingKey(t);if(a)return a.signatures&&(n={[t]:n}),await Me.verify(n,a)}}class $e extends Be{static signForStorage({message:e,tag:t,signingKey:r,time:a}){return this.sign(e,{tags:[t],signingKey:r,time:a})}static async wrap(e,t=""){if(t.includes(Me.concatChar))return Promise.reject("Cannot create recovery tag with a prompt that contains '~'.");let{decryptingKey:r,signingKey:a,tag:n}=e,i={decryptingKey:r,signingKey:a},s={[t]:await this.getSecret(n,t)};return Me.wrapKey(i,s)}async unwrap(e){let t=e.json.recipients[0].header.kid,r={[t]:await this.constructor.getSecret(this.tag,t)},a=(await Me.decrypt(r,e.json)).json;return await Me.importJWK(a,{decryptingKey:"decrypt",signingKey:"sign"})}static async getSecret(e,t){return Be.getUserDeviceSecret(e,t)}}class Ge extends $e{static collection="KeyRecovery"}class Fe extends $e{static collection="Device"}const Ne=new class{constructor({collectionName:e="collection",dbName:t="asyncLocalStorage"}={}){this.collectionName=e,this.dbName=t,this.version=1}get db(){return this._db??=new Promise((e=>{const t=indexedDB.open(this.dbName,this.version);t.onupgradeneeded=e=>e.target.result.createObjectStore(this.collectionName),this.result(e,t)}))}transaction(e="read"){const t=this.collectionName;return this.db.then((r=>r.transaction(t,e).objectStore(t)))}result(e,t){t.onsuccess=t=>e(t.target.result||"")}retrieve(e){return new Promise((t=>{this.transaction("readonly").then((r=>this.result(t,r.get(e))))}))}store(e,t){return new Promise((r=>{this.transaction("readwrite").then((a=>this.result(r,a.put(t,e))))}))}remove(e){return new Promise((t=>{this.transaction("readwrite").then((r=>this.result(t,r.delete(e))))}))}}({collectionName:Fe.collection});class Le extends Be{static collection="Team";static signForStorage({message:e,tag:t,...r}){return this.sign(e,{team:t,...r})}static async wrap(e,t){let{decryptingKey:r,signingKey:a}=e,n={decryptingKey:r,signingKey:a},i={};return await Promise.all(t.map((e=>Be.encryptingKey(e).then((t=>i[e]=t))))),await Me.wrapKey(n,i)}async unwrap(e){let{recipients:t}=e.json,r=this.memberTags=t.map((e=>e.header.kid)),a=await Promise.all(r.map((e=>Ge.getWrapped(e).catch((()=>null))))),n=r.filter(((e,t)=>a[t])),i=r.filter((e=>!n.includes(e))),s=await Promise.any(i.map((e=>Be.ensure(e)))).catch((async e=>{for(let e of n){let t=await Be.ensure(e).catch((()=>null));if(t)return t}return e})),o=await s.decrypt(e.json);return await Me.importJWK(o.json)}async changeMembership({add:e=[],remove:t=[]}={}){let{memberTags:r}=this,a=r.concat(e).filter((e=>!t.includes(e)));await this.constructor.persist(this.tag,this,a,Date.now(),r),this.memberTags=a}}var ze={name:"@kilroy-code/distributed-security",version:"0.0.3",description:"Signed and encrypted document infrastructure based on public key encryption and self-organizing users.",type:"module",exports:{node:"./lib/api.mjs",default:"./index.mjs"},imports:{"#raw":{node:"./lib/raw-node.mjs",default:"./lib/raw-browser.mjs"},"#localStore":{node:"./lib/store-fs.mjs",default:"./lib/store-indexed.mjs"},"#internals":{node:"./spec/support/internals.mjs",default:"./spec/support/internal-browser-bundle.mjs"}},scripts:{build:"rollup -c",test:"jasmine"},repository:{type:"git",url:"git+https://github.com/kilroy-code/distributed-security.git"},keywords:["encryption","pki","dao"],author:{name:"Howard Stearns",email:"howard@ki1r0y.com"},license:"MIT",bugs:{url:"https://github.com/kilroy-code/distributed-security/issues"},homepage:"https://github.com/kilroy-code/distributed-security#readme",devDependencies:{"@rollup/plugin-commonjs":"^25.0.7","@rollup/plugin-eslint":"^9.0.5","@rollup/plugin-node-resolve":"^15.2.3","@rollup/plugin-terser":"^0.4.4",eslint:"^8.57.0",jasmine:"^4.5.0","jsonc-eslint-parser":"^2.4.0",rollup:"^4.13.0"},dependencies:{"@kilroy-code/jsonrpc":"^0.0.1","@rollup/plugin-json":"^6.1.0",jose:"^5.2.3"}};const{name:Ve,version:Xe}=ze,Ye={set Storage(e){Be.Storage=e},set getUserDeviceSecret(e){Be.getUserDeviceSecret=e},ready:{name:Ve,version:Xe},async encrypt(e,...t){let r={},a=this.canonicalizeParameters(t,r),n=await Be.produceKey(a,(e=>Be.encryptingKey(e)),r);return Me.encrypt(n,e,r)},async decrypt(e,...t){let r={},[a]=this.canonicalizeParameters(t,r,e);return(await Be.ensure(a)).decrypt(e,r)},async sign(e,...t){let r={},a=this.canonicalizeParameters(t,r);return Be.sign(e,{tags:a,...r})},async verify(e,...t){let r={},a=this.canonicalizeParameters(t,r,e);return Be.verify(e,a,r)},async create(...e){if(!e.length)return await Fe.create([]);let t=e[0].prompt;return t?await Ge.create(t):await Le.create(e)},changeMembership:async({tag:e,...t})=>(await Be.ensure(e)).changeMembership(t),async destroy(e){"string"==typeof e&&(e={tag:e});let{tag:t,...r}=e;return(await Be.ensure(t)).destroy(r)},clear(e){Be.clear(e)},decodeProtectedHeader:Me.decodeProtectedHeader,canonicalizeParameters(e,t,r){let a=e,n=e[0]||r&&(r.recipients?.[0].header||this.decodeProtectedHeader(r.signatures?.[0]||r)).kid;if(!n.tags&&!n.team||e[1])n&&!a.includes(n)&&a.push(n);else{let{tags:e=[],contentType:r,time:i,...s}=n;a=e,r&&(t.cty=r),i&&(t.iat=i),Object.assign(t,s)}return a}};export{Ye as default};
