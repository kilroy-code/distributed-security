var e=crypto,t=crypto;const r=e=>e instanceof CryptoKey,n=async(e,r)=>{const n=`SHA-${e.slice(-3)}`;return new Uint8Array(await t.subtle.digest(n,r))},a=new TextEncoder,i=new TextDecoder,s=2**32;function o(...e){const t=e.reduce(((e,{length:t})=>e+t),0),r=new Uint8Array(t);let n=0;for(const t of e)r.set(t,n),n+=t.length;return r}function c(e,t,r){if(t<0||t>=s)throw new RangeError(`value must be >= 0 and <= 4294967295. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,255&t],r)}function d(e){const t=Math.floor(e/s),r=e%s,n=new Uint8Array(8);return c(n,t,0),c(n,r,4),n}function p(e){const t=new Uint8Array(4);return c(t,e),t}function h(e){return o(p(e.length),e)}const l=e=>(e=>{let t=e;"string"==typeof t&&(t=a.encode(t));const r=[];for(let e=0;e<t.length;e+=32768)r.push(String.fromCharCode.apply(null,t.subarray(e,e+32768)));return btoa(r.join(""))})(e).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),u=e=>{let t=e;t instanceof Uint8Array&&(t=i.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return(e=>{const t=atob(e),r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);return r})(t)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}};class y extends Error{constructor(e,t){super(e,t),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,Error.captureStackTrace?.(this,this.constructor)}}y.code="ERR_JOSE_GENERIC";(class extends y{constructor(e,t,r="unspecified",n="unspecified"){super(e,{cause:{claim:r,reason:n,payload:t}}),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=r,this.reason=n,this.payload=t}}).code="ERR_JWT_CLAIM_VALIDATION_FAILED";(class extends y{constructor(e,t,r="unspecified",n="unspecified"){super(e,{cause:{claim:r,reason:n,payload:t}}),this.code="ERR_JWT_EXPIRED",this.claim=r,this.reason=n,this.payload=t}}).code="ERR_JWT_EXPIRED";class w extends y{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}}w.code="ERR_JOSE_ALG_NOT_ALLOWED";class g extends y{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}}g.code="ERR_JOSE_NOT_SUPPORTED";class f extends y{constructor(e="decryption operation failed",t){super(e,t),this.code="ERR_JWE_DECRYPTION_FAILED"}}f.code="ERR_JWE_DECRYPTION_FAILED";class m extends y{constructor(){super(...arguments),this.code="ERR_JWE_INVALID"}}m.code="ERR_JWE_INVALID";class E extends y{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}}E.code="ERR_JWS_INVALID";(class extends y{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}}).code="ERR_JWT_INVALID";(class extends y{constructor(){super(...arguments),this.code="ERR_JWK_INVALID"}}).code="ERR_JWK_INVALID";(class extends y{constructor(){super(...arguments),this.code="ERR_JWKS_INVALID"}}).code="ERR_JWKS_INVALID";(class extends y{constructor(e="no applicable key found in the JSON Web Key Set",t){super(e,t),this.code="ERR_JWKS_NO_MATCHING_KEY"}}).code="ERR_JWKS_NO_MATCHING_KEY";(class extends y{constructor(e="multiple matching keys found in the JSON Web Key Set",t){super(e,t),this.code="ERR_JWKS_MULTIPLE_MATCHING_KEYS"}}).code="ERR_JWKS_MULTIPLE_MATCHING_KEYS";(class extends y{constructor(e="request timed out",t){super(e,t),this.code="ERR_JWKS_TIMEOUT"}}).code="ERR_JWKS_TIMEOUT";class S extends y{constructor(e="signature verification failed",t){super(e,t),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}S.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED";var A=t.getRandomValues.bind(t);function v(e){switch(e){case"A128GCM":case"A128GCMKW":case"A192GCM":case"A192GCMKW":case"A256GCM":case"A256GCMKW":return 96;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return 128;default:throw new g(`Unsupported JWE Algorithm: ${e}`)}}const b=(e,t)=>{if(t.length<<3!==v(e))throw new m("Invalid Initialization Vector length")},H=(e,t)=>{const r=e.byteLength<<3;if(r!==t)throw new m(`Invalid Content Encryption Key length. Expected ${t} bits, got ${r} bits`)};function K(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function _(e,t){return e.name===t}function P(e){return parseInt(e.name.slice(4),10)}function W(e,t){if(t.length&&!t.some((t=>e.usages.includes(t)))){let e="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const r=t.pop();e+=`one of ${t.join(", ")}, or ${r}.`}else 2===t.length?e+=`one of ${t[0]} or ${t[1]}.`:e+=`${t[0]}.`;throw new TypeError(e)}}function C(e,t,...r){switch(t){case"HS256":case"HS384":case"HS512":{if(!_(e.algorithm,"HMAC"))throw K("HMAC");const r=parseInt(t.slice(2),10);if(P(e.algorithm.hash)!==r)throw K(`SHA-${r}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!_(e.algorithm,"RSASSA-PKCS1-v1_5"))throw K("RSASSA-PKCS1-v1_5");const r=parseInt(t.slice(2),10);if(P(e.algorithm.hash)!==r)throw K(`SHA-${r}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!_(e.algorithm,"RSA-PSS"))throw K("RSA-PSS");const r=parseInt(t.slice(2),10);if(P(e.algorithm.hash)!==r)throw K(`SHA-${r}`,"algorithm.hash");break}case"EdDSA":if("Ed25519"!==e.algorithm.name&&"Ed448"!==e.algorithm.name)throw K("Ed25519 or Ed448");break;case"ES256":case"ES384":case"ES512":{if(!_(e.algorithm,"ECDSA"))throw K("ECDSA");const r=function(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}(t);if(e.algorithm.namedCurve!==r)throw K(r,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}W(e,r)}function k(e,t,...r){switch(t){case"A128GCM":case"A192GCM":case"A256GCM":{if(!_(e.algorithm,"AES-GCM"))throw K("AES-GCM");const r=parseInt(t.slice(1,4),10);if(e.algorithm.length!==r)throw K(r,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!_(e.algorithm,"AES-KW"))throw K("AES-KW");const r=parseInt(t.slice(1,4),10);if(e.algorithm.length!==r)throw K(r,"algorithm.length");break}case"ECDH":switch(e.algorithm.name){case"ECDH":case"X25519":case"X448":break;default:throw K("ECDH, X25519, or X448")}break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!_(e.algorithm,"PBKDF2"))throw K("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!_(e.algorithm,"RSA-OAEP"))throw K("RSA-OAEP");const r=parseInt(t.slice(9),10)||1;if(P(e.algorithm.hash)!==r)throw K(`SHA-${r}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}W(e,r)}function T(e,t,...r){if((r=r.filter(Boolean)).length>2){const t=r.pop();e+=`one of type ${r.join(", ")}, or ${t}.`}else 2===r.length?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;return null==t?e+=` Received ${t}`:"function"==typeof t&&t.name?e+=` Received function ${t.name}`:"object"==typeof t&&null!=t&&t.constructor?.name&&(e+=` Received an instance of ${t.constructor.name}`),e}var J=(e,...t)=>T("Key must be ",e,...t);function R(e,t,...r){return T(`Key for the ${e} algorithm must be `,t,...r)}var U=e=>!!r(e)||"KeyObject"===e?.[Symbol.toStringTag];const x=["CryptoKey"];async function I(e,r,n,a,i,s){if(!(r instanceof Uint8Array))throw new TypeError(J(r,"Uint8Array"));const c=parseInt(e.slice(1,4),10),p=await t.subtle.importKey("raw",r.subarray(c>>3),"AES-CBC",!1,["decrypt"]),h=await t.subtle.importKey("raw",r.subarray(0,c>>3),{hash:"SHA-"+(c<<1),name:"HMAC"},!1,["sign"]),l=o(s,a,n,d(s.length<<3)),u=new Uint8Array((await t.subtle.sign("HMAC",h,l)).slice(0,c>>3));let y,w;try{y=((e,t)=>{if(!(e instanceof Uint8Array))throw new TypeError("First argument must be a buffer");if(!(t instanceof Uint8Array))throw new TypeError("Second argument must be a buffer");if(e.length!==t.length)throw new TypeError("Input buffers must have the same length");const r=e.length;let n=0,a=-1;for(;++a<r;)n|=e[a]^t[a];return 0===n})(i,u)}catch{}if(!y)throw new f;try{w=new Uint8Array(await t.subtle.decrypt({iv:a,name:"AES-CBC"},p,n))}catch{}if(!w)throw new f;return w}const D=async(e,n,a,i,s,c)=>{if(!(r(n)||n instanceof Uint8Array))throw new TypeError(J(n,...x,"Uint8Array"));if(!i)throw new m("JWE Initialization Vector missing");if(!s)throw new m("JWE Authentication Tag missing");switch(b(e,i),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return n instanceof Uint8Array&&H(n,parseInt(e.slice(-3),10)),I(e,n,a,i,s,c);case"A128GCM":case"A192GCM":case"A256GCM":return n instanceof Uint8Array&&H(n,parseInt(e.slice(1,4),10)),async function(e,r,n,a,i,s){let c;r instanceof Uint8Array?c=await t.subtle.importKey("raw",r,"AES-GCM",!1,["decrypt"]):(k(r,e,"decrypt"),c=r);try{return new Uint8Array(await t.subtle.decrypt({additionalData:s,iv:a,name:"AES-GCM",tagLength:128},c,o(n,i)))}catch{throw new f}}(e,n,a,i,s,c);default:throw new g("Unsupported JWE Content Encryption Algorithm")}},O=(...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let r;for(const e of t){const t=Object.keys(e);if(r&&0!==r.size)for(const e of t){if(r.has(e))return!1;r.add(e)}else r=new Set(t)}return!0};function M(e){if("object"!=typeof(t=e)||null===t||"[object Object]"!==Object.prototype.toString.call(e))return!1;var t;if(null===Object.getPrototypeOf(e))return!0;let r=e;for(;null!==Object.getPrototypeOf(r);)r=Object.getPrototypeOf(r);return Object.getPrototypeOf(e)===r}const j=[{hash:"SHA-256",name:"HMAC"},!0,["sign"]];function $(e,t){if(e.algorithm.length!==parseInt(t.slice(1,4),10))throw new TypeError(`Invalid key size for alg: ${t}`)}function B(e,n,a){if(r(e))return k(e,n,a),e;if(e instanceof Uint8Array)return t.subtle.importKey("raw",e,"AES-KW",!0,[a]);throw new TypeError(J(e,...x,"Uint8Array"))}const L=async(e,r,n)=>{const a=await B(r,e,"wrapKey");$(a,e);const i=await t.subtle.importKey("raw",n,...j);return new Uint8Array(await t.subtle.wrapKey("raw",i,a,"AES-KW"))},G=async(e,r,n)=>{const a=await B(r,e,"unwrapKey");$(a,e);const i=await t.subtle.unwrapKey("raw",n,a,"AES-KW",...j);return new Uint8Array(await t.subtle.exportKey("raw",i))};async function N(e,i,s,c,d=new Uint8Array(0),l=new Uint8Array(0)){if(!r(e))throw new TypeError(J(e,...x));if(k(e,"ECDH"),!r(i))throw new TypeError(J(i,...x));k(i,"ECDH","deriveBits");const u=o(h(a.encode(s)),h(d),h(l),p(c));let y;y="X25519"===e.algorithm.name?256:"X448"===e.algorithm.name?448:Math.ceil(parseInt(e.algorithm.namedCurve.substr(-3),10)/8)<<3;return async function(e,t,r){const a=Math.ceil((t>>3)/32),i=new Uint8Array(32*a);for(let t=0;t<a;t++){const a=new Uint8Array(4+e.length+r.length);a.set(p(t+1)),a.set(e,4),a.set(r,4+e.length),i.set(await n("sha256",a),32*t)}return i.slice(0,t>>3)}(new Uint8Array(await t.subtle.deriveBits({name:e.algorithm.name,public:e},i,y)),c,u)}function z(e){if(!r(e))throw new TypeError(J(e,...x));return["P-256","P-384","P-521"].includes(e.algorithm.namedCurve)||"X25519"===e.algorithm.name||"X448"===e.algorithm.name}async function F(e,n,i,s){!function(e){if(!(e instanceof Uint8Array)||e.length<8)throw new m("PBES2 Salt Input must be 8 or more octets")}(e);const c=function(e,t){return o(a.encode(e),new Uint8Array([0]),t)}(n,e),d=parseInt(n.slice(13,16),10),p={hash:`SHA-${n.slice(8,11)}`,iterations:i,name:"PBKDF2",salt:c},h={length:d,name:"AES-KW"},l=await function(e,n){if(e instanceof Uint8Array)return t.subtle.importKey("raw",e,"PBKDF2",!1,["deriveBits"]);if(r(e))return k(e,n,"deriveBits","deriveKey"),e;throw new TypeError(J(e,...x,"Uint8Array"))}(s,n);if(l.usages.includes("deriveBits"))return new Uint8Array(await t.subtle.deriveBits(p,l,d));if(l.usages.includes("deriveKey"))return t.subtle.deriveKey(p,l,h,!1,["wrapKey","unwrapKey"]);throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"')}function V(e){switch(e){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return"RSA-OAEP";default:throw new g(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}var X=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if("number"!=typeof r||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};function q(e){return M(e)&&"string"==typeof e.kty}const Y=async e=>{if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:r,keyUsages:n}=function(e){let t,r;switch(e.kty){case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new g('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new g('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"OKP":switch(e.alg){case"EdDSA":t={name:e.crv},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new g('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;default:throw new g('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}(e),a=[r,e.ext??!1,e.key_ops??n],i={...e};return delete i.alg,delete i.use,t.subtle.importKey("jwk",i,...a)},Q=e=>u(e);let Z,ee;const te=e=>"KeyObject"===e?.[Symbol.toStringTag],re=async(e,t,r,n,a=!1)=>{let i=e.get(t);if(i?.[n])return i[n];const s=await Y({...r,alg:n});return a&&Object.freeze(t),i?i[n]=s:e.set(t,{[n]:s}),s};var ne=(e,t)=>{if(te(e)){let r=e.export({format:"jwk"});return delete r.d,delete r.dp,delete r.dq,delete r.p,delete r.q,delete r.qi,r.k?Q(r.k):(ee||(ee=new WeakMap),re(ee,e,r,t))}if(q(e)){if(e.k)return u(e.k);ee||(ee=new WeakMap);return re(ee,e,e,t,!0)}return e},ae=(e,t)=>{if(te(e)){let r=e.export({format:"jwk"});return r.k?Q(r.k):(Z||(Z=new WeakMap),re(Z,e,r,t))}if(q(e)){if(e.k)return u(e.k);Z||(Z=new WeakMap);return re(Z,e,e,t,!0)}return e};function ie(e){switch(e){case"A128GCM":return 128;case"A192GCM":return 192;case"A256GCM":case"A128CBC-HS256":return 256;case"A192CBC-HS384":return 384;case"A256CBC-HS512":return 512;default:throw new g(`Unsupported JWE Algorithm: ${e}`)}}var se=e=>A(new Uint8Array(ie(e)>>3));async function oe(e,t){if(!M(e))throw new TypeError("JWK must be an object");switch(t||(t=e.alg),e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return u(e.k);case"RSA":if(void 0!==e.oth)throw new g('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return Y({...e,alg:t});default:throw new g('Unsupported "kty" (Key Type) Parameter value')}}const ce=e=>e?.[Symbol.toStringTag],de=(e,t,r)=>{if(void 0!==t.use&&"sig"!==t.use)throw new TypeError("Invalid key for this operation, when present its use must be sig");if(void 0!==t.key_ops&&!0!==t.key_ops.includes?.(r))throw new TypeError(`Invalid key for this operation, when present its key_ops must include ${r}`);if(void 0!==t.alg&&t.alg!==e)throw new TypeError(`Invalid key for this operation, when present its alg must be ${e}`);return!0},pe=(e,t,r,n)=>{if(!(t instanceof Uint8Array)){if(n&&q(t)){if(function(e){return q(e)&&"oct"===e.kty&&"string"==typeof e.k}(t)&&de(e,t,r))return;throw new TypeError('JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present')}if(!U(t))throw new TypeError(R(e,t,...x,"Uint8Array",n?"JSON Web Key":null));if("secret"!==t.type)throw new TypeError(`${ce(t)} instances for symmetric algorithms must be of type "secret"`)}};function he(e,t,r,n){t.startsWith("HS")||"dir"===t||t.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(t)?pe(t,r,n,e):((e,t,r,n)=>{if(n&&q(t))switch(r){case"sign":if(function(e){return"oct"!==e.kty&&"string"==typeof e.d}(t)&&de(e,t,r))return;throw new TypeError("JSON Web Key for this operation be a private JWK");case"verify":if(function(e){return"oct"!==e.kty&&void 0===e.d}(t)&&de(e,t,r))return;throw new TypeError("JSON Web Key for this operation be a public JWK")}if(!U(t))throw new TypeError(R(e,t,...x,n?"JSON Web Key":null));if("secret"===t.type)throw new TypeError(`${ce(t)} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===r&&"public"===t.type)throw new TypeError(`${ce(t)} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===r&&"public"===t.type)throw new TypeError(`${ce(t)} instances for asymmetric algorithm decryption must be of type "private"`);if(t.algorithm&&"verify"===r&&"private"===t.type)throw new TypeError(`${ce(t)} instances for asymmetric algorithm verifying must be of type "public"`);if(t.algorithm&&"encrypt"===r&&"private"===t.type)throw new TypeError(`${ce(t)} instances for asymmetric algorithm encryption must be of type "public"`)})(t,r,n,e)}var le=he.bind(void 0,!1);const ue=he.bind(void 0,!0);const ye=async(e,n,a,i,s)=>{if(!(r(a)||a instanceof Uint8Array))throw new TypeError(J(a,...x,"Uint8Array"));switch(i?b(e,i):i=A(new Uint8Array(v(e)>>3)),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return a instanceof Uint8Array&&H(a,parseInt(e.slice(-3),10)),async function(e,r,n,a,i){if(!(n instanceof Uint8Array))throw new TypeError(J(n,"Uint8Array"));const s=parseInt(e.slice(1,4),10),c=await t.subtle.importKey("raw",n.subarray(s>>3),"AES-CBC",!1,["encrypt"]),p=await t.subtle.importKey("raw",n.subarray(0,s>>3),{hash:"SHA-"+(s<<1),name:"HMAC"},!1,["sign"]),h=new Uint8Array(await t.subtle.encrypt({iv:a,name:"AES-CBC"},c,r)),l=o(i,a,h,d(i.length<<3));return{ciphertext:h,tag:new Uint8Array((await t.subtle.sign("HMAC",p,l)).slice(0,s>>3)),iv:a}}(e,n,a,i,s);case"A128GCM":case"A192GCM":case"A256GCM":return a instanceof Uint8Array&&H(a,parseInt(e.slice(1,4),10)),async function(e,r,n,a,i){let s;n instanceof Uint8Array?s=await t.subtle.importKey("raw",n,"AES-GCM",!1,["encrypt"]):(k(n,e,"encrypt"),s=n);const o=new Uint8Array(await t.subtle.encrypt({additionalData:i,iv:a,name:"AES-GCM",tagLength:128},s,r)),c=o.slice(-16);return{ciphertext:o.slice(0,-16),tag:c,iv:a}}(e,n,a,i,s);default:throw new g("Unsupported JWE Content Encryption Algorithm")}};async function we(e,n,a,i,s){switch(le(e,n,"decrypt"),n=await(ae?.(n,e))||n,e){case"dir":if(void 0!==a)throw new m("Encountered unexpected JWE Encrypted Key");return n;case"ECDH-ES":if(void 0!==a)throw new m("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!M(i.epk))throw new m('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(!z(n))throw new g("ECDH with the provided key is not allowed or not supported by your javascript runtime");const t=await oe(i.epk,e);let r,s;if(void 0!==i.apu){if("string"!=typeof i.apu)throw new m('JOSE Header "apu" (Agreement PartyUInfo) invalid');try{r=u(i.apu)}catch{throw new m("Failed to base64url decode the apu")}}if(void 0!==i.apv){if("string"!=typeof i.apv)throw new m('JOSE Header "apv" (Agreement PartyVInfo) invalid');try{s=u(i.apv)}catch{throw new m("Failed to base64url decode the apv")}}const o=await N(t,n,"ECDH-ES"===e?i.enc:e,"ECDH-ES"===e?ie(i.enc):parseInt(e.slice(-5,-2),10),r,s);if("ECDH-ES"===e)return o;if(void 0===a)throw new m("JWE Encrypted Key missing");return G(e.slice(-6),o,a)}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":if(void 0===a)throw new m("JWE Encrypted Key missing");return(async(e,n,a)=>{if(!r(n))throw new TypeError(J(n,...x));if(k(n,e,"decrypt","unwrapKey"),X(e,n),n.usages.includes("decrypt"))return new Uint8Array(await t.subtle.decrypt(V(e),n,a));if(n.usages.includes("unwrapKey")){const r=await t.subtle.unwrapKey("raw",a,n,V(e),...j);return new Uint8Array(await t.subtle.exportKey("raw",r))}throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation')})(e,n,a);case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{if(void 0===a)throw new m("JWE Encrypted Key missing");if("number"!=typeof i.p2c)throw new m('JOSE Header "p2c" (PBES2 Count) missing or invalid');const t=s?.maxPBES2Count||1e4;if(i.p2c>t)throw new m('JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds');if("string"!=typeof i.p2s)throw new m('JOSE Header "p2s" (PBES2 Salt) missing or invalid');let r;try{r=u(i.p2s)}catch{throw new m("Failed to base64url decode the p2s")}return(async(e,t,r,n,a)=>{const i=await F(a,e,n,t);return G(e.slice(-6),i,r)})(e,n,a,i.p2c,r)}case"A128KW":case"A192KW":case"A256KW":if(void 0===a)throw new m("JWE Encrypted Key missing");return G(e,n,a);case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{if(void 0===a)throw new m("JWE Encrypted Key missing");if("string"!=typeof i.iv)throw new m('JOSE Header "iv" (Initialization Vector) missing or invalid');if("string"!=typeof i.tag)throw new m('JOSE Header "tag" (Authentication Tag) missing or invalid');let t,r;try{t=u(i.iv)}catch{throw new m("Failed to base64url decode the iv")}try{r=u(i.tag)}catch{throw new m("Failed to base64url decode the tag")}return async function(e,t,r,n,a){const i=e.slice(0,7);return D(i,t,r,n,a,new Uint8Array(0))}(e,n,a,t,r)}default:throw new g('Invalid or unsupported "alg" (JWE Algorithm) header value')}}function ge(e,t,r,n,a){if(void 0!==a.crit&&void 0===n?.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||void 0===n.crit)return new Set;if(!Array.isArray(n.crit)||0===n.crit.length||n.crit.some((e=>"string"!=typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let i;i=void 0!==r?new Map([...Object.entries(r),...t.entries()]):t;for(const t of n.crit){if(!i.has(t))throw new g(`Extension Header Parameter "${t}" is not recognized`);if(void 0===a[t])throw new e(`Extension Header Parameter "${t}" is missing`);if(i.get(t)&&void 0===n[t])throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}return new Set(n.crit)}const fe=(e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some((e=>"string"!=typeof e))))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};async function me(e,t,r){if(!M(e))throw new m("Flattened JWE must be an object");if(void 0===e.protected&&void 0===e.header&&void 0===e.unprotected)throw new m("JOSE Header missing");if(void 0!==e.iv&&"string"!=typeof e.iv)throw new m("JWE Initialization Vector incorrect type");if("string"!=typeof e.ciphertext)throw new m("JWE Ciphertext missing or incorrect type");if(void 0!==e.tag&&"string"!=typeof e.tag)throw new m("JWE Authentication Tag incorrect type");if(void 0!==e.protected&&"string"!=typeof e.protected)throw new m("JWE Protected Header incorrect type");if(void 0!==e.encrypted_key&&"string"!=typeof e.encrypted_key)throw new m("JWE Encrypted Key incorrect type");if(void 0!==e.aad&&"string"!=typeof e.aad)throw new m("JWE AAD incorrect type");if(void 0!==e.header&&!M(e.header))throw new m("JWE Shared Unprotected Header incorrect type");if(void 0!==e.unprotected&&!M(e.unprotected))throw new m("JWE Per-Recipient Unprotected Header incorrect type");let n;if(e.protected)try{const t=u(e.protected);n=JSON.parse(i.decode(t))}catch{throw new m("JWE Protected Header is invalid")}if(!O(n,e.header,e.unprotected))throw new m("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");const s={...n,...e.header,...e.unprotected};if(ge(m,new Map,r?.crit,n,s),void 0!==s.zip)throw new g('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');const{alg:c,enc:d}=s;if("string"!=typeof c||!c)throw new m("missing JWE Algorithm (alg) in JWE Header");if("string"!=typeof d||!d)throw new m("missing JWE Encryption Algorithm (enc) in JWE Header");const p=r&&fe("keyManagementAlgorithms",r.keyManagementAlgorithms),h=r&&fe("contentEncryptionAlgorithms",r.contentEncryptionAlgorithms);if(p&&!p.has(c)||!p&&c.startsWith("PBES2"))throw new w('"alg" (Algorithm) Header Parameter value not allowed');if(h&&!h.has(d))throw new w('"enc" (Encryption Algorithm) Header Parameter value not allowed');let l;if(void 0!==e.encrypted_key)try{l=u(e.encrypted_key)}catch{throw new m("Failed to base64url decode the encrypted_key")}let y,f,E,S=!1;"function"==typeof t&&(t=await t(n,e),S=!0);try{y=await we(c,t,l,s,r)}catch(e){if(e instanceof TypeError||e instanceof m||e instanceof g)throw e;y=se(d)}if(void 0!==e.iv)try{f=u(e.iv)}catch{throw new m("Failed to base64url decode the iv")}if(void 0!==e.tag)try{E=u(e.tag)}catch{throw new m("Failed to base64url decode the tag")}const A=a.encode(e.protected??"");let v,b;v=void 0!==e.aad?o(A,a.encode("."),a.encode(e.aad)):A;try{b=u(e.ciphertext)}catch{throw new m("Failed to base64url decode the ciphertext")}const H={plaintext:await D(d,y,b,f,E,v)};if(void 0!==e.protected&&(H.protectedHeader=n),void 0!==e.aad)try{H.additionalAuthenticatedData=u(e.aad)}catch{throw new m("Failed to base64url decode the aad")}return void 0!==e.unprotected&&(H.sharedUnprotectedHeader=e.unprotected),void 0!==e.header&&(H.unprotectedHeader=e.header),S?{...H,key:t}:H}const Ee=Symbol();async function Se(e){return(async e=>{if(e instanceof Uint8Array)return{kty:"oct",k:l(e)};if(!r(e))throw new TypeError(J(e,...x,"Uint8Array"));if(!e.extractable)throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");const{ext:n,key_ops:a,alg:i,use:s,...o}=await t.subtle.exportKey("jwk",e);return o})(e)}async function Ae(e,n,a,i,s={}){let o,c,d;switch(le(e,a,"encrypt"),a=await(ne?.(a,e))||a,e){case"dir":d=a;break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!z(a))throw new g("ECDH with the provided key is not allowed or not supported by your javascript runtime");const{apu:p,apv:h}=s;let{epk:u}=s;u||(u=(await async function(e){if(!r(e))throw new TypeError(J(e,...x));return t.subtle.generateKey(e.algorithm,!0,["deriveBits"])}(a)).privateKey);const{x:y,y:w,crv:f,kty:m}=await Se(u),E=await N(a,u,"ECDH-ES"===e?n:e,"ECDH-ES"===e?ie(n):parseInt(e.slice(-5,-2),10),p,h);if(c={epk:{x:y,crv:f,kty:m}},"EC"===m&&(c.epk.y=w),p&&(c.apu=l(p)),h&&(c.apv=l(h)),"ECDH-ES"===e){d=E;break}d=i||se(n);const S=e.slice(-6);o=await L(S,E,d);break}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":d=i||se(n),o=await(async(e,n,a)=>{if(!r(n))throw new TypeError(J(n,...x));if(k(n,e,"encrypt","wrapKey"),X(e,n),n.usages.includes("encrypt"))return new Uint8Array(await t.subtle.encrypt(V(e),n,a));if(n.usages.includes("wrapKey")){const r=await t.subtle.importKey("raw",a,...j);return new Uint8Array(await t.subtle.wrapKey("raw",r,n,V(e)))}throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation')})(e,a,d);break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{d=i||se(n);const{p2c:t,p2s:r}=s;({encryptedKey:o,...c}=await(async(e,t,r,n=2048,a=A(new Uint8Array(16)))=>{const i=await F(a,e,n,t);return{encryptedKey:await L(e.slice(-6),i,r),p2c:n,p2s:l(a)}})(e,a,d,t,r));break}case"A128KW":case"A192KW":case"A256KW":d=i||se(n),o=await L(e,a,d);break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{d=i||se(n);const{iv:t}=s;({encryptedKey:o,...c}=await async function(e,t,r,n){const a=e.slice(0,7),i=await ye(a,r,t,n,new Uint8Array(0));return{encryptedKey:i.ciphertext,iv:l(i.iv),tag:l(i.tag)}}(e,a,d,t));break}default:throw new g('Invalid or unsupported "alg" (JWE Algorithm) header value')}return{cek:d,encryptedKey:o,parameters:c}}class ve{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("plaintext must be an instance of Uint8Array");this._plaintext=e}setKeyManagementParameters(e){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=e,this}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._sharedUnprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._sharedUnprotectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}setContentEncryptionKey(e){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=e,this}setInitializationVector(e){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=e,this}async encrypt(e,t){if(!this._protectedHeader&&!this._unprotectedHeader&&!this._sharedUnprotectedHeader)throw new m("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");if(!O(this._protectedHeader,this._unprotectedHeader,this._sharedUnprotectedHeader))throw new m("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const r={...this._protectedHeader,...this._unprotectedHeader,...this._sharedUnprotectedHeader};if(ge(m,new Map,t?.crit,this._protectedHeader,r),void 0!==r.zip)throw new g('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');const{alg:n,enc:s}=r;if("string"!=typeof n||!n)throw new m('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("string"!=typeof s||!s)throw new m('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');let c,d,p,h,u;if(this._cek&&("dir"===n||"ECDH-ES"===n))throw new TypeError(`setContentEncryptionKey cannot be called with JWE "alg" (Algorithm) Header ${n}`);{let r;({cek:d,encryptedKey:c,parameters:r}=await Ae(n,s,e,this._cek,this._keyManagementParameters)),r&&(t&&Ee in t?this._unprotectedHeader?this._unprotectedHeader={...this._unprotectedHeader,...r}:this.setUnprotectedHeader(r):this._protectedHeader?this._protectedHeader={...this._protectedHeader,...r}:this.setProtectedHeader(r))}h=this._protectedHeader?a.encode(l(JSON.stringify(this._protectedHeader))):a.encode(""),this._aad?(u=l(this._aad),p=o(h,a.encode("."),a.encode(u))):p=h;const{ciphertext:y,tag:w,iv:f}=await ye(s,this._plaintext,d,this._iv,p),E={ciphertext:l(y)};return f&&(E.iv=l(f)),w&&(E.tag=l(w)),c&&(E.encrypted_key=l(c)),u&&(E.aad=u),this._protectedHeader&&(E.protected=i.decode(h)),this._sharedUnprotectedHeader&&(E.unprotected=this._sharedUnprotectedHeader),this._unprotectedHeader&&(E.header=this._unprotectedHeader),E}}class be{constructor(e,t,r){this.parent=e,this.key=t,this.options=r}setUnprotectedHeader(e){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=e,this}addRecipient(...e){return this.parent.addRecipient(...e)}encrypt(...e){return this.parent.encrypt(...e)}done(){return this.parent}}class He{constructor(e){this._recipients=[],this._plaintext=e}addRecipient(e,t){const r=new be(this,e,{crit:t?.crit});return this._recipients.push(r),r}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}async encrypt(){if(!this._recipients.length)throw new m("at least one recipient must be added");if(1===this._recipients.length){const[e]=this._recipients,t=await new ve(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(e.unprotectedHeader).encrypt(e.key,{...e.options}),r={ciphertext:t.ciphertext,iv:t.iv,recipients:[{}],tag:t.tag};return t.aad&&(r.aad=t.aad),t.protected&&(r.protected=t.protected),t.unprotected&&(r.unprotected=t.unprotected),t.encrypted_key&&(r.recipients[0].encrypted_key=t.encrypted_key),t.header&&(r.recipients[0].header=t.header),r}let e;for(let t=0;t<this._recipients.length;t++){const r=this._recipients[t];if(!O(this._protectedHeader,this._unprotectedHeader,r.unprotectedHeader))throw new m("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const n={...this._protectedHeader,...this._unprotectedHeader,...r.unprotectedHeader},{alg:a}=n;if("string"!=typeof a||!a)throw new m('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("dir"===a||"ECDH-ES"===a)throw new m('"dir" and "ECDH-ES" alg may only be used with a single recipient');if("string"!=typeof n.enc||!n.enc)throw new m('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');if(e){if(e!==n.enc)throw new m('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients')}else e=n.enc;if(ge(m,new Map,r.options.crit,this._protectedHeader,n),void 0!==n.zip)throw new g('JWE "zip" (Compression Algorithm) Header Parameter is not supported.')}const t=se(e),r={ciphertext:"",iv:"",recipients:[],tag:""};for(let n=0;n<this._recipients.length;n++){const a=this._recipients[n],i={};r.recipients.push(i);const s={...this._protectedHeader,...this._unprotectedHeader,...a.unprotectedHeader}.alg.startsWith("PBES2")?2048+n:void 0;if(0===n){const e=await new ve(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(t).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(a.unprotectedHeader).setKeyManagementParameters({p2c:s}).encrypt(a.key,{...a.options,[Ee]:!0});r.ciphertext=e.ciphertext,r.iv=e.iv,r.tag=e.tag,e.aad&&(r.aad=e.aad),e.protected&&(r.protected=e.protected),e.unprotected&&(r.unprotected=e.unprotected),i.encrypted_key=e.encrypted_key,e.header&&(i.header=e.header);continue}const{encryptedKey:o,parameters:c}=await Ae(a.unprotectedHeader?.alg||this._protectedHeader?.alg||this._unprotectedHeader?.alg,e,a.key,t,{p2c:s});i.encrypted_key=l(o),(a.unprotectedHeader||c)&&(i.header={...a.unprotectedHeader,...c})}return r}}function Ke(e,t){const r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case"EdDSA":return{name:t.name};default:throw new g(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}async function _e(e,n,a){if("sign"===a&&(n=await ae(n,e)),"verify"===a&&(n=await ne(n,e)),r(n))return C(n,e,a),n;if(n instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(J(n,...x));return t.subtle.importKey("raw",n,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[a])}throw new TypeError(J(n,...x,"Uint8Array","JSON Web Key"))}async function Pe(e,r,n){if(!M(e))throw new E("Flattened JWS must be an object");if(void 0===e.protected&&void 0===e.header)throw new E('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==e.protected&&"string"!=typeof e.protected)throw new E("JWS Protected Header incorrect type");if(void 0===e.payload)throw new E("JWS Payload missing");if("string"!=typeof e.signature)throw new E("JWS Signature missing or incorrect type");if(void 0!==e.header&&!M(e.header))throw new E("JWS Unprotected Header incorrect type");let s={};if(e.protected)try{const t=u(e.protected);s=JSON.parse(i.decode(t))}catch{throw new E("JWS Protected Header is invalid")}if(!O(s,e.header))throw new E("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const c={...s,...e.header};let d=!0;if(ge(E,new Map([["b64",!0]]),n?.crit,s,c).has("b64")&&(d=s.b64,"boolean"!=typeof d))throw new E('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:p}=c;if("string"!=typeof p||!p)throw new E('JWS "alg" (Algorithm) Header Parameter missing or invalid');if(d){if("string"!=typeof e.payload)throw new E("JWS Payload must be a string")}else if("string"!=typeof e.payload&&!(e.payload instanceof Uint8Array))throw new E("JWS Payload must be a string or an Uint8Array instance");let h=!1;"function"==typeof r?(r=await r(s,e),h=!0,ue(p,r,"verify"),q(r)&&(r=await oe(r,p))):ue(p,r,"verify");const l=o(a.encode(e.protected??""),a.encode("."),"string"==typeof e.payload?a.encode(e.payload):e.payload);let y;try{y=u(e.signature)}catch{throw new E("Failed to base64url decode the signature")}const w=await(async(e,r,n,a)=>{const i=await _e(e,r,"verify");X(e,i);const s=Ke(e,i.algorithm);try{return await t.subtle.verify(s,i,n,a)}catch{return!1}})(p,r,y,l);if(!w)throw new S;let g;if(d)try{g=u(e.payload)}catch{throw new E("Failed to base64url decode the payload")}else g="string"==typeof e.payload?a.encode(e.payload):e.payload;const f={payload:g};return void 0!==e.protected&&(f.protectedHeader=s),void 0!==e.header&&(f.unprotectedHeader=e.header),h?{...f,key:r}:f}class We{constructor(e){this._flattened=new ve(e)}setContentEncryptionKey(e){return this._flattened.setContentEncryptionKey(e),this}setInitializationVector(e){return this._flattened.setInitializationVector(e),this}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}setKeyManagementParameters(e){return this._flattened.setKeyManagementParameters(e),this}async encrypt(e,t){const r=await this._flattened.encrypt(e,t);return[r.protected,r.encrypted_key,r.iv,r.ciphertext,r.tag].join(".")}}class Ce{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=e}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}async sign(e,r){if(!this._protectedHeader&&!this._unprotectedHeader)throw new E("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!O(this._protectedHeader,this._unprotectedHeader))throw new E("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const n={...this._protectedHeader,...this._unprotectedHeader};let s=!0;if(ge(E,new Map([["b64",!0]]),r?.crit,this._protectedHeader,n).has("b64")&&(s=this._protectedHeader.b64,"boolean"!=typeof s))throw new E('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:c}=n;if("string"!=typeof c||!c)throw new E('JWS "alg" (Algorithm) Header Parameter missing or invalid');ue(c,e,"sign");let d,p=this._payload;s&&(p=a.encode(l(p))),d=this._protectedHeader?a.encode(l(JSON.stringify(this._protectedHeader))):a.encode("");const h=o(d,a.encode("."),p),u=await(async(e,r,n)=>{const a=await _e(e,r,"sign");X(e,a);const i=await t.subtle.sign(Ke(e,a.algorithm),a,n);return new Uint8Array(i)})(c,e,h),y={signature:l(u),payload:""};return s&&(y.payload=i.decode(p)),this._unprotectedHeader&&(y.header=this._unprotectedHeader),this._protectedHeader&&(y.protected=i.decode(d)),y}}class ke{constructor(e){this._flattened=new Ce(e)}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}async sign(e,t){const r=await this._flattened.sign(e,t);if(void 0===r.payload)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${r.protected}.${r.payload}.${r.signature}`}}class Te{constructor(e,t,r){this.parent=e,this.key=t,this.options=r}setProtectedHeader(e){if(this.protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this.protectedHeader=e,this}setUnprotectedHeader(e){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=e,this}addSignature(...e){return this.parent.addSignature(...e)}sign(...e){return this.parent.sign(...e)}done(){return this.parent}}class Je{constructor(e){this._signatures=[],this._payload=e}addSignature(e,t){const r=new Te(this,e,t);return this._signatures.push(r),r}async sign(){if(!this._signatures.length)throw new E("at least one signature must be added");const e={signatures:[],payload:""};for(let t=0;t<this._signatures.length;t++){const r=this._signatures[t],n=new Ce(this._payload);n.setProtectedHeader(r.protectedHeader),n.setUnprotectedHeader(r.unprotectedHeader);const{payload:a,...i}=await n.sign(r.key,r.options);if(0===t)e.payload=a;else if(e.payload!==a)throw new E("inconsistent use of JWS Unencoded Payload (RFC7797)");e.signatures.push(i)}return e}}const Re=l,Ue=u;function xe(e){let t;if("string"==typeof e){const r=e.split(".");3!==r.length&&5!==r.length||([t]=r)}else if("object"==typeof e&&e){if(!("protected"in e))throw new TypeError("Token does not contain a Protected Header");t=e.protected}try{if("string"!=typeof t||!t)throw new Error;const e=JSON.parse(i.decode(Ue(t)));if(!M(e))throw new Error;return e}catch{throw new TypeError("Invalid Token or Protected Header formatting")}}function Ie(e){const t=e?.modulusLength??2048;if("number"!=typeof t||t<2048)throw new g("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");return t}async function De(e,r){return async function(e,r){let n,a;switch(e){case"PS256":case"PS384":case"PS512":n={name:"RSA-PSS",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:Ie(r)},a=["sign","verify"];break;case"RS256":case"RS384":case"RS512":n={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:Ie(r)},a=["sign","verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":n={name:"RSA-OAEP",hash:`SHA-${parseInt(e.slice(-3),10)||1}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:Ie(r)},a=["decrypt","unwrapKey","encrypt","wrapKey"];break;case"ES256":n={name:"ECDSA",namedCurve:"P-256"},a=["sign","verify"];break;case"ES384":n={name:"ECDSA",namedCurve:"P-384"},a=["sign","verify"];break;case"ES512":n={name:"ECDSA",namedCurve:"P-521"},a=["sign","verify"];break;case"EdDSA":{a=["sign","verify"];const e=r?.crv??"Ed25519";switch(e){case"Ed25519":case"Ed448":n={name:e};break;default:throw new g("Invalid or unsupported crv option provided")}break}case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{a=["deriveKey","deriveBits"];const e=r?.crv??"P-256";switch(e){case"P-256":case"P-384":case"P-521":n={name:"ECDH",namedCurve:e};break;case"X25519":case"X448":n={name:e};break;default:throw new g("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448")}break}default:throw new g('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return t.subtle.generateKey(n,r?.extractable??!1,a)}(e,r)}async function Oe(e,r){return async function(e,r){let n,a,i;switch(e){case"HS256":case"HS384":case"HS512":n=parseInt(e.slice(-3),10),a={name:"HMAC",hash:`SHA-${n}`,length:n},i=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return n=parseInt(e.slice(-3),10),A(new Uint8Array(n>>3));case"A128KW":case"A192KW":case"A256KW":n=parseInt(e.slice(1,4),10),a={name:"AES-KW",length:n},i=["wrapKey","unwrapKey"];break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":case"A128GCM":case"A192GCM":case"A256GCM":n=parseInt(e.slice(1,4),10),a={name:"AES-GCM",length:n},i=["encrypt","decrypt"];break;default:throw new g('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return t.subtle.generateKey(a,r?.extractable,i)}(e,r)}const Me="Ed25519",je="EdDSA",$e="SHA-256",Be="RSA-OAEP-256",Le="AES-GCM",Ge="A256GCM",Ne="PBES2-HS512+A256KW",ze=!0;async function Fe(t){let r=await e.subtle.digest($e,t);return new Uint8Array(r)}function Ve(e){return Fe((new TextEncoder).encode(e))}function Xe(e){return Re(e)}function qe(e){return Ue(e)}const Ye={decodeProtectedHeader:xe,isEmptyJWSPayload:e=>!e.split(".")[1],inputBuffer(e,t){if(ArrayBuffer.isView(e))return e;let r=t.cty||"";return r.includes("text")||"string"==typeof e?t.cty=r||"text/plain":(t.cty=r||"json",e=JSON.stringify(e)),(new TextEncoder).encode(e)},recoverDataFromContentType:(e,{cty:t=e?.protectedHeader?.cty}={})=>(e&&!Object.prototype.hasOwnProperty.call(e,"payload")&&(e.payload=e.plaintext),t&&e?.payload?(e.text=(new TextDecoder).decode(e.payload),t.includes("json")&&(e.json=JSON.parse(e.text)),e):e),generateSigningKey:()=>De(je,{extractable:ze}),async sign(e,t,r={}){let n={alg:je,...r},a=this.inputBuffer(t,n);return new ke(a).setProtectedHeader(n).sign(e)},async verify(e,t,r){let n=await async function(e,t,r){if(e instanceof Uint8Array&&(e=i.decode(e)),"string"!=typeof e)throw new E("Compact JWS must be a string or Uint8Array");const{0:n,1:a,2:s,length:o}=e.split(".");if(3!==o)throw new E("Invalid Compact JWS");const c=await Pe({payload:a,protected:n,signature:s},t,r),d={payload:c.payload,protectedHeader:c.protectedHeader};return"function"==typeof t?{...d,key:c.key}:d}(t,e).catch((()=>{}));return this.recoverDataFromContentType(n,r)},generateEncryptingKey:()=>De(Be,{extractable:ze,modulusLength:4096}),async encrypt(e,t,r={}){let n={alg:this.isSymmetric(e)?"dir":Be,enc:Ge,...r},a=this.inputBuffer(t,n),i=this.keySecret(e);return new We(a).setProtectedHeader(n).encrypt(i)},async decrypt(e,t,r={}){let n=this.keySecret(e),a=await async function(e,t,r){if(e instanceof Uint8Array&&(e=i.decode(e)),"string"!=typeof e)throw new m("Compact JWE must be a string or Uint8Array");const{0:n,1:a,2:s,3:o,4:c,length:d}=e.split(".");if(5!==d)throw new m("Invalid Compact JWE");const p=await me({ciphertext:o,iv:s||void 0,protected:n,tag:c||void 0,encrypted_key:a||void 0},t,r),h={plaintext:p.plaintext,protectedHeader:p.protectedHeader};return"function"==typeof t?{...h,key:p.key}:h}(t,n);return this.recoverDataFromContentType(a,r),a},generateSecretKey:async e=>({type:"secret",text:await Ve(e)}),generateSymmetricKey(e){return e?this.generateSecretKey(e):Oe(Ge,{extractable:ze})},isSymmetric:e=>"secret"===e.type,keySecret:e=>e.text?e.text:e,async exportRaw(t){let r=await function(t){return e.subtle.exportKey("raw",t)}(t);return Xe(new Uint8Array(r))},importRaw:async t=>function(t){const r={name:Me};return e.subtle.importKey("raw",t,r,ze,["verify"])}(qe(t)),async exportJWK(e){let t=await Se(e),r=e.algorithm;if(r)"EdDSA"===r.name&&r.namedCurve===Me||r.name===Me?t.alg=je:"RSA-OAEP"===r.name&&r.hash.name===$e?t.alg=Be:r.name===Le&&256===r.length&&(t.alg=Ge);else switch(t.kty){case"EC":case"OKP":t.alg=je;break;case"RSA":t.alg=Be;break;case"oct":t.alg=Ge}return t},async importJWK(t){t={ext:!0,...t};let r=await oe(t);return r instanceof Uint8Array&&(r=await function(t){const r={name:Le,length:256};return e.subtle.importKey("raw",t,r,!0,["encrypt","decrypt"])}(r)),r},async wrapKey(e,t,r={}){let n=await this.exportJWK(e);return this.encrypt(t,n,r)},async unwrapKey(e,t){let r=await this.decrypt(t,e);return this.importJWK(r.json)}};const Qe={isMultiKey:e=>"multi"===(e.type||"multi"),keyTags:e=>Object.keys(e).filter((e=>"type"!==e)),async exportJWK(e){if(!this.isMultiKey(e))return super.exportJWK(e);let t=this.keyTags(e),r=await Promise.all(t.map((async t=>{let r=await this.exportJWK(e[t]);return r.kid=t,r})));return{keys:r}},async importJWK(e){if(!e.keys)return super.importJWK(e);let t={};return await Promise.all(e.keys.map((async e=>t[e.kid]=await this.importJWK(e)))),t},async encrypt(e,t,r={}){if(!this.isMultiKey(e))return super.encrypt(e,t,r);let n={enc:Ge,...r},a=this.inputBuffer(t,n),i=new He(a).setProtectedHeader(n);for(let t of this.keyTags(e)){let r=e[t],n="string"==typeof r,a=n||this.isSymmetric(r),s=n?(new TextEncoder).encode(r):this.keySecret(r),o=n?Ne:a?"A256GCMKW":Be;i.addRecipient(s).setUnprotectedHeader({kid:t,alg:o})}return await i.encrypt()},async decrypt(e,t,r){if(!this.isMultiKey(e))return super.decrypt(e,t,r);let n=t,{recipients:a}=n,i=a.map((async({header:t})=>{let{kid:r}=t,a=e[r],i={};if(!a)return Promise.reject("missing");"string"==typeof a&&(a=(new TextEncoder).encode(a),i.keyManagementAlgorithms=[Ne]);let s=await async function(e,t,r){if(!M(e))throw new m("General JWE must be an object");if(!Array.isArray(e.recipients)||!e.recipients.every(M))throw new m("JWE Recipients missing or incorrect type");if(!e.recipients.length)throw new m("JWE Recipients has no members");for(const n of e.recipients)try{return await me({aad:e.aad,ciphertext:e.ciphertext,encrypted_key:n.encrypted_key,header:n.header,iv:e.iv,protected:e.protected,tag:e.tag,unprotected:e.unprotected},t,r)}catch{}throw new f}(n,this.keySecret(a),i),o=s.unprotectedHeader.kid;return o!==r?function(e,t){let r=`Key ${e} does not match encoded ${t}.`;return Promise.reject(r)}(r,o):s}));return await Promise.any(i).then((e=>(this.recoverDataFromContentType(e,r),e)),(()=>{}))},async sign(e,t,r={}){if(!this.isMultiKey(e))return super.sign(e,t,r);let n=this.inputBuffer(t,r),a=new Je(n);for(let t of this.keyTags(e)){let n=e[t],i={kid:t,alg:je,...r};a.addSignature(n).setProtectedHeader(i)}return a.sign()},verifySubSignature(e,t,r,n){let a=t.protectedHeader??this.decodeProtectedHeader(t),i=t.unprotectedHeader,s=a?.kid||i?.kid,o={...e,signatures:[t]},c={protectedHeader:a,unprotectedHeader:i,kid:s},d=s?[s]:n,p=Promise.any(d.map((async e=>async function(e,t,r){if(!M(e))throw new E("General JWS must be an object");if(!Array.isArray(e.signatures)||!e.signatures.every(M))throw new E("JWS Signatures missing or incorrect type");for(const n of e.signatures)try{return await Pe({header:n.header,payload:e.payload,protected:n.protected,signature:n.signature},t,r)}catch{}throw new S}(o,r[e]).then((t=>({kid:e,...t}))))));return p.catch((()=>c))},async verify(e,t,r={}){if(!this.isMultiKey(e))return super.verify(e,t,r);if(!t.signatures)return;let n=t,a=this.keyTags(e),i=await Promise.all(n.signatures.map((t=>this.verifySubSignature(n,t,e,a))));if(!i.find((e=>e.payload)))return;let[s,...o]=i,c={protectedHeader:{},unprotectedHeader:{},signers:i},d=e=>{let t=s[e],r=c[e];for(let n in t){let a=t[n];o.some((t=>t[e][n]!==a))||(r[n]=a)}};return d("protectedHeader"),d("protectedHeader"),c.payload=i.find((e=>e.payload)).payload,this.recoverDataFromContentType(c,r)}};Object.setPrototypeOf(Qe,Ye);let Ze=class extends Map{constructor(e,t=0){super(),this.maxSize=e,this.defaultTimeToLive=t,this._nextWriteIndex=0,this._keyList=Array(e),this._timers=new Map}set(e,t,r=this.defaultTimeToLive){let n=this._nextWriteIndex;this.delete(this._keyList[n]),this._keyList[n]=e,this._nextWriteIndex=(n+1)%this.maxSize,this._timers.has(e)&&clearTimeout(this._timers.get(e)),super.set(e,t),r&&this._timers.set(e,setTimeout((()=>this.delete(e)),r))}delete(e){return this._timers.has(e)&&clearTimeout(this._timers.get(e)),this._timers.delete(e),super.delete(e)}clear(e=this.maxSize){this.maxSize=e,this._keyList=Array(e),this._nextWriteIndex=0,super.clear();for(const e of this._timers.values())clearTimeout(e);this._timers.clear()}};class et extends Map{constructor(e,t=0){super(),this.maxSize=e,this.defaultTimeToLive=t,this._nextWriteIndex=0,this._keyList=Array(e),this._timers=new Map}set(e,t,r=this.defaultTimeToLive){let n=this._nextWriteIndex;this.delete(this._keyList[n]),this._keyList[n]=e,this._nextWriteIndex=(n+1)%this.maxSize,this._timers.has(e)&&clearTimeout(this._timers.get(e)),super.set(e,t),r&&this._timers.set(e,setTimeout((()=>this.delete(e)),r))}delete(e){return this._timers.has(e)&&clearTimeout(this._timers.get(e)),this._timers.delete(e),super.delete(e)}clear(e=this.maxSize){this.maxSize=e,this._keyList=Array(e),this._nextWriteIndex=0,super.clear();for(const e of this._timers.values())clearTimeout(e);this._timers.clear()}}class tt{constructor({name:e,maxSerializerSize:t=1e3,debug:r=!1}){const n=new et(t);Object.assign(this,{name:e,debug:r,serializer:n})}async list(){return this.serialize("",((e,t)=>this.listInternal(t,e)))}async get(e){return this.serialize(e,((e,t)=>this.getInternal(t,e)))}async delete(e){return this.serialize(e,((e,t)=>this.deleteInternal(t,e)))}async put(e,t){return this.serialize(e,((e,r)=>this.putInternal(r,t,e)))}log(...e){this.debug&&console.log(this.name,...e)}async serialize(e,t){const{serializer:r,ready:n}=this;let a=r.get(e)||n;return a=a.then((async()=>t(await this.ready,this.path(e)))),r.set(e,a),await a}}const{Response:rt,URL:nt}=globalThis;var at=e=>e;function it(e,t){return t?e+at(t):e}"undefined"!=typeof window&&(at=window.prompt);const st=new URL(import.meta.url).origin,ot=/(\S{50})(\S{2})(\S{2})(\S+)/;async function ct(e){if(404===e.status)return"";if(!e.ok)return Promise.reject(e.statusText);let t=await e.text();return t?JSON.parse(t):t}const dt={get origin(){return st},tagPath:function(e,t,r="json"){if(!t)return e;let n=t.match(ot);if(!n)return`${e}/${t}`;let[a,i,s,o,c]=n;return`${e}/${s}/${o}/${i}/${c}.${r}`},uri(e,t){return`${st}/db/${this.tagPath(e,t)}`},store(e,t,r,n={}){return fetch(this.uri(e,t),{method:"PUT",body:JSON.stringify(r),headers:{"Content-Type":"application/json",...n.headers||{}}}).then(ct)},retrieve(e,t,r={}){return fetch(this.uri(e,t),{cache:"default",headers:{Accept:"application/json",...r.headers||{}}}).then(ct)}};function pt(e,t,r=void 0){let n=e(t?t.slice(0,16)+"...":"<empty tag>");return Promise.reject(new Error(n,{cause:r}))}function ht(e){return pt((e=>`The tag ${e} is not available.`),e)}class lt{static keySets=new Ze(500,36e5);static cached(e){return lt.keySets.get(e)}static cache(e,t){lt.keySets.set(e,t)}static clear(e=null){if(!e)return lt.keySets.clear();lt.keySets.delete(e)}constructor(e){this.tag=e,this.memberTags=[],lt.cache(e,this)}static getUserDeviceSecret=it;static Storage=dt;static async create(e){let{time:t,...r}=await this.createKeys(e),{tag:n}=r;return await this.persist(n,r,e,t),n}async destroy(e={}){let{tag:t,memberTags:r,signingKey:n}=this,a=await this.constructor.signForStorage({...e,message:"",tag:t,memberTags:r,signingKey:n,time:Date.now(),recovery:!0});await this.constructor.store("EncryptionKey",t,a),await this.constructor.store(this.constructor.collection,t,a),this.constructor.clear(t),e.recursiveMembers&&await Promise.allSettled(this.memberTags.map((async t=>{let r=await lt.ensure(t,{...e,recovery:!0});await r.destroy(e)})))}decrypt(e,t){let{tag:r,decryptingKey:n}=this,a=e.recipients?{[r]:n}:n;return Qe.decrypt(a,e,t)}static async sign(e,{tags:t=[],team:r,member:n,subject:a="hash",time:i=r&&Date.now(),memberTags:s,signingKey:o,recovery:c,...d}){if(r&&!n){s||(s=(await lt.ensure(r)).memberTags);let e=s.find((e=>this.cached(e)));n=e||await this.ensure1(s).then((e=>e.tag))}r&&!t.includes(r)&&(t=[r,...t]),n&&!t.includes(n)&&(t=[...t,n]);let p=await this.produceKey(t,(async e=>{let t=o||(await lt.ensure(e,{recovery:c,...d})).signingKey;return o=null,t}),d),h=Qe.inputBuffer(e,d);if("hash"===a){const e=await Fe(h);a=await Xe(e)}else a||(a=void 0);return Qe.sign(p,h,{iss:r,act:n,iat:i,sub:a,...d})}static async verify(e,t,r){let n=!e.signatures,a=await this.produceKey(t,(e=>lt.verifyingKey(e)),r,n),i=await Qe.verify(a,e,r),s=void 0===r.member?i?.protectedHeader.act:r.member,o=r.notBefore;function c(e){if(r.hardError)return Promise.reject(new Error(e))}if(!i)return c("Incorrect signature.");if(s){if("team"===r.member&&(s=i.protectedHeader.act,!s))return c("No member identified in signature.");if(!t.includes(s)){let n=await lt.verifyingKey(s),a={[s]:n};if(!await Qe.verify(a,e,r))return c("Incorrect member signature.");t.push(s),i.signers.find((e=>e.protectedHeader.kid===s)).payload=i.payload}}if(s||"team"===o){let e=i.protectedHeader.iss||i.protectedHeader.kid,t=await this.retrieve(ft.collection,e),r=t?.json;if(s&&!e)return c("No team or main tag identified in signature");if(s&&r&&!r.recipients.find((e=>e.header.kid===s)))return c("Signer is not a member.");"team"===o&&(o=t?.protectedHeader.iat||(await this.retrieve("EncryptionKey",e,"force"))?.protectedHeader.iat)}if(o){let{iat:e}=i.protectedHeader;if(e<o)return c("Signature predates required timestamp.")}return(i.signers?.filter((e=>e.payload)).length||1)!==t.length?c("Unverified signer"):i}static async produceKey(e,t,r,n=1===e.length){if(n){let n=e[0];return r.kid=n,t(n)}let a={},i=await Promise.all(e.map((e=>t(e))));return e.forEach(((e,t)=>a[e]=i[t])),a}static verifyingKey(e){return Qe.importRaw(e).catch((()=>ht(e)))}static async encryptingKey(e){let t=await this.retrieve("EncryptionKey",e);return t?await Qe.importJWK(t.json):ht(e)}static async createKeys(e){let{publicKey:t,privateKey:r}=await Qe.generateSigningKey(),{publicKey:n,privateKey:a}=await Qe.generateEncryptingKey(),i=await Qe.exportRaw(t),s=await Qe.exportJWK(n),o=Date.now(),c=await this.signForStorage({message:s,tag:i,signingKey:r,memberTags:e,time:o,recovery:!0});return await this.store("EncryptionKey",i,c),{signingKey:r,decryptingKey:a,tag:i,time:o}}static getWrapped(e){return this.retrieve(this.collection,e)}static async ensure(e,{device:t=!0,team:r=!0,recovery:n=!1}={}){let a=this.cached(e),i=t&&await wt.getWrapped(e);return i?a||=new wt(e):r&&(i=await ft.getWrapped(e))?a||=new ft(e):n&&(i=await yt.getWrapped(e))&&(a||=new yt(e)),a?.cached&&a.cached.protectedHeader.iat===i?.protectedHeader.iat&&a.cached.text===i?.text&&a.decryptingKey&&a.signingKey?a:i?(a.cached=i,a.unwrap(a.cached).then((e=>Object.assign(a,e)),(e=>(this.clear(a.tag),pt((e=>`You do not have access to the private key for ${e}.`),a.tag,e))))):(this.clear(e),ht(e))}static ensure1(e){return Promise.any(e.map((e=>lt.ensure(e)))).catch((async t=>{for(let t of e){let e=await lt.ensure(t,{device:!1,team:!1,recovery:!0}).catch((()=>null));if(e)return e}throw t}))}static async persist(e,t,r,n=Date.now(),a=r){let{signingKey:i}=t,s=await this.wrap(t,r),o=await this.signForStorage({message:s,tag:e,signingKey:i,memberTags:a,time:n,recovery:!0});await this.store(this.collection,e,o)}static async store(e,t,r){return e===wt.collection?Qe.isEmptyJWSPayload(r)?gt.delete(t):gt.put(t,r):lt.Storage.store(e,t,r)}static async retrieve(e,t,r=!1){let n=!r&&this.cached(t);if(n?.constructor.collection===e)return n.cached;let a=e===wt.collection?gt.get(t):lt.Storage.retrieve(e,t),i=await a,s=i&&await lt.verifyingKey(t);return i?(i.signatures&&(s={[t]:s}),await Qe.verify(s,i)):void 0}}class ut extends lt{static signForStorage({message:e,tag:t,signingKey:r,time:n}){return this.sign(e,{tags:[t],signingKey:r,time:n})}static async wrappingKey(e,t){let r=await this.getSecret(e,t);return Qe.generateSecretKey(r)}static async wrap(e,t=""){let{decryptingKey:r,signingKey:n,tag:a}=e,i={decryptingKey:r,signingKey:n},s=await this.wrappingKey(a,t);return Qe.wrapKey(i,s,{prompt:t})}async unwrap(e){let t=e.json||e.text,r=Qe.decodeProtectedHeader(t).prompt,n=await this.constructor.wrappingKey(this.tag,r),a=(await Qe.decrypt(n,t)).json;return await Qe.importJWK(a,{decryptingKey:"decrypt",signingKey:"sign"})}static async getSecret(e,t){return lt.getUserDeviceSecret(e,t)}}class yt extends ut{static collection="KeyRecovery"}class wt extends ut{static collection="Device"}const gt=new class extends tt{constructor(...e){super(...e),this.stripper=new RegExp(`^/${this.name}/`),this.ready=caches.open(this.name)}async listInternal(e,t){return(await t.keys()||[]).map((e=>this.tag(e.url)))}async getInternal(e,t){const r=await t.match(e);return r?.json()}deleteInternal(e,t){return t.delete(e)}putInternal(e,t,r){return r.put(e,rt.json(t))}path(e){return`/${this.name}/${e}`}tag(e){return new nt(e).pathname.replace(this.stripper,"")}destroy(){return caches.delete(this.name)}}(wt.collection);class ft extends lt{static collection="Team";static signForStorage({message:e,tag:t,...r}){return this.sign(e,{team:t,...r})}static async wrap(e,t){let{decryptingKey:r,signingKey:n}=e,a={decryptingKey:r,signingKey:n},i={};return await Promise.all(t.map((e=>lt.encryptingKey(e).then((t=>i[e]=t))))),await Qe.wrapKey(a,i)}async unwrap(e){let{recipients:t}=e.json,r=this.memberTags=t.map((e=>e.header.kid)),n=await this.constructor.ensure1(r),a=await n.decrypt(e.json);return await Qe.importJWK(a.json)}async changeMembership({add:e=[],remove:t=[]}={}){let{memberTags:r}=this,n=r.concat(e).filter((e=>!t.includes(e)));await this.constructor.persist(this.tag,this,n,Date.now(),r),this.memberTags=n,this.constructor.clear(this.tag)}}var mt={name:"@ki1r0y/distributed-security",version:"1.2.0",description:"Signed and encrypted document infrastructure based on public key encryption and self-organizing users.",type:"module",exports:{".":{node:"./lib/api.mjs",default:"./index.mjs"},"./spec.mjs":{node:"./spec/securitySpec.mjs",default:"dist/securitySpec-bundle.mjs"}},imports:{"#crypto":{node:"./lib/crypto-node.mjs",default:"./lib/crypto-browser.mjs"},"#raw":{node:"./lib/raw-node.mjs",default:"./lib/raw-browser.mjs"},"#origin":{node:"./lib/origin-node.mjs",default:"./lib/origin-browser.mjs"},"#internals":{node:"./spec/support/internals.mjs",default:"./spec/support/internal-browser-bundle.mjs"}},scripts:{build:"rollup -c","build-dev":"npx rollup -c --environment NODE_ENV:development",test:"jasmine"},engines:{node:">=18.19.0"},repository:{type:"git",url:"git+https://github.com/kilroy-code/distributed-security.git"},publishConfig:{registry:"https://registry.npmjs.org"},keywords:["encryption","pki","dao"],author:{name:"Howard Stearns",email:"howard@ki1r0y.com"},license:"MIT",bugs:{url:"https://github.com/kilroy-code/distributed-security/issues"},homepage:"https://github.com/kilroy-code/distributed-security#readme",devDependencies:{"@rollup/plugin-json":"^6.1.0","@rollup/plugin-node-resolve":"15.3","@rollup/plugin-terser":"^0.4.4",jasmine:"^5.4.0",rollup:"4.27"},dependencies:{"@ki1r0y/cache":"^1.0.1","@ki1r0y/jsonrpc":"^1.0.1","@ki1r0y/storage":"^1.0.2",jose:"5.9"}};const{name:Et,version:St}=mt,At={get KeySet(){return lt},set Storage(e){lt.Storage=e},get Storage(){return lt.Storage},set getUserDeviceSecret(e){lt.getUserDeviceSecret=e},get getUserDeviceSecret(){return lt.getUserDeviceSecret},ready:{name:Et,version:St,origin:lt.Storage.origin},async encrypt(e,...t){let r={},n=this.canonicalizeParameters(t,r),a=await lt.produceKey(n,(e=>lt.encryptingKey(e)),r);return Qe.encrypt(a,e,r)},async decrypt(e,...t){let r={},[n]=this.canonicalizeParameters(t,r,e),{recovery:a,...i}=r;return(await lt.ensure(n,{recovery:a})).decrypt(e,i)},async sign(e,...t){let r={},n=this.canonicalizeParameters(t,r);return lt.sign(e,{tags:n,...r})},async verify(e,...t){let r={},n=this.canonicalizeParameters(t,r,e);return lt.verify(e,n,r)},async create(...e){if(!e.length)return await wt.create();let t=e[0].prompt;return t?await yt.create(t):await ft.create(e)},changeMembership:async({tag:e,recovery:t=!1,...r})=>(await lt.ensure(e,{recovery:t,...r})).changeMembership(r),async destroy(e){"string"==typeof e&&(e={tag:e});let{tag:t,recovery:r=!0,...n}=e,a={recovery:r,...n};return(await lt.ensure(t,a)).destroy(a)},clear(e){lt.clear(e)},hashBuffer:Fe,hashText:Ve,encodeBase64url:Xe,decodeBase64url:qe,decodeClaims:function(e,t=0){return xe(e.signatures?.[t]||e)},canonicalizeParameters(e,t,r){if(e.length>1||void 0!==e[0]?.length)return e;let{tags:n=[],contentType:a,time:i,...s}=e[0]||{},{team:o}=s;if(!n.length)if(e.length&&e[0].length)n=e;else if(r)if(r.signatures)n=r.signatures.map((e=>Qe.decodeProtectedHeader(e).kid));else if(r.recipients)n=r.recipients.map((e=>e.header.kid));else{let e=Qe.decodeProtectedHeader(r).kid;e&&(n=[e])}return o&&!n.includes(o)&&(n=[o,...n]),a&&(t.cty=a),i&&(t.iat=i),Object.assign(t,s),n}};const vt=function({target:e=self,receiver:t=e,namespace:r=t,origin:n=e!==t&&e.location.origin,dispatcherLabel:a=r.name||t.name||t.location?.href||t,targetLabel:i=e.name||n||e.location?.href||e,log:s=null,info:o=console.info.bind(console),warn:c=console.warn.bind(console),error:d=console.error.bind(console)}){const p={},h="2.0",l=e.postMessage.bind(e),u=n?e=>l(e,n):l;let y=0;return t.addEventListener("message",(async function(t){s?.(a,"got message",t.data,"from",i,t.origin);let{id:o,method:l,params:y=[],result:w,error:g,jsonrpc:f}=t.data||{};if(t.source&&t.source!==e)return d?.(a,"to",i,"got message from",t.source);if(n&&n!==t.origin)return d?.(a,n,"mismatched origin",i,t.origin);if(f!==h)return c?.(`${a} ignoring non-jsonrpc message ${JSON.stringify(t.data)}.`);if(l){let e,t=null,n=Array.isArray(y)?y:[y];try{e=await r[l](...n)}catch(e){t=function(e){let{name:t,message:r,code:n,data:a}=e;return{name:t,message:r,code:n,data:a}}(e),r[l]||t.message.includes(l)?t.message||(t.message=`${t.name||t.toString()} in ${l}.`):(t.message=`${l} is not defined.`,t.code=-32601)}if(void 0===o)return;let c=t?{id:o,error:t,jsonrpc:h}:{id:o,result:e,jsonrpc:h};return s?.(a,"answering",o,t||e,"to",i),u(c)}let m=p[o];if(delete p[o],!m)return c?.(`${a} ignoring response ${t.data}.`);g?m.reject(g):m.resolve(w)})),o?.(`${a} will dispatch to ${i}`),function(e,...t){let r=++y,n=p[r]={};return new Promise(((o,c)=>{s?.(a,"request",r,e,t,"to",i),Object.assign(n,{resolve:o,reject:c}),u({id:r,method:e,params:t,jsonrpc:h})}))}}({targetLabel:"vault:"+self.name.split("!")[1],namespace:At});At.Storage={store:(...e)=>vt("store",...e),retrieve:(...e)=>vt("retrieve",...e)},At.getUserDeviceSecret=(e,t="")=>vt("getUserDeviceSecret",e,t),vt("ready",At.ready);
