const e={async store(e,t,a){let r=await this.Security.verify(a,{team:t,notBefore:"team"});if(!r)throw new Error(`Signature ${a} does not match owner of ${t}.`);return r.payload.length?this[e][t]=a:delete this[e][t],null},async retrieve(e,t){return this[e][t]},Team:{},KeyRecovery:{},EncryptionKey:{}};const t=import.meta.url,a=new URL("lib/vault-bundle.mjs",t),r=document.createElement("iframe"),i={log(...e){console.log(...e)}},n={sign:(e,...t)=>c("sign",e,...t),verify:(e,...t)=>c("verify",e,...t),encrypt:(e,...t)=>c("encrypt",e,...t),decrypt:(e,...t)=>c("decrypt",e,...t),create:(...e)=>c("create",...e),changeMembership:({tag:e,add:t,remove:a}={})=>c("changeMembership",{tag:e,add:t,remove:a}),destroy:e=>c("destroy",e),clear:(e=null)=>c("clear",e),set Storage(e){Object.assign(i,e)},set getUserDeviceSecret(e){i.getUserDeviceSecret=e},ready:new Promise((e=>{i.ready=e,r.style.display="none",document.body.append(r),r.setAttribute("srcdoc",`<!DOCTYPE html><html><body><script type="module" src="${a.href}"><\/script></body></html>`)}))},c=function({target:e,receiver:t=e,namespace:a=t,origin:r=e!==t&&e.location.origin,log:i=(()=>null),warn:n=console.warn.bind(console),error:c=console.error.bind(console)}){let o={},s=0,d="2.0",y=r||e,p=e.postMessage.bind(e),l=r?e=>p(e,r):p;return i("dispatch to",y),t.addEventListener("message",(async t=>{i("message",t.data,"from",t.origin||y);let{id:s,method:p,params:u=[],result:w,error:h,jsonrpc:f}=t.data||{};if(t.source&&t.source!==e)return c("mismatched target:",e,t.source);if(r&&r!==t.origin)return c("mismatched origin",r,t.origin);if(f!==d)return n(`Ignoring non-jsonrpc message ${JSON.stringify(t.data)}.`);if(p){let e,t=null,r=Array.isArray(u)?u:[u];try{e=await a[p](...r)}catch(e){t=function(e){let{name:t,message:a}=e;return{name:t,message:a}}(e),a[p]||t.message.includes(p)?t.message||(t.message=`${t.name||t.toString()} in ${p}.`):t.message=`${p} is not defined.`}let n=t?{id:s,error:t,jsonrpc:d}:{id:s,result:e,jsonrpc:d};return i("answering",s,t||e,"to",y),l(n)}let g=o[s];if(delete o[s],!g)return console.log(`Ignoring response ${t.data}.`);h?g.reject(h):g.resolve(w)})),function(e,...t){let a=++s,r=o[a]={};return new Promise(((n,c)=>{Object.assign(r,{resolve:n,reject:c}),i("posting",a,e,t,"to",y),l({id:a,method:e,params:t,jsonrpc:d})}))}}({dispatcherLabel:t,target:r.contentWindow,targetLabel:"vault",receiver:self,origin:a.origin,namespace:i}),o=10485760;function s(e=o){return Array.from({length:e},((e,t)=>1&t)).join("")}const d=/^[A-Za-z0-9_\-.]+$/;function y(e,t=d){expect(t.test(e)).toBeTruthy()}function p(e,t){expect(new Uint8Array(e.payload)).toEqual(t)}function l(e,t=446){const a=1e4,r=t>1e3?a:5e3,i=s();describe("signing",(function(){let t;beforeAll((async function(){t=await e.generateSigningKey()})),it("with a private key produces a base64URL signature that verifies with the public key.",(async function(){let a=await e.sign(t.privateKey,i);y(a),expect(await e.verify(t.publicKey,a)).toBeTruthy()})),it("returns undefined for verify with the wrong key.",(async function(){let a=await e.sign(t.privateKey,i),r=await e.generateSigningKey();expect(await e.verify(r.publicKey,a)).toBeUndefined()})),it("handles binary, and verifies with that as payload property.",(async function(){let a=new Uint8Array([21,31]),r=await e.sign(t.privateKey,a),i=await e.verify(t.publicKey,r);expect(i.cty).toBeUndefined(),p(i,a)})),it('handles text, setting cty as "text/plain", and verifies with that as the text property and an encoding of that for payload.',(async function(){let a=await e.sign(t.privateKey,i),r=await e.verify(t.publicKey,a);expect(r.protectedHeader.cty).toBe("text/plain"),expect(r.text).toBe(i),expect(r.payload).toEqual((new TextEncoder).encode(i))})),it('handles json, setting cty as "json", and verifies with that as json property, the string of that as the text property, and the encoding of that string for payload.',(async function(){let a={foo:"bar"},r=await e.sign(t.privateKey,a),i=await e.verify(t.publicKey,r);expect(i.protectedHeader.cty).toBe("json"),expect(i.json).toEqual(a),expect(i.text).toBe(JSON.stringify(a)),expect(i.payload).toEqual((new TextEncoder).encode(JSON.stringify(a)))})),it("Uses specified headers if supplied, including cty.",(async function(){let a="text/html",r=Date.now(),i="<something else>",n=await e.sign(t.privateKey,i,{cty:a,iat:r,foo:17}),c=await e.verify(t.publicKey,n);expect(c.protectedHeader.cty).toBe(a),expect(c.protectedHeader.iat).toBe(r),expect(c.protectedHeader.foo).toBe(17),expect(c.text).toEqual(i)}))})),describe("encryption",(function(){let n;function c(t,a,r=a){it(`can work on much larger data with a ${t}.`,(async function(){let t=await a,n=await r,c=await e.encrypt(t,i),o=await e.decrypt(n,c);y(c),expect(o.text).toBe(i)}))}function o(r,i){it(`rejects wrong ${r}.`,(async function(){let[a,r]=await i(),n=s(t),c=await e.encrypt(a,n);await expectAsync(e.decrypt(r,c)).toBeRejected()}),a)}beforeAll((async function(){n=await e.generateEncryptingKey()})),it(`can work up through at least ${t} bytes with an asymmetric keypair.`,(async function(){let a=s(t),r=await e.encrypt(n.publicKey,a),i=await e.decrypt(n.privateKey,r);y(r),expect(i.text).toBe(a)}),r),c("fixed symmetric key",e.generateSymmetricKey()),c("reproducible secret",e.generateSymmetricKey("secret"),e.generateSymmetricKey("secret")),it("handles binary, and decrypts as same.",(async function(){let t=new Uint8Array([21,31]),a=await e.encrypt(n.publicKey,t),r=await e.decrypt(n.privateKey,a),i=e.decodeProtectedHeader(a);expect(i.cty).toBeUndefined(),p(r,t)})),it("handles text, and decrypts as same.",(async function(){let t=await e.encrypt(n.publicKey,i),a=await e.decrypt(n.privateKey,t),r=e.decodeProtectedHeader(t);expect(r.cty).toBe("text/plain"),expect(a.text).toBe(i)})),it("handles json, and decrypts as same.",(async function(){let t={foo:"bar"},a=await e.encrypt(n.publicKey,t),r=e.decodeProtectedHeader(a),i=await e.decrypt(n.privateKey,a);expect(r.cty).toBe("json"),expect(i.json).toEqual(t)})),it("Uses specified headers if supplied, including cty.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await e.encrypt(n.publicKey,r,{cty:t,iat:a,foo:17}),c=await e.decrypt(n.privateKey,i),o=e.decodeProtectedHeader(i);expect(o.cty).toBe(t),expect(o.iat).toBe(a),expect(o.foo).toBe(17),expect(c.text).toBe(r)})),o("asymmetric key",(async()=>[(await e.generateEncryptingKey()).publicKey,(await e.generateEncryptingKey()).privateKey])),o("symmetric key",(async()=>[await e.generateSymmetricKey(),await e.generateSymmetricKey()])),o("secret",(async()=>[await e.generateSymmetricKey("secret"),await e.generateSymmetricKey("secretX")]))})),describe("export/import",(function(){async function t(t){return JSON.stringify(await e.exportJWK(t))}function a(t){return e.importJWK(JSON.parse(t))}describe("of signing keys",(function(){it("works with the private signing key as a 253 byte serialization.",(async function(){let r=await e.generateSigningKey(),n=await t(r.privateKey),c=await a(n),o=await e.sign(c,i);expect(n.length).toBe(253),expect(await e.verify(r.publicKey,o)).toBeTruthy()}));it("works with the public verifying key as a 182 byte serialization.",(async function(){let r=await e.generateSigningKey(),n=await t(r.publicKey),c=await a(n),o=await e.sign(r.privateKey,i);expect(n.length).toBe(182),expect(await e.verify(c,o)).toBeTruthy()}));it("works with public key as a raw verifying key as a base64URL serialization of no more that 132 bytes",(async function(){let t=await e.generateSigningKey(),a=await e.exportRaw(t.publicKey),r=await e.importRaw(a),n=await e.sign(t.privateKey,i);y(a),expect(a.length).toBeLessThanOrEqual(132),expect(await e.verify(r,n)).toBeTruthy()}))})),describe("of encryption keys",(function(){const r=[3169,3173];it(`works with the private key as a ${r[0]}-${r[1]} byte serialization.`,(async function(){let i=await e.generateEncryptingKey(),n=await t(i.privateKey),c=await a(n),o=s(446),d=await e.encrypt(i.publicKey,o),y=await e.decrypt(c,d);expect(n.length).toBeGreaterThanOrEqual(r[0]),expect(n.length).toBeLessThanOrEqual(r[1]),expect(y.text).toBe(o)}));it("works with the public key as a 735 byte serialization.",(async function(){let r=await e.generateEncryptingKey(),i=await t(r.publicKey),n=await a(i),c=s(446),o=await e.encrypt(n,c),d=await e.decrypt(r.privateKey,o);expect(i.length).toBe(735),expect(d.text).toBe(c)}))})),describe("of symmetric key",(function(){it("works as a 79 byte serialization.",(async function(){let r=await e.generateSymmetricKey(),n=await t(r),c=await a(n),o=await e.encrypt(r,i),s=await e.decrypt(c,o);expect(n.length).toBe(79),expect(s.text).toBe(i)}))}))})),it("wraps like export+encrypt.",(async function(){let t=await e.generateSymmetricKey(),a=await e.generateEncryptingKey(),r=await e.exportJWK(t),i=await e.encrypt(a.publicKey,r),n=await e.decrypt(a.privateKey,i),c=await e.importJWK(n.json),o=await e.wrapKey(t,a.publicKey),s=await e.unwrapKey(o,a.privateKey),d="this is a message",p=await e.encrypt(s,d),l=await e.decrypt(c,p);y(o),expect(l.text).toBe(d)}),a)}var u=crypto;const w=e=>e instanceof CryptoKey,h=async(e,t)=>{const a=`SHA-${e.slice(-3)}`;return new Uint8Array(await u.subtle.digest(a,t))},f=new TextEncoder,g=new TextDecoder,m=2**32;function b(...e){const t=e.reduce(((e,{length:t})=>e+t),0),a=new Uint8Array(t);let r=0;for(const t of e)a.set(t,r),r+=t.length;return a}function v(e,t,a){if(t<0||t>=m)throw new RangeError(`value must be >= 0 and <= ${m-1}. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,255&t],a)}function E(e){const t=Math.floor(e/m),a=e%m,r=new Uint8Array(8);return v(r,t,0),v(r,a,4),r}function S(e){const t=new Uint8Array(4);return v(t,e),t}function x(e){return b(S(e.length),e)}const A=e=>(e=>{let t=e;"string"==typeof t&&(t=f.encode(t));const a=[];for(let e=0;e<t.length;e+=32768)a.push(String.fromCharCode.apply(null,t.subarray(e,e+32768)));return btoa(a.join(""))})(e).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),K=e=>{let t=e;t instanceof Uint8Array&&(t=g.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return(e=>{const t=atob(e),a=new Uint8Array(t.length);for(let e=0;e<t.length;e++)a[e]=t.charCodeAt(e);return a})(t)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}};class H extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(e){super(e),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,Error.captureStackTrace?.(this,this.constructor)}}class P extends H{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class B extends H{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class k extends H{constructor(){super(...arguments),this.code="ERR_JWE_DECRYPTION_FAILED",this.message="decryption operation failed"}static get code(){return"ERR_JWE_DECRYPTION_FAILED"}}class C extends H{constructor(){super(...arguments),this.code="ERR_JWE_INVALID"}static get code(){return"ERR_JWE_INVALID"}}class T extends H{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class W extends H{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}var U=u.getRandomValues.bind(u);function _(e){switch(e){case"A128GCM":case"A128GCMKW":case"A192GCM":case"A192GCMKW":case"A256GCM":case"A256GCMKW":return 96;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return 128;default:throw new B(`Unsupported JWE Algorithm: ${e}`)}}const J=(e,t)=>{if(t.length<<3!==_(e))throw new C("Invalid Initialization Vector length")},R=(e,t)=>{const a=e.byteLength<<3;if(a!==t)throw new C(`Invalid Content Encryption Key length. Expected ${t} bits, got ${a} bits`)};function D(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function j(e,t){return e.name===t}function O(e){return parseInt(e.name.slice(4),10)}function M(e,t){if(t.length&&!t.some((t=>e.usages.includes(t)))){let e="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const a=t.pop();e+=`one of ${t.join(", ")}, or ${a}.`}else 2===t.length?e+=`one of ${t[0]} or ${t[1]}.`:e+=`${t[0]}.`;throw new TypeError(e)}}function I(e,t,...a){switch(t){case"HS256":case"HS384":case"HS512":{if(!j(e.algorithm,"HMAC"))throw D("HMAC");const a=parseInt(t.slice(2),10);if(O(e.algorithm.hash)!==a)throw D(`SHA-${a}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!j(e.algorithm,"RSASSA-PKCS1-v1_5"))throw D("RSASSA-PKCS1-v1_5");const a=parseInt(t.slice(2),10);if(O(e.algorithm.hash)!==a)throw D(`SHA-${a}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!j(e.algorithm,"RSA-PSS"))throw D("RSA-PSS");const a=parseInt(t.slice(2),10);if(O(e.algorithm.hash)!==a)throw D(`SHA-${a}`,"algorithm.hash");break}case"EdDSA":if("Ed25519"!==e.algorithm.name&&"Ed448"!==e.algorithm.name)throw D("Ed25519 or Ed448");break;case"ES256":case"ES384":case"ES512":{if(!j(e.algorithm,"ECDSA"))throw D("ECDSA");const a=function(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}(t);if(e.algorithm.namedCurve!==a)throw D(a,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}M(e,a)}function $(e,t,...a){switch(t){case"A128GCM":case"A192GCM":case"A256GCM":{if(!j(e.algorithm,"AES-GCM"))throw D("AES-GCM");const a=parseInt(t.slice(1,4),10);if(e.algorithm.length!==a)throw D(a,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!j(e.algorithm,"AES-KW"))throw D("AES-KW");const a=parseInt(t.slice(1,4),10);if(e.algorithm.length!==a)throw D(a,"algorithm.length");break}case"ECDH":switch(e.algorithm.name){case"ECDH":case"X25519":case"X448":break;default:throw D("ECDH, X25519, or X448")}break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!j(e.algorithm,"PBKDF2"))throw D("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!j(e.algorithm,"RSA-OAEP"))throw D("RSA-OAEP");const a=parseInt(t.slice(9),10)||1;if(O(e.algorithm.hash)!==a)throw D(`SHA-${a}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}M(e,a)}function G(e,t,...a){if(a.length>2){const t=a.pop();e+=`one of type ${a.join(", ")}, or ${t}.`}else 2===a.length?e+=`one of type ${a[0]} or ${a[1]}.`:e+=`of type ${a[0]}.`;return null==t?e+=` Received ${t}`:"function"==typeof t&&t.name?e+=` Received function ${t.name}`:"object"==typeof t&&null!=t&&t.constructor?.name&&(e+=` Received an instance of ${t.constructor.name}`),e}var F=(e,...t)=>G("Key must be ",e,...t);function L(e,t,...a){return G(`Key for the ${e} algorithm must be `,t,...a)}var N=e=>w(e);const z=["CryptoKey"];async function q(e,t,a,r,i,n){if(!(t instanceof Uint8Array))throw new TypeError(F(t,"Uint8Array"));const c=parseInt(e.slice(1,4),10),o=await u.subtle.importKey("raw",t.subarray(c>>3),"AES-CBC",!1,["decrypt"]),s=await u.subtle.importKey("raw",t.subarray(0,c>>3),{hash:"SHA-"+(c<<1),name:"HMAC"},!1,["sign"]),d=b(n,r,a,E(n.length<<3)),y=new Uint8Array((await u.subtle.sign("HMAC",s,d)).slice(0,c>>3));let p,l;try{p=((e,t)=>{if(!(e instanceof Uint8Array))throw new TypeError("First argument must be a buffer");if(!(t instanceof Uint8Array))throw new TypeError("Second argument must be a buffer");if(e.length!==t.length)throw new TypeError("Input buffers must have the same length");const a=e.length;let r=0,i=-1;for(;++i<a;)r|=e[i]^t[i];return 0===r})(i,y)}catch{}if(!p)throw new k;try{l=new Uint8Array(await u.subtle.decrypt({iv:r,name:"AES-CBC"},o,a))}catch{}if(!l)throw new k;return l}const V=async(e,t,a,r,i,n)=>{if(!(w(t)||t instanceof Uint8Array))throw new TypeError(F(t,...z,"Uint8Array"));if(!r)throw new C("JWE Initialization Vector missing");if(!i)throw new C("JWE Authentication Tag missing");switch(J(e,r),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return t instanceof Uint8Array&&R(t,parseInt(e.slice(-3),10)),q(e,t,a,r,i,n);case"A128GCM":case"A192GCM":case"A256GCM":return t instanceof Uint8Array&&R(t,parseInt(e.slice(1,4),10)),async function(e,t,a,r,i,n){let c;t instanceof Uint8Array?c=await u.subtle.importKey("raw",t,"AES-GCM",!1,["decrypt"]):($(t,e,"decrypt"),c=t);try{return new Uint8Array(await u.subtle.decrypt({additionalData:n,iv:r,name:"AES-GCM",tagLength:128},c,b(a,i)))}catch{throw new k}}(e,t,a,r,i,n);default:throw new B("Unsupported JWE Content Encryption Algorithm")}},X=(...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let a;for(const e of t){const t=Object.keys(e);if(a&&0!==a.size)for(const e of t){if(a.has(e))return!1;a.add(e)}else a=new Set(t)}return!0};function Y(e){if("object"!=typeof(t=e)||null===t||"[object Object]"!==Object.prototype.toString.call(e))return!1;var t;if(null===Object.getPrototypeOf(e))return!0;let a=e;for(;null!==Object.getPrototypeOf(a);)a=Object.getPrototypeOf(a);return Object.getPrototypeOf(e)===a}const Z=[{hash:"SHA-256",name:"HMAC"},!0,["sign"]];function Q(e,t){if(e.algorithm.length!==parseInt(t.slice(1,4),10))throw new TypeError(`Invalid key size for alg: ${t}`)}function ee(e,t,a){if(w(e))return $(e,t,a),e;if(e instanceof Uint8Array)return u.subtle.importKey("raw",e,"AES-KW",!0,[a]);throw new TypeError(F(e,...z,"Uint8Array"))}const te=async(e,t,a)=>{const r=await ee(t,e,"wrapKey");Q(r,e);const i=await u.subtle.importKey("raw",a,...Z);return new Uint8Array(await u.subtle.wrapKey("raw",i,r,"AES-KW"))},ae=async(e,t,a)=>{const r=await ee(t,e,"unwrapKey");Q(r,e);const i=await u.subtle.unwrapKey("raw",a,r,"AES-KW",...Z);return new Uint8Array(await u.subtle.exportKey("raw",i))};async function re(e,t,a,r,i=new Uint8Array(0),n=new Uint8Array(0)){if(!w(e))throw new TypeError(F(e,...z));if($(e,"ECDH"),!w(t))throw new TypeError(F(t,...z));$(t,"ECDH","deriveBits");const c=b(x(f.encode(a)),x(i),x(n),S(r));let o;o="X25519"===e.algorithm.name?256:"X448"===e.algorithm.name?448:Math.ceil(parseInt(e.algorithm.namedCurve.substr(-3),10)/8)<<3;return async function(e,t,a){const r=Math.ceil((t>>3)/32),i=new Uint8Array(32*r);for(let t=0;t<r;t++){const r=new Uint8Array(4+e.length+a.length);r.set(S(t+1)),r.set(e,4),r.set(a,4+e.length),i.set(await h("sha256",r),32*t)}return i.slice(0,t>>3)}(new Uint8Array(await u.subtle.deriveBits({name:e.algorithm.name,public:e},t,o)),r,c)}function ie(e){if(!w(e))throw new TypeError(F(e,...z));return["P-256","P-384","P-521"].includes(e.algorithm.namedCurve)||"X25519"===e.algorithm.name||"X448"===e.algorithm.name}async function ne(e,t,a,r){!function(e){if(!(e instanceof Uint8Array)||e.length<8)throw new C("PBES2 Salt Input must be 8 or more octets")}(e);const i=function(e,t){return b(f.encode(e),new Uint8Array([0]),t)}(t,e),n=parseInt(t.slice(13,16),10),c={hash:`SHA-${t.slice(8,11)}`,iterations:a,name:"PBKDF2",salt:i},o={length:n,name:"AES-KW"},s=await function(e,t){if(e instanceof Uint8Array)return u.subtle.importKey("raw",e,"PBKDF2",!1,["deriveBits"]);if(w(e))return $(e,t,"deriveBits","deriveKey"),e;throw new TypeError(F(e,...z,"Uint8Array"))}(r,t);if(s.usages.includes("deriveBits"))return new Uint8Array(await u.subtle.deriveBits(c,s,n));if(s.usages.includes("deriveKey"))return u.subtle.deriveKey(c,s,o,!1,["wrapKey","unwrapKey"]);throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"')}const ce=async(e,t,a,r,i)=>{const n=await ne(i,e,r,t);return ae(e.slice(-6),n,a)};function oe(e){switch(e){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return"RSA-OAEP";default:throw new B(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}var se=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:a}=t.algorithm;if("number"!=typeof a||a<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};const de=async(e,t,a)=>{if(!w(t))throw new TypeError(F(t,...z));if($(t,e,"decrypt","unwrapKey"),se(e,t),t.usages.includes("decrypt"))return new Uint8Array(await u.subtle.decrypt(oe(e),t,a));if(t.usages.includes("unwrapKey")){const r=await u.subtle.unwrapKey("raw",a,t,oe(e),...Z);return new Uint8Array(await u.subtle.exportKey("raw",r))}throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation')};function ye(e){switch(e){case"A128GCM":return 128;case"A192GCM":return 192;case"A256GCM":case"A128CBC-HS256":return 256;case"A192CBC-HS384":return 384;case"A256CBC-HS512":return 512;default:throw new B(`Unsupported JWE Algorithm: ${e}`)}}var pe=e=>U(new Uint8Array(ye(e)>>3));var le=async e=>{if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:t,keyUsages:a}=function(e){let t,a;switch(e.kty){case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},a=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},a=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},a=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new B('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},a=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},a=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},a=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},a=e.d?["deriveBits"]:[];break;default:throw new B('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"OKP":switch(e.alg){case"EdDSA":t={name:e.crv},a=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},a=e.d?["deriveBits"]:[];break;default:throw new B('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;default:throw new B('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:a}}(e),r=[t,e.ext??!1,e.key_ops??a],i={...e};return delete i.alg,delete i.use,u.subtle.importKey("jwk",i,...r)};async function ue(e,t){if(!Y(e))throw new TypeError("JWK must be an object");switch(t||(t=e.alg),e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return K(e.k);case"RSA":if(void 0!==e.oth)throw new B('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return le({...e,alg:t});default:throw new B('Unsupported "kty" (Key Type) Parameter value')}}const we=(e,t,a)=>{e.startsWith("HS")||"dir"===e||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e)?((e,t)=>{if(!(t instanceof Uint8Array)){if(!N(t))throw new TypeError(L(e,t,...z,"Uint8Array"));if("secret"!==t.type)throw new TypeError(`${z.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}})(e,t):((e,t,a)=>{if(!N(t))throw new TypeError(L(e,t,...z));if("secret"===t.type)throw new TypeError(`${z.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===a&&"public"===t.type)throw new TypeError(`${z.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===a&&"public"===t.type)throw new TypeError(`${z.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(t.algorithm&&"verify"===a&&"private"===t.type)throw new TypeError(`${z.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(t.algorithm&&"encrypt"===a&&"private"===t.type)throw new TypeError(`${z.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)})(e,t,a)};const he=async(e,t,a,r,i)=>{if(!(w(a)||a instanceof Uint8Array))throw new TypeError(F(a,...z,"Uint8Array"));switch(r?J(e,r):r=U(new Uint8Array(_(e)>>3)),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return a instanceof Uint8Array&&R(a,parseInt(e.slice(-3),10)),async function(e,t,a,r,i){if(!(a instanceof Uint8Array))throw new TypeError(F(a,"Uint8Array"));const n=parseInt(e.slice(1,4),10),c=await u.subtle.importKey("raw",a.subarray(n>>3),"AES-CBC",!1,["encrypt"]),o=await u.subtle.importKey("raw",a.subarray(0,n>>3),{hash:"SHA-"+(n<<1),name:"HMAC"},!1,["sign"]),s=new Uint8Array(await u.subtle.encrypt({iv:r,name:"AES-CBC"},c,t)),d=b(i,r,s,E(i.length<<3));return{ciphertext:s,tag:new Uint8Array((await u.subtle.sign("HMAC",o,d)).slice(0,n>>3)),iv:r}}(e,t,a,r,i);case"A128GCM":case"A192GCM":case"A256GCM":return a instanceof Uint8Array&&R(a,parseInt(e.slice(1,4),10)),async function(e,t,a,r,i){let n;a instanceof Uint8Array?n=await u.subtle.importKey("raw",a,"AES-GCM",!1,["encrypt"]):($(a,e,"encrypt"),n=a);const c=new Uint8Array(await u.subtle.encrypt({additionalData:i,iv:r,name:"AES-GCM",tagLength:128},n,t)),o=c.slice(-16);return{ciphertext:c.slice(0,-16),tag:o,iv:r}}(e,t,a,r,i);default:throw new B("Unsupported JWE Content Encryption Algorithm")}};async function fe(e,t,a,r,i){switch(we(e,t,"decrypt"),e){case"dir":if(void 0!==a)throw new C("Encountered unexpected JWE Encrypted Key");return t;case"ECDH-ES":if(void 0!==a)throw new C("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!Y(r.epk))throw new C('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(!ie(t))throw new B("ECDH with the provided key is not allowed or not supported by your javascript runtime");const i=await ue(r.epk,e);let n,c;if(void 0!==r.apu){if("string"!=typeof r.apu)throw new C('JOSE Header "apu" (Agreement PartyUInfo) invalid');try{n=K(r.apu)}catch{throw new C("Failed to base64url decode the apu")}}if(void 0!==r.apv){if("string"!=typeof r.apv)throw new C('JOSE Header "apv" (Agreement PartyVInfo) invalid');try{c=K(r.apv)}catch{throw new C("Failed to base64url decode the apv")}}const o=await re(i,t,"ECDH-ES"===e?r.enc:e,"ECDH-ES"===e?ye(r.enc):parseInt(e.slice(-5,-2),10),n,c);if("ECDH-ES"===e)return o;if(void 0===a)throw new C("JWE Encrypted Key missing");return ae(e.slice(-6),o,a)}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":if(void 0===a)throw new C("JWE Encrypted Key missing");return de(e,t,a);case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{if(void 0===a)throw new C("JWE Encrypted Key missing");if("number"!=typeof r.p2c)throw new C('JOSE Header "p2c" (PBES2 Count) missing or invalid');const n=i?.maxPBES2Count||1e4;if(r.p2c>n)throw new C('JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds');if("string"!=typeof r.p2s)throw new C('JOSE Header "p2s" (PBES2 Salt) missing or invalid');let c;try{c=K(r.p2s)}catch{throw new C("Failed to base64url decode the p2s")}return ce(e,t,a,r.p2c,c)}case"A128KW":case"A192KW":case"A256KW":if(void 0===a)throw new C("JWE Encrypted Key missing");return ae(e,t,a);case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{if(void 0===a)throw new C("JWE Encrypted Key missing");if("string"!=typeof r.iv)throw new C('JOSE Header "iv" (Initialization Vector) missing or invalid');if("string"!=typeof r.tag)throw new C('JOSE Header "tag" (Authentication Tag) missing or invalid');let i,n;try{i=K(r.iv)}catch{throw new C("Failed to base64url decode the iv")}try{n=K(r.tag)}catch{throw new C("Failed to base64url decode the tag")}return async function(e,t,a,r,i){const n=e.slice(0,7);return V(n,t,a,r,i,new Uint8Array(0))}(e,t,a,i,n)}default:throw new B('Invalid or unsupported "alg" (JWE Algorithm) header value')}}function ge(e,t,a,r,i){if(void 0!==i.crit&&void 0===r?.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!r||void 0===r.crit)return new Set;if(!Array.isArray(r.crit)||0===r.crit.length||r.crit.some((e=>"string"!=typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let n;n=void 0!==a?new Map([...Object.entries(a),...t.entries()]):t;for(const t of r.crit){if(!n.has(t))throw new B(`Extension Header Parameter "${t}" is not recognized`);if(void 0===i[t])throw new e(`Extension Header Parameter "${t}" is missing`);if(n.get(t)&&void 0===r[t])throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}return new Set(r.crit)}const me=(e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some((e=>"string"!=typeof e))))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};async function be(e,t,a){if(!Y(e))throw new C("Flattened JWE must be an object");if(void 0===e.protected&&void 0===e.header&&void 0===e.unprotected)throw new C("JOSE Header missing");if(void 0!==e.iv&&"string"!=typeof e.iv)throw new C("JWE Initialization Vector incorrect type");if("string"!=typeof e.ciphertext)throw new C("JWE Ciphertext missing or incorrect type");if(void 0!==e.tag&&"string"!=typeof e.tag)throw new C("JWE Authentication Tag incorrect type");if(void 0!==e.protected&&"string"!=typeof e.protected)throw new C("JWE Protected Header incorrect type");if(void 0!==e.encrypted_key&&"string"!=typeof e.encrypted_key)throw new C("JWE Encrypted Key incorrect type");if(void 0!==e.aad&&"string"!=typeof e.aad)throw new C("JWE AAD incorrect type");if(void 0!==e.header&&!Y(e.header))throw new C("JWE Shared Unprotected Header incorrect type");if(void 0!==e.unprotected&&!Y(e.unprotected))throw new C("JWE Per-Recipient Unprotected Header incorrect type");let r;if(e.protected)try{const t=K(e.protected);r=JSON.parse(g.decode(t))}catch{throw new C("JWE Protected Header is invalid")}if(!X(r,e.header,e.unprotected))throw new C("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");const i={...r,...e.header,...e.unprotected};if(ge(C,new Map,a?.crit,r,i),void 0!==i.zip)throw new B('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');const{alg:n,enc:c}=i;if("string"!=typeof n||!n)throw new C("missing JWE Algorithm (alg) in JWE Header");if("string"!=typeof c||!c)throw new C("missing JWE Encryption Algorithm (enc) in JWE Header");const o=a&&me("keyManagementAlgorithms",a.keyManagementAlgorithms),s=a&&me("contentEncryptionAlgorithms",a.contentEncryptionAlgorithms);if(o&&!o.has(n)||!o&&n.startsWith("PBES2"))throw new P('"alg" (Algorithm) Header Parameter value not allowed');if(s&&!s.has(c))throw new P('"enc" (Encryption Algorithm) Header Parameter value not allowed');let d;if(void 0!==e.encrypted_key)try{d=K(e.encrypted_key)}catch{throw new C("Failed to base64url decode the encrypted_key")}let y,p,l,u=!1;"function"==typeof t&&(t=await t(r,e),u=!0);try{y=await fe(n,t,d,i,a)}catch(e){if(e instanceof TypeError||e instanceof C||e instanceof B)throw e;y=pe(c)}if(void 0!==e.iv)try{p=K(e.iv)}catch{throw new C("Failed to base64url decode the iv")}if(void 0!==e.tag)try{l=K(e.tag)}catch{throw new C("Failed to base64url decode the tag")}const w=f.encode(e.protected??"");let h,m;h=void 0!==e.aad?b(w,f.encode("."),f.encode(e.aad)):w;try{m=K(e.ciphertext)}catch{throw new C("Failed to base64url decode the ciphertext")}const v={plaintext:await V(c,y,m,p,l,h)};if(void 0!==e.protected&&(v.protectedHeader=r),void 0!==e.aad)try{v.additionalAuthenticatedData=K(e.aad)}catch{throw new C("Failed to base64url decode the aad")}return void 0!==e.unprotected&&(v.sharedUnprotectedHeader=e.unprotected),void 0!==e.header&&(v.unprotectedHeader=e.header),u?{...v,key:t}:v}var ve=async e=>{if(e instanceof Uint8Array)return{kty:"oct",k:A(e)};if(!w(e))throw new TypeError(F(e,...z,"Uint8Array"));if(!e.extractable)throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");const{ext:t,key_ops:a,alg:r,use:i,...n}=await u.subtle.exportKey("jwk",e);return n};async function Ee(e){return ve(e)}async function Se(e,t,a,r,i={}){let n,c,o;switch(we(e,a,"encrypt"),e){case"dir":o=a;break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!ie(a))throw new B("ECDH with the provided key is not allowed or not supported by your javascript runtime");const{apu:s,apv:d}=i;let{epk:y}=i;y||(y=(await async function(e){if(!w(e))throw new TypeError(F(e,...z));return u.subtle.generateKey(e.algorithm,!0,["deriveBits"])}(a)).privateKey);const{x:p,y:l,crv:h,kty:f}=await Ee(y),g=await re(a,y,"ECDH-ES"===e?t:e,"ECDH-ES"===e?ye(t):parseInt(e.slice(-5,-2),10),s,d);if(c={epk:{x:p,crv:h,kty:f}},"EC"===f&&(c.epk.y=l),s&&(c.apu=A(s)),d&&(c.apv=A(d)),"ECDH-ES"===e){o=g;break}o=r||pe(t);const m=e.slice(-6);n=await te(m,g,o);break}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":o=r||pe(t),n=await(async(e,t,a)=>{if(!w(t))throw new TypeError(F(t,...z));if($(t,e,"encrypt","wrapKey"),se(e,t),t.usages.includes("encrypt"))return new Uint8Array(await u.subtle.encrypt(oe(e),t,a));if(t.usages.includes("wrapKey")){const r=await u.subtle.importKey("raw",a,...Z);return new Uint8Array(await u.subtle.wrapKey("raw",r,t,oe(e)))}throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation')})(e,a,o);break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{o=r||pe(t);const{p2c:s,p2s:d}=i;({encryptedKey:n,...c}=await(async(e,t,a,r=2048,i=U(new Uint8Array(16)))=>{const n=await ne(i,e,r,t);return{encryptedKey:await te(e.slice(-6),n,a),p2c:r,p2s:A(i)}})(e,a,o,s,d));break}case"A128KW":case"A192KW":case"A256KW":o=r||pe(t),n=await te(e,a,o);break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{o=r||pe(t);const{iv:s}=i;({encryptedKey:n,...c}=await async function(e,t,a,r){const i=e.slice(0,7),n=await he(i,a,t,r,new Uint8Array(0));return{encryptedKey:n.ciphertext,iv:A(n.iv),tag:A(n.tag)}}(e,a,o,s));break}default:throw new B('Invalid or unsupported "alg" (JWE Algorithm) header value')}return{cek:o,encryptedKey:n,parameters:c}}const xe=Symbol();class Ae{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("plaintext must be an instance of Uint8Array");this._plaintext=e}setKeyManagementParameters(e){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=e,this}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._sharedUnprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._sharedUnprotectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}setContentEncryptionKey(e){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=e,this}setInitializationVector(e){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=e,this}async encrypt(e,t){if(!this._protectedHeader&&!this._unprotectedHeader&&!this._sharedUnprotectedHeader)throw new C("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");if(!X(this._protectedHeader,this._unprotectedHeader,this._sharedUnprotectedHeader))throw new C("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const a={...this._protectedHeader,...this._unprotectedHeader,...this._sharedUnprotectedHeader};if(ge(C,new Map,t?.crit,this._protectedHeader,a),void 0!==a.zip)throw new B('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');const{alg:r,enc:i}=a;if("string"!=typeof r||!r)throw new C('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("string"!=typeof i||!i)throw new C('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');let n,c,o,s,d;if(this._cek&&("dir"===r||"ECDH-ES"===r))throw new TypeError(`setContentEncryptionKey cannot be called with JWE "alg" (Algorithm) Header ${r}`);{let a;({cek:c,encryptedKey:n,parameters:a}=await Se(r,i,e,this._cek,this._keyManagementParameters)),a&&(t&&xe in t?this._unprotectedHeader?this._unprotectedHeader={...this._unprotectedHeader,...a}:this.setUnprotectedHeader(a):this._protectedHeader?this._protectedHeader={...this._protectedHeader,...a}:this.setProtectedHeader(a))}s=this._protectedHeader?f.encode(A(JSON.stringify(this._protectedHeader))):f.encode(""),this._aad?(d=A(this._aad),o=b(s,f.encode("."),f.encode(d))):o=s;const{ciphertext:y,tag:p,iv:l}=await he(i,this._plaintext,c,this._iv,o),u={ciphertext:A(y)};return l&&(u.iv=A(l)),p&&(u.tag=A(p)),n&&(u.encrypted_key=A(n)),d&&(u.aad=d),this._protectedHeader&&(u.protected=g.decode(s)),this._sharedUnprotectedHeader&&(u.unprotected=this._sharedUnprotectedHeader),this._unprotectedHeader&&(u.header=this._unprotectedHeader),u}}class Ke{constructor(e,t,a){this.parent=e,this.key=t,this.options=a}setUnprotectedHeader(e){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=e,this}addRecipient(...e){return this.parent.addRecipient(...e)}encrypt(...e){return this.parent.encrypt(...e)}done(){return this.parent}}class He{constructor(e){this._recipients=[],this._plaintext=e}addRecipient(e,t){const a=new Ke(this,e,{crit:t?.crit});return this._recipients.push(a),a}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}async encrypt(){if(!this._recipients.length)throw new C("at least one recipient must be added");if(1===this._recipients.length){const[e]=this._recipients,t=await new Ae(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(e.unprotectedHeader).encrypt(e.key,{...e.options}),a={ciphertext:t.ciphertext,iv:t.iv,recipients:[{}],tag:t.tag};return t.aad&&(a.aad=t.aad),t.protected&&(a.protected=t.protected),t.unprotected&&(a.unprotected=t.unprotected),t.encrypted_key&&(a.recipients[0].encrypted_key=t.encrypted_key),t.header&&(a.recipients[0].header=t.header),a}let e;for(let t=0;t<this._recipients.length;t++){const a=this._recipients[t];if(!X(this._protectedHeader,this._unprotectedHeader,a.unprotectedHeader))throw new C("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const r={...this._protectedHeader,...this._unprotectedHeader,...a.unprotectedHeader},{alg:i}=r;if("string"!=typeof i||!i)throw new C('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("dir"===i||"ECDH-ES"===i)throw new C('"dir" and "ECDH-ES" alg may only be used with a single recipient');if("string"!=typeof r.enc||!r.enc)throw new C('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');if(e){if(e!==r.enc)throw new C('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients')}else e=r.enc;if(ge(C,new Map,a.options.crit,this._protectedHeader,r),void 0!==r.zip)throw new B('JWE "zip" (Compression Algorithm) Header Parameter is not supported.')}const t=pe(e),a={ciphertext:"",iv:"",recipients:[],tag:""};for(let r=0;r<this._recipients.length;r++){const i=this._recipients[r],n={};a.recipients.push(n);const c={...this._protectedHeader,...this._unprotectedHeader,...i.unprotectedHeader}.alg.startsWith("PBES2")?2048+r:void 0;if(0===r){const e=await new Ae(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(t).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(i.unprotectedHeader).setKeyManagementParameters({p2c:c}).encrypt(i.key,{...i.options,[xe]:!0});a.ciphertext=e.ciphertext,a.iv=e.iv,a.tag=e.tag,e.aad&&(a.aad=e.aad),e.protected&&(a.protected=e.protected),e.unprotected&&(a.unprotected=e.unprotected),n.encrypted_key=e.encrypted_key,e.header&&(n.header=e.header);continue}const{encryptedKey:o,parameters:s}=await Se(i.unprotectedHeader?.alg||this._protectedHeader?.alg||this._unprotectedHeader?.alg,e,i.key,t,{p2c:c});n.encrypted_key=A(o),(i.unprotectedHeader||s)&&(n.header={...i.unprotectedHeader,...s})}return a}}function Pe(e,t){const a=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:a,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:a,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:a,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:a,name:"ECDSA",namedCurve:t.namedCurve};case"EdDSA":return{name:t.name};default:throw new B(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}function Be(e,t,a){if(w(t))return I(t,e,a),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(F(t,...z));return u.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[a])}throw new TypeError(F(t,...z,"Uint8Array"))}const ke=async(e,t,a,r)=>{const i=await Be(e,t,"verify");se(e,i);const n=Pe(e,i.algorithm);try{return await u.subtle.verify(n,i,a,r)}catch{return!1}};async function Ce(e,t,a){if(!Y(e))throw new T("Flattened JWS must be an object");if(void 0===e.protected&&void 0===e.header)throw new T('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==e.protected&&"string"!=typeof e.protected)throw new T("JWS Protected Header incorrect type");if(void 0===e.payload)throw new T("JWS Payload missing");if("string"!=typeof e.signature)throw new T("JWS Signature missing or incorrect type");if(void 0!==e.header&&!Y(e.header))throw new T("JWS Unprotected Header incorrect type");let r={};if(e.protected)try{const t=K(e.protected);r=JSON.parse(g.decode(t))}catch{throw new T("JWS Protected Header is invalid")}if(!X(r,e.header))throw new T("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const i={...r,...e.header};let n=!0;if(ge(T,new Map([["b64",!0]]),a?.crit,r,i).has("b64")&&(n=r.b64,"boolean"!=typeof n))throw new T('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:c}=i;if("string"!=typeof c||!c)throw new T('JWS "alg" (Algorithm) Header Parameter missing or invalid');const o=a&&me("algorithms",a.algorithms);if(o&&!o.has(c))throw new P('"alg" (Algorithm) Header Parameter value not allowed');if(n){if("string"!=typeof e.payload)throw new T("JWS Payload must be a string")}else if("string"!=typeof e.payload&&!(e.payload instanceof Uint8Array))throw new T("JWS Payload must be a string or an Uint8Array instance");let s=!1;"function"==typeof t&&(t=await t(r,e),s=!0),we(c,t,"verify");const d=b(f.encode(e.protected??""),f.encode("."),"string"==typeof e.payload?f.encode(e.payload):e.payload);let y;try{y=K(e.signature)}catch{throw new T("Failed to base64url decode the signature")}if(!await ke(c,t,y,d))throw new W;let p;if(n)try{p=K(e.payload)}catch{throw new T("Failed to base64url decode the payload")}else p="string"==typeof e.payload?f.encode(e.payload):e.payload;const l={payload:p};return void 0!==e.protected&&(l.protectedHeader=r),void 0!==e.header&&(l.unprotectedHeader=e.header),s?{...l,key:t}:l}class Te{constructor(e){this._flattened=new Ae(e)}setContentEncryptionKey(e){return this._flattened.setContentEncryptionKey(e),this}setInitializationVector(e){return this._flattened.setInitializationVector(e),this}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}setKeyManagementParameters(e){return this._flattened.setKeyManagementParameters(e),this}async encrypt(e,t){const a=await this._flattened.encrypt(e,t);return[a.protected,a.encrypted_key,a.iv,a.ciphertext,a.tag].join(".")}}class We{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=e}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}async sign(e,t){if(!this._protectedHeader&&!this._unprotectedHeader)throw new T("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!X(this._protectedHeader,this._unprotectedHeader))throw new T("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const a={...this._protectedHeader,...this._unprotectedHeader};let r=!0;if(ge(T,new Map([["b64",!0]]),t?.crit,this._protectedHeader,a).has("b64")&&(r=this._protectedHeader.b64,"boolean"!=typeof r))throw new T('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:i}=a;if("string"!=typeof i||!i)throw new T('JWS "alg" (Algorithm) Header Parameter missing or invalid');we(i,e,"sign");let n,c=this._payload;r&&(c=f.encode(A(c))),n=this._protectedHeader?f.encode(A(JSON.stringify(this._protectedHeader))):f.encode("");const o=b(n,f.encode("."),c),s=await(async(e,t,a)=>{const r=await Be(e,t,"sign");se(e,r);const i=await u.subtle.sign(Pe(e,r.algorithm),r,a);return new Uint8Array(i)})(i,e,o),d={signature:A(s),payload:""};return r&&(d.payload=g.decode(c)),this._unprotectedHeader&&(d.header=this._unprotectedHeader),this._protectedHeader&&(d.protected=g.decode(n)),d}}class Ue{constructor(e){this._flattened=new We(e)}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}async sign(e,t){const a=await this._flattened.sign(e,t);if(void 0===a.payload)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${a.protected}.${a.payload}.${a.signature}`}}class _e{constructor(e,t,a){this.parent=e,this.key=t,this.options=a}setProtectedHeader(e){if(this.protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this.protectedHeader=e,this}setUnprotectedHeader(e){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=e,this}addSignature(...e){return this.parent.addSignature(...e)}sign(...e){return this.parent.sign(...e)}done(){return this.parent}}class Je{constructor(e){this._signatures=[],this._payload=e}addSignature(e,t){const a=new _e(this,e,t);return this._signatures.push(a),a}async sign(){if(!this._signatures.length)throw new T("at least one signature must be added");const e={signatures:[],payload:""};for(let t=0;t<this._signatures.length;t++){const a=this._signatures[t],r=new We(this._payload);r.setProtectedHeader(a.protectedHeader),r.setUnprotectedHeader(a.unprotectedHeader);const{payload:i,...n}=await r.sign(a.key,a.options);if(0===t)e.payload=i;else if(e.payload!==i)throw new T("inconsistent use of JWS Unencoded Payload (RFC7797)");e.signatures.push(n)}return e}}const Re=A,De=K;function je(e){const t=e?.modulusLength??2048;if("number"!=typeof t||t<2048)throw new B("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");return t}async function Oe(e,t){return async function(e,t){let a,r;switch(e){case"PS256":case"PS384":case"PS512":a={name:"RSA-PSS",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:je(t)},r=["sign","verify"];break;case"RS256":case"RS384":case"RS512":a={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:je(t)},r=["sign","verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":a={name:"RSA-OAEP",hash:`SHA-${parseInt(e.slice(-3),10)||1}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:je(t)},r=["decrypt","unwrapKey","encrypt","wrapKey"];break;case"ES256":a={name:"ECDSA",namedCurve:"P-256"},r=["sign","verify"];break;case"ES384":a={name:"ECDSA",namedCurve:"P-384"},r=["sign","verify"];break;case"ES512":a={name:"ECDSA",namedCurve:"P-521"},r=["sign","verify"];break;case"EdDSA":{r=["sign","verify"];const e=t?.crv??"Ed25519";switch(e){case"Ed25519":case"Ed448":a={name:e};break;default:throw new B("Invalid or unsupported crv option provided")}break}case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{r=["deriveKey","deriveBits"];const e=t?.crv??"P-256";switch(e){case"P-256":case"P-384":case"P-521":a={name:"ECDH",namedCurve:e};break;case"X25519":case"X448":a={name:e};break;default:throw new B("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448")}break}default:throw new B('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return u.subtle.generateKey(a,t?.extractable??!1,r)}(e,t)}async function Me(e,t){return async function(e,t){let a,r,i;switch(e){case"HS256":case"HS384":case"HS512":a=parseInt(e.slice(-3),10),r={name:"HMAC",hash:`SHA-${a}`,length:a},i=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return a=parseInt(e.slice(-3),10),U(new Uint8Array(a>>3));case"A128KW":case"A192KW":case"A256KW":a=parseInt(e.slice(1,4),10),r={name:"AES-KW",length:a},i=["wrapKey","unwrapKey"];break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":case"A128GCM":case"A192GCM":case"A256GCM":a=parseInt(e.slice(1,4),10),r={name:"AES-GCM",length:a},i=["encrypt","decrypt"];break;default:throw new B('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return u.subtle.generateKey(r,t?.extractable??!1,i)}(e,t)}const Ie="ECDSA",$e="P-384",Ge="ES384",Fe="SHA-256",Le="RSA-OAEP-256",Ne="AES-GCM",ze="A256GCM",qe="PBES2-HS512+A256KW",Ve=!0;const Xe={decodeProtectedHeader:function(e){let t;if("string"==typeof e){const a=e.split(".");3!==a.length&&5!==a.length||([t]=a)}else if("object"==typeof e&&e){if(!("protected"in e))throw new TypeError("Token does not contain a Protected Header");t=e.protected}try{if("string"!=typeof t||!t)throw new Error;const e=JSON.parse(g.decode(De(t)));if(!Y(e))throw new Error;return e}catch{throw new TypeError("Invalid Token or Protected Header formatting")}},isEmptyJWSPayload:e=>!e.split(".")[1],inputBuffer(e,t){if(ArrayBuffer.isView(e)&&!t.cty)return e;let a=t.cty||"";return a.includes("text")||"string"==typeof e?t.cty=a||"text/plain":(t.cty=a||"json",e=JSON.stringify(e)),(new TextEncoder).encode(e)},recoverDataFromContentType:(e,{cty:t=e?.protectedHeader?.cty}={})=>(e&&!Object.prototype.hasOwnProperty.call(e,"payload")&&(e.payload=e.plaintext),t&&e?.payload?(e.text=(new TextDecoder).decode(e.payload),t.includes("json")&&(e.json=JSON.parse(e.text)),e):e),generateSigningKey:()=>Oe(Ge,{extractable:Ve}),async sign(e,t,a={}){let r={alg:Ge,...a},i=this.inputBuffer(t,r);return new Ue(i).setProtectedHeader(r).sign(e)},async verify(e,t,a){let r=await async function(e,t,a){if(e instanceof Uint8Array&&(e=g.decode(e)),"string"!=typeof e)throw new T("Compact JWS must be a string or Uint8Array");const{0:r,1:i,2:n,length:c}=e.split(".");if(3!==c)throw new T("Invalid Compact JWS");const o=await Ce({payload:i,protected:r,signature:n},t,a),s={payload:o.payload,protectedHeader:o.protectedHeader};return"function"==typeof t?{...s,key:o.key}:s}(t,e).catch((()=>{}));return this.recoverDataFromContentType(r,a)},generateEncryptingKey:()=>Oe(Le,{extractable:Ve,modulusLength:4096}),async encrypt(e,t,a={}){let r={alg:this.isSymmetric(e)?"dir":Le,enc:ze,...a},i=this.inputBuffer(t,r),n=this.keySecret(e);return new Te(i).setProtectedHeader(r).encrypt(n)},async decrypt(e,t,a){let r=this.keySecret(e),i=await async function(e,t,a){if(e instanceof Uint8Array&&(e=g.decode(e)),"string"!=typeof e)throw new C("Compact JWE must be a string or Uint8Array");const{0:r,1:i,2:n,3:c,4:o,length:s}=e.split(".");if(5!==s)throw new C("Invalid Compact JWE");const d=await be({ciphertext:c,iv:n||void 0,protected:r,tag:o||void 0,encrypted_key:i||void 0},t,a),y={plaintext:d.plaintext,protectedHeader:d.protectedHeader};return"function"==typeof t?{...y,key:d.key}:y}(t,r);return this.recoverDataFromContentType(i,a),i},async generateSecretKey(e){let t=(new TextEncoder).encode(e),a=await function(e,t){return crypto.subtle.digest(e,t)}(Fe,t);return{type:"secret",text:new Uint8Array(a)}},generateSymmetricKey(e){return e?this.generateSecretKey(e):Me(ze,{extractable:Ve})},isSymmetric:e=>"secret"===e.type,keySecret:e=>e.text?e.text:e,async exportRaw(e){let t=await function(e){return crypto.subtle.exportKey("raw",e)}(e);return Re(new Uint8Array(t))},importRaw:async e=>function(e){const t={name:Ie,namedCurve:$e};return crypto.subtle.importKey("raw",e,t,Ve,["verify"])}(De(e)),async exportJWK(e){let t=await Ee(e),a=e.algorithm;if(a)a.name===Ie&&a.namedCurve===$e?t.alg=Ge:"RSA-OAEP"===a.name&&a.hash.name===Fe?t.alg=Le:a.name===Ne&&256===a.length&&(t.alg=ze);else switch(t.kty){case"EC":t.alg=Ge;break;case"RSA":t.alg=Le;break;case"oct":t.alg=ze}return t},async importJWK(e){e=Object.assign({ext:!0},e);let t=await ue(e);return t instanceof Uint8Array&&(t=await function(e){const t={name:Ne,length:256};return crypto.subtle.importKey("raw",e,t,!0,["encrypt","decrypt"])}(t)),t},async wrapKey(e,t){let a=await this.exportJWK(e);return this.encrypt(t,a)},async unwrapKey(e,t){let a=await this.decrypt(t,e);return this.importJWK(a.json)}};const Ye={isMultiKey:e=>"multi"===(e.type||"multi"),keyTags:e=>Object.keys(e).filter((e=>"type"!==e)),async exportJWK(e){if(!this.isMultiKey(e))return super.exportJWK(e);let t=this.keyTags(e),a=await Promise.all(t.map((async t=>{let a=await this.exportJWK(e[t]);return a.kid=t,a})));return{keys:a}},async importJWK(e){if(!e.keys)return super.importJWK(e);let t={};return await Promise.all(e.keys.map((async e=>t[e.kid]=await this.importJWK(e)))),t},async encrypt(e,t,a={}){if(!this.isMultiKey(e))return super.encrypt(e,t,a);let r=Object.assign({enc:ze},a),i=this.inputBuffer(t,r),n=new He(i).setProtectedHeader(r);for(let t of this.keyTags(e)){let a=e[t],r="string"==typeof a,i=r||this.isSymmetric(a),c=r?(new TextEncoder).encode(a):this.keySecret(a),o=r?qe:i?"A256GCMKW":Le;n.addRecipient(c).setUnprotectedHeader({kid:t,alg:o})}return await n.encrypt()},async decrypt(e,t,a){if(!this.isMultiKey(e))return super.decrypt(e,t,a);let r=t,{recipients:i}=r,n=i.map((async({header:t})=>{let{kid:a}=t,i=e[a],n={};if(!i)return Promise.reject("missing");"string"==typeof i&&(i=(new TextEncoder).encode(i),n.keyManagementAlgorithms=[qe]);let c=await async function(e,t,a){if(!Y(e))throw new C("General JWE must be an object");if(!Array.isArray(e.recipients)||!e.recipients.every(Y))throw new C("JWE Recipients missing or incorrect type");if(!e.recipients.length)throw new C("JWE Recipients has no members");for(const r of e.recipients)try{return await be({aad:e.aad,ciphertext:e.ciphertext,encrypted_key:r.encrypted_key,header:r.header,iv:e.iv,protected:e.protected,tag:e.tag,unprotected:e.unprotected},t,a)}catch{}throw new k}(r,this.keySecret(i),n),o=c.unprotectedHeader.kid;return o!==a?function(e,t){let a=`Key ${e} does not match encoded ${t}.`;return Promise.reject(a)}(a,o):c}));return await Promise.any(n).then((e=>(this.recoverDataFromContentType(e,a),e)),(()=>{}))},async sign(e,t,a={}){if(!this.isMultiKey(e))return super.sign(e,t,a);let r=this.inputBuffer(t,a),i=new Je(r);for(let t of this.keyTags(e)){let r=e[t],n=Object.assign({kid:t,alg:Ge},a);i.addSignature(r).setProtectedHeader(n)}return i.sign()},verifySubSignature(e,t,a,r){let i=t.protectedHeader??this.decodeProtectedHeader(t),n=t.unprotectedHeader,c=i?.kid||n?.kid,o=Object.assign({},e,{signatures:[t]}),s={protectedHeader:i,unprotectedHeader:n,kid:c},d=c?[c]:r,y=Promise.any(d.map((async e=>async function(e,t,a){if(!Y(e))throw new T("General JWS must be an object");if(!Array.isArray(e.signatures)||!e.signatures.every(Y))throw new T("JWS Signatures missing or incorrect type");for(const r of e.signatures)try{return await Ce({header:r.header,payload:e.payload,protected:r.protected,signature:r.signature},t,a)}catch{}throw new W}(o,a[e]).then((t=>Object.assign({kid:e},t))))));return y.catch((()=>s))},async verify(e,t,a={}){if(!this.isMultiKey(e))return super.verify(e,t,a);if(!t.signatures)return;let r=t,i=this.keyTags(e),n=await Promise.all(r.signatures.map((t=>this.verifySubSignature(r,t,e,i))));if(!n.find((e=>e.payload)))return;let[c,...o]=n,s={protectedHeader:{},unprotectedHeader:{},signers:n},d=e=>{let t=c[e],a=s[e];for(let r in t){let i=t[r];o.some((t=>t[e][r]!==i))||(a[r]=i)}};return d("protectedHeader"),d("protectedHeader"),s.payload=n.find((e=>e.payload)).payload,this.recoverDataFromContentType(s,a)}};Object.setPrototypeOf(Ye,Xe);class Ze{constructor({collectionName:e="collection",dbName:t="asyncLocalStorage"}={}){this.collectionName=e,this.dbName=t,this.version=1}get db(){return this._db??=new Promise((e=>{const t=indexedDB.open(this.dbName,this.version);t.onupgradeneeded=e=>e.target.result.createObjectStore(this.collectionName),this.result(e,t)}))}transaction(e="read"){const t=this.collectionName;return this.db.then((a=>a.transaction(t,e).objectStore(t)))}result(e,t){t.onsuccess=t=>e(t.target.result||"")}retrieve(e){return new Promise((t=>{this.transaction("readonly").then((a=>this.result(t,a.get(e))))}))}store(e,t){return new Promise((a=>{this.transaction("readwrite").then((r=>this.result(a,r.put(t,e))))}))}remove(e){return new Promise((t=>{this.transaction("readwrite").then((a=>this.result(t,a.delete(e))))}))}}function Qe(e,t,a=void 0){let r=e(t.slice(0,16)+"...");return Promise.reject(new Error(r,{cause:a}))}function et(e){return Qe((e=>`The tag ${e} is not available.`),e)}class tt{static keySets={};static cached(e){return this.keySets[e]}static clear(e=null){if(!e)return tt.keySets={};delete tt.keySets[e]}constructor(e){this.tag=e,this.memberTags=[],tt.keySets[e]=this}static async create(e){let{time:t,...a}=await this.createKeys(e),{tag:r}=a;return await this.persist(r,a,e,t),r}async destroy(e={}){let{tag:t,memberTags:a,signingKey:r}=this,i=await this.constructor.signForStorage({message:"",tag:t,memberTags:a,signingKey:r,time:Date.now()});await this.constructor.store("EncryptionKey",t,i),await this.constructor.store(this.constructor.collection,t,i),this.constructor.clear(t),e.recursiveMembers&&await Promise.allSettled(this.memberTags.map((async t=>{let a=await tt.ensure(t);await a.destroy(e)})))}decrypt(e,t){let{tag:a,decryptingKey:r}=this,i=e.recipients?{[a]:r}:r;return Ye.decrypt(i,e,t)}static async sign(e,{tags:t=[],team:a,member:r,time:i=a&&Date.now(),memberTags:n,signingKey:c,...o}){if(a&&!r){n||(n=(await tt.ensure(a)).memberTags),r=n.find((e=>this.cached(e)))||await Promise.any(n.map((e=>tt.ensure(e)))).then((e=>e.tag))}a&&!t.includes(a)&&(t=[a,...t]),r&&!t.includes(r)&&(t=[...t,r]);let s=await this.produceKey(t,(async e=>{let t=c||(await tt.ensure(e)).signingKey;return c=null,t}),o);return Ye.sign(s,e,{iss:a,act:r,iat:i,...o})}static async verify(e,t,a){a.team&&!t.includes(a.team)&&(t=[a.team,...t]);let r=!e.signatures,i=await this.produceKey(t,(e=>tt.verifyingKey(e)),a,r),n=await Ye.verify(i,e,a),c=void 0===a.member?n?.protectedHeader.act:a.member,o=a.notBefore;if(n){if(c){if("team"===a.member&&(c=n.protecteHeader.act,!c))return;if(!t.includes(c)){let r=await tt.verifyingKey(c),i={[c]:r};if(!await Ye.verify(i,e,a))return;t.push(c),n.signers.find((e=>e.protectedHeader.kid===c)).payload=n.payload}}if(c||"team"===o){let e=n.protectedHeader.iss||n.protectedHeader.kid,t=await this.retrieve(ot.collection,e),a=t?.json;if(c&&!e)return;if(c&&a&&!a.recipients.find((e=>e.header.kid===c)))return;"team"===o&&(o=t?.protectedHeader.iat)}if(o){let{iat:e}=n.protectedHeader;if(e<o)return}if((n.signers?.filter((e=>e.payload)).length||1)===t.length)return n}}static async produceKey(e,t,a,r=1===e.length){if(r){let r=e[0];return a.kid=r,t(r)}let i={},n=await Promise.all(e.map((e=>t(e))));return e.forEach(((e,t)=>i[e]=n[t])),i}static verifyingKey(e){return Ye.importRaw(e).catch((()=>et(e)))}static async encryptingKey(e){let t=await this.retrieve("EncryptionKey",e);return t?await Ye.importJWK(t.json):et(e)}static async createKeys(e){let{publicKey:t,privateKey:a}=await Ye.generateSigningKey(),{publicKey:r,privateKey:i}=await Ye.generateEncryptingKey(),n=await Ye.exportRaw(t),c=await Ye.exportJWK(r),o=Date.now(),s=await this.signForStorage({message:c,tag:n,signingKey:a,memberTags:e,time:o});return await this.store("EncryptionKey",n,s),{signingKey:a,decryptingKey:i,tag:n,time:o}}static getWrapped(e){return this.retrieve(this.collection,e)}static async ensure(e){let t=this.cached(e),a=await nt.getWrapped(e);return a?t=new nt(e):(a=await ot.getWrapped(e))?t=new ot(e):(a=await rt.getWrapped(e))&&(t=new rt(e)),t?.cached&&t.cached===a&&t.decryptingKey&&t.signingKey?t:a?(t.cached=a,t.unwrap(t.cached).then((e=>Object.assign(t,e)),(e=>(this.clear(t.tag),Qe((e=>`You do not have access to the private key for ${e}.`),t.tag,e))))):(this.clear(e),et(e))}static async persist(e,t,a,r=Date.now(),i=a){let{signingKey:n}=t,c=await this.wrap(t,a),o=await this.signForStorage({message:c,tag:e,signingKey:n,memberTags:i,time:r});await this.store(this.collection,e,o)}static async store(e,t,a){return e===nt.collection?Ye.isEmptyJWSPayload(a)?ct.remove(t):ct.store(t,a):tt.Storage.store(e,t,a)}static async retrieve(e,t){let a=e===nt.collection?ct.retrieve(t):tt.Storage.retrieve(e,t),r=await a,i=r&&await tt.verifyingKey(t);if(r)return r.signatures&&(i={[t]:i}),await Ye.verify(i,r)}}class at extends tt{static signForStorage({message:e,tag:t,signingKey:a,time:r}){return this.sign(e,{tags:[t],signingKey:a,time:r})}static async wrap(e,t=""){if(t.includes(Ye.concatChar))return Promise.reject("Cannot create recovery tag with a prompt that contains '~'.");let{decryptingKey:a,signingKey:r,tag:i}=e,n={decryptingKey:a,signingKey:r},c={[t]:await this.getSecret(i,t)};return Ye.wrapKey(n,c)}async unwrap(e){let t=e.json.recipients[0].header.kid,a={[t]:await this.constructor.getSecret(this.tag,t)},r=(await Ye.decrypt(a,e.json)).json;return await Ye.importJWK(r,{decryptingKey:"decrypt",signingKey:"sign"})}static async getSecret(e,t){return tt.getUserDeviceSecret(e,t)}}class rt extends at{static collection="KeyRecovery"}class nt extends at{static collection="Device"}const ct=new Ze({collectionName:nt.collection});class ot extends tt{static collection="Team";static signForStorage({message:e,tag:t,...a}){return this.sign(e,{team:t,...a})}static async wrap(e,t){let{decryptingKey:a,signingKey:r}=e,i={decryptingKey:a,signingKey:r},n={};return await Promise.all(t.map((e=>tt.encryptingKey(e).then((t=>n[e]=t))))),await Ye.wrapKey(i,n)}async unwrap(e){let{recipients:t}=e.json,a=this.memberTags=t.map((e=>e.header.kid)),r=await Promise.all(a.map((e=>rt.getWrapped(e).catch((()=>null))))),i=a.filter(((e,t)=>r[t])),n=a.filter((e=>!i.includes(e))),c=await Promise.any(n.map((e=>tt.ensure(e)))).catch((async e=>{for(let e of i){let t=await tt.ensure(e).catch((()=>null));if(t)return t}return e})),o=await c.decrypt(e.json);return await Ye.importJWK(o.json)}async changeMembership({add:e=[],remove:t=[]}={}){let{memberTags:a}=this,r=a.concat(e).filter((e=>!t.includes(e)));await this.constructor.persist(this.tag,this,r,Date.now(),a),this.memberTags=r}}var st={name:"@kilroy-code/distributed-security",version:"0.0.3",description:"Signed and encrypted document infrastructure based on public key encryption and self-organizing users.",type:"module",exports:{node:"./lib/api.mjs",default:"./index.mjs"},imports:{"#raw":{node:"./lib/raw-node.mjs",default:"./lib/raw-browser.mjs"},"#localStore":{node:"./lib/store-fs.mjs",default:"./lib/store-indexed.mjs"},"#internals":{node:"./spec/support/internals.mjs",default:"./spec/support/internal-browser-bundle.mjs"}},scripts:{build:"rollup -c",test:"jasmine"},repository:{type:"git",url:"git+https://github.com/kilroy-code/distributed-security.git"},keywords:["encryption","pki","dao"],author:{name:"Howard Stearns",email:"howard@ki1r0y.com"},license:"MIT",bugs:{url:"https://github.com/kilroy-code/distributed-security/issues"},homepage:"https://github.com/kilroy-code/distributed-security#readme",devDependencies:{"@rollup/plugin-commonjs":"^25.0.7","@rollup/plugin-eslint":"^9.0.5","@rollup/plugin-node-resolve":"^15.2.3","@rollup/plugin-terser":"^0.4.4","@rollup/plugin-json":"^6.1.0",eslint:"^8.57.0",jasmine:"^4.5.0","jsonc-eslint-parser":"^2.4.0",rollup:"^4.13.0"},dependencies:{"@kilroy-code/jsonrpc":"^0.0.1",jose:"^5.2.3"}};const{name:dt,version:yt}=st,pt={set Storage(e){tt.Storage=e},set getUserDeviceSecret(e){tt.getUserDeviceSecret=e},ready:{name:dt,version:yt},async encrypt(e,...t){let a={},r=this.canonicalizeParameters(t,a),i=await tt.produceKey(r,(e=>tt.encryptingKey(e)),a);return Ye.encrypt(i,e,a)},async decrypt(e,...t){let a={},[r]=this.canonicalizeParameters(t,a,e);return(await tt.ensure(r)).decrypt(e,a)},async sign(e,...t){let a={},r=this.canonicalizeParameters(t,a);return tt.sign(e,{tags:r,...a})},async verify(e,...t){let a={},r=this.canonicalizeParameters(t,a,e);return tt.verify(e,r,a)},async create(...e){if(!e.length)return await nt.create([]);let t=e[0].prompt;return t?await rt.create(t):await ot.create(e)},changeMembership:async({tag:e,...t})=>(await tt.ensure(e)).changeMembership(t),async destroy(e){"string"==typeof e&&(e={tag:e});let{tag:t,...a}=e;return(await tt.ensure(t)).destroy(a)},clear(e){tt.clear(e)},decodeProtectedHeader:Ye.decodeProtectedHeader,canonicalizeParameters(e,t,a){if(e.length>1)return e;let{tags:r=[],contentType:i,time:n,...c}=e[0]||{},{team:o}=c;if(!r.length)if(e.length&&e[0].length)r=e;else if(a)if(a.signatures)r=a.signatures.map((e=>this.decodeProtectedHeader(e).kid));else if(a.recipients)r=a.recipients.map((e=>e.header.kid));else try{let e=this.decodeProtectedHeader(a).kid;e&&(r=[e])}catch(t){console.error("failure with",{rest:e,token:a,team:o,tags:r,e:t})}return o&&!r.includes(o)&&(r=[o,...r]),i&&(t.cty=i),n&&(t.iat=n),Object.assign(t,c),r}};e.Security=n,n.Storage=e;let lt="secret",ut=lt;async function wt(e){ut="other",await e(),ut=lt}function ht(e,t=""){return t+ut}n.getUserDeviceSecret=ht,pt.Storage=e,pt.getUserDeviceSecret=ht,"undefined"!=typeof window&&Object.assign(window,{Security:n,Krypto:Xe,MultiKrypto:Ye}),describe("Distributed Security",(function(){let t=s();describe("Krypto",(function(){l(Xe)})),describe("MultiKrypto",(function(){!function(e){const t=2e4,a=s();describe("falls through to krypto with single keys",(function(){l(e,o)})),describe("multi-way keys",(function(){describe("multi-signature",(function(){let t,r;beforeAll((async function(){t=await e.generateSigningKey(),r=await e.generateSigningKey()})),it("is a multi-signature.",(async function(){let i={a:t.privateKey,b:r.privateKey},n={b:r.publicKey,a:t.publicKey},c=await e.sign(i,a),o=await e.verify(n,c);expect(o).toBeTruthy()})),it('can specify type:"multi" in the signing key for clarify.',(async function(){let i={a:t.privateKey,b:r.privateKey,type:"multi"},n={a:t.publicKey,b:r.publicKey},c=await e.sign(i,a),o=await e.verify(n,c);expect(o).toBeTruthy()})),it('can specify type:"multi" in the verifying key for clarify.',(async function(){let i={a:t.privateKey,b:r.privateKey},n={a:t.publicKey,b:r.publicKey,type:"multi"},c=await e.sign(i,a),o=await e.verify(n,c);expect(o).toBeTruthy()})),it("can specify iss, act, iat in the key, which will appear in the signature.",(async function(){let i=Date.now(),n={a:t.privateKey,b:r.privateKey},c={a:t.publicKey,b:r.publicKey},o=await e.sign(n,a,{iss:"a",act:"b",iat:i}),s=await e.verify(c,o);expect(s).toBeTruthy(),o.signatures.forEach((t=>{let a=e.decodeProtectedHeader(t);expect(a.iss).toBe("a"),expect(a.act).toBe("b"),expect(a.iat).toBe(i)}))})),it("can sign binary and it is recovery as binary from payload property of verfication.",(async function(){let a=new Uint8Array([1],[2],[3]),i=await e.sign({a:t.privateKey,b:r.privateKey},a),n=await e.verify({a:t.publicKey,b:r.publicKey},i);expect(n.payload).toEqual(a)})),it("can sign string type and it is recoverable as string from text property of verification.",(async function(){let a="a string",i=await e.sign({a:t.privateKey,b:r.privateKey},a),n=await e.verify({a:t.publicKey,b:r.publicKey},i);expect(n.text).toEqual(a),expect(n.payload).toEqual((new TextEncoder).encode(a))})),it("can sign a jsonable object and it is recovery as same from json property of result.",(async function(){let a={foo:"a string",bar:!1,baz:["a",2,null]},i=await e.sign({a:t.privateKey,b:r.privateKey},a),n=await e.verify({a:t.publicKey,b:r.publicKey},i);expect(n.json).toEqual(a),expect(n.payload).toEqual((new TextEncoder).encode(JSON.stringify(a)))})),it("can specify a specific cty that will pass through to verify.",(async function(){let a={foo:"a string",bar:!1,baz:["a",2,null]},i="application/foo+json",n=await e.sign({a:t.privateKey,b:r.privateKey},a,{cty:i}),c=await e.verify({a:t.publicKey,b:r.publicKey},n);expect(c.json).toEqual(a),expect(c.protectedHeader.cty).toBe(i),expect(c.payload).toEqual((new TextEncoder).encode(JSON.stringify(a)))})),it("fails verification if the signature is mislabeled.",(async function(){let i={a:r.privateKey,b:t.privateKey},n={a:t.publicKey,b:r.publicKey},c=await e.sign(i,a),o=await e.verify(n,c);expect(o).toBeUndefined()})),it("gives enough information that we can tell if a verifying sub key is missing.",(async function(){let i={a:t.privateKey,b:r.privateKey},n={b:r.publicKey},c=await e.sign(i,a),o=await e.verify(n,c);expect(o.payload).toBeTruthy(),expect(o.text).toBe(a),expect(o.signers[1].payload).toBeTruthy(),expect(o.signers[0].payload).toBeUndefined()})),it("gives enough information that we can tell if a signature sub key is missing.",(async function(){let i={a:t.privateKey},n={a:t.publicKey,b:r.publicKey},c=await e.sign(i,a),o=await e.verify(n,c);expect(o.payload).toBeTruthy(),expect(o.text).toBe(a),expect(o.signers.length).toBe(1),expect(o.signers[0].protectedHeader.kid).toBe("a"),expect(o.signers[0].payload).toBeTruthy()}))})),describe("multi-way encryption",(function(){let r,i,n,c,o,s,d="shh!";beforeAll((async function(){n=await e.generateSymmetricKey(),i=await e.generateEncryptingKey(),r=await e.encrypt({a:n,b:i.publicKey,c:d},a),c=r.recipients;let t=await e.generateEncryptingKey();o={a:i.publicKey,b:t.publicKey},s={a:i.privateKey,b:t.privateKey}}),t),it("works with symmetric members.",(async function(){let t=await e.decrypt({a:n},r);expect(t.text).toBe(a),expect(c[0].header.kid).toBe("a"),expect(c[0].header.alg).toBe("A256GCMKW")})),it("works with keypair members.",(async function(){let t=await e.decrypt({b:i.privateKey},r);expect(t.text).toBe(a),expect(c[1].header.kid).toBe("b"),expect(c[1].header.alg).toBe("RSA-OAEP-256")})),it("works with secret text members.",(async function(){let t=await e.decrypt({c:d},r);expect(t.text).toBe(a),expect(c[2].header.kid).toBe("c"),expect(c[2].header.alg).toBe("PBES2-HS512+A256KW")})),it("handles binary, and decrypts as same.",(async function(){let t=new Uint8Array([21,31]),a=await e.encrypt(o,t),r=await e.decrypt(s,a),i=e.decodeProtectedHeader(a);expect(i.cty).toBeUndefined(),p(r,t)})),it("handles text, and decrypts as same.",(async function(){let t=await e.encrypt(o,a),r=await e.decrypt(s,t),i=e.decodeProtectedHeader(t);expect(i.cty).toBe("text/plain"),expect(r.text).toBe(a)})),it("handles json, and decrypts as same.",(async function(){let t={foo:"bar"},a=await e.encrypt(o,t),r=e.decodeProtectedHeader(a),i=await e.decrypt(s,a);expect(r.cty).toBe("json"),expect(i.json).toEqual(t)})),it("Uses specified headers if supplied, including cty.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await e.encrypt(o,r,{cty:t,iat:a,foo:17}),n=await e.decrypt(s,i),c=e.decodeProtectedHeader(i);expect(c.cty).toBe(t),expect(c.iat).toBe(a),expect(c.foo).toBe(17),expect(n.text).toBe(r)})),it("produces undefined for wrong symmetric key.",(async function(){let t=await e.generateSymmetricKey(),a=await e.decrypt({a:t},r);expect(a).toBeUndefined()})),it("produces undefined for wrong keypair.",(async function(){let t=await e.generateEncryptingKey(),a=await e.decrypt({b:t.privateKey},r);expect(a).toBeUndefined()})),it("produces undefined for wrong secret text.",(async function(){let t=await e.decrypt({c:"shh! "},r);expect(t).toBeUndefined()})),it("produces undefined for mislabeled key.",(async function(){let t=await e.decrypt({a:d},r);expect(t).toBeUndefined()}))}))})),describe("export/wrap",(function(){let r,i;beforeAll((async function(){let t=await e.generateEncryptingKey(),a=await e.generateEncryptingKey(),n=await e.generateEncryptingKey();r={a:t.publicKey,b:a.publicKey},i={c:n.privateKey,b:a.privateKey}}),t),it("exports homogenous member.",(async function(){let t=await e.exportJWK(r),n=await e.importJWK(t),c=await e.encrypt(n,a),o=await e.decrypt(i,c);expect(t.keys[0].kid).toBe("a"),expect(t.keys[1].kid).toBe("b"),expect(o.text).toBe(a)})),it("export heterogenous members.",(async function(){let t=await e.generateEncryptingKey(),a=await e.generateSigningKey(),r=await e.exportJWK({myDecrypt:t.privateKey,mySign:a.privateKey}),i=await e.importJWK(r),n="a smaller message for asymmetric encryption",c=await e.encrypt(t.publicKey,n),o=await e.decrypt(i.myDecrypt,c),s=await e.sign(i.mySign,n);expect(r.keys[0].kid).toBe("myDecrypt"),expect(r.keys[1].kid).toBe("mySign"),expect(o.text).toBe(n),expect(await e.verify(a.publicKey,s)).toBeTruthy()})),it("can wrap/unwrap a simple key.",(async function(){let t=await e.generateSymmetricKey(),n=await e.wrapKey(t,r),c=await e.unwrapKey(n,i),o=await e.encrypt(c,a),s=await e.decrypt(t,o);expect(s.text).toBe(a)})),it("can be wrapped/unwrapped by a symmetric key with homogenous members.",(async function(){let t=await e.generateSymmetricKey(),n=await e.wrapKey(r,t),c=await e.unwrapKey(n,t),o=await e.encrypt(c,a),s=await e.decrypt(i,o);expect(s.text).toBe(a)})),it("can wrap/unwrap a symmetric multikey with homogenous members.",(async function(){let t={x:await e.generateSymmetricKey(),y:await e.generateSymmetricKey()},a=await e.wrapKey(t,r),n=await e.unwrapKey(a,i),c=s(),o=await e.encrypt(n,c),d=await e.decrypt(t,o);expect(d.text).toBe(c)})),it("can wrap/unwrap a heterogeneous multikey.",(async function(){let t=await e.generateEncryptingKey(),a=await e.generateSigningKey(),n=await e.wrapKey({myDecrypt:t.privateKey,mySign:a.privateKey},r),c=await e.unwrapKey(n,i),o="a shorter message",s=await e.encrypt(t.publicKey,o),d=await e.decrypt(c.myDecrypt,s),y=await e.sign(c.mySign,o);expect(d.text).toBe(o),expect(await e.verify(a.publicKey,y)).toBeTruthy()}),t)}))}(Ye)})),describe("Security",(function(){const a=25e3;async function r(e){let t,a,r={},[i,n,c]=await Promise.all([e.create(),e.create({prompt:"what?"}),e.create({prompt:"nope!"})]);await wt((async function(){t=await e.create(),a=await e.create(t)}));let o=await e.create(i),[s,d]=await Promise.all([e.create(o,a),e.create(a,o)]);return r.device=i,r.otherDevice=t,r.recovery=n,r.otherRecovery=c,r.user=o,r.otherUser=a,r.team=s,r.otherTeam=d,r}async function i(e,t){await e.destroy(t.otherTeam),await e.destroy(t.team),await e.destroy(t.user),await e.destroy(t.device),await e.destroy(t.recovery),await e.destroy(t.otherRecovery),await wt((async function(){await e.destroy(t.otherUser),await e.destroy(t.otherDevice)}))}describe("internal machinery",(function(){let c;function o(a,r){describe(a,(function(){let a,i;beforeAll((async function(){i=c[r],a=await tt.ensure(i)})),it("tag is exported verify key, and sign() pairs with it.",(async function(){let e=await Ye.importRaw(i),a=await Ye.exportRaw(e);expect(typeof i).toBe("string"),expect(a).toBe(i);let r=await tt.ensure(i),n=await tt.sign(t,{tags:[i],signingKey:r.signingKey}),c=await Ye.verify(e,n);y(n),expect(c).toBeTruthy()})),it("public encryption tag can be retrieved externally, and vault.decrypt() pairs with it.",(async function(){let r=a.tag,i=await e.retrieve("EncryptionKey",r),c=await n.verify(i,r),o=await Ye.importJWK(c.json),s=await Ye.encrypt(o,t),d=await a.decrypt(s);expect(d.text).toBe(t)}))}))}beforeAll((async function(){c=await r(pt)}),a),afterAll((async function(){await i(pt,c)}),a),o("DeviceKeySet","device"),o("RecoveryKeySet","recovery"),o("TeamKeySet","user"),describe("local store",(function(){var e;beforeAll((async function(){e=new Ze({dbName:"testStore",collectionName:"Foo"}),await new Promise((e=>setTimeout(e,2e3)))})),it("can remove without existing.",(async function(){expect(await e.remove("nonExistant")).toBe("")})),it("can retrieve without existing.",(async function(){expect(await e.retrieve("nonExistant")).toBe("")})),it("retrieves and can remove what is stored.",(async function(){let t="x",a="hello";expect(await e.store(t,a)).not.toBeUndefined(),expect(await e.retrieve(t)).toBe(a),expect(await e.remove(t)).toBe(""),expect(await e.retrieve(t)).toBe("")})),it("can write a lot without getting jumbled.",(async function(){let t,a,r,i=1e3,n=[];for(let e=0;e<i;e++)n.push("y"+e);t=Date.now();let c=await Promise.all(n.map(((t,a)=>e.store(t,a.toString()))));a=Date.now()-t,r=a/i,expect(r).toBeLessThan(5),c.forEach((e=>expect(e).not.toBeUndefined())),t=Date.now();let o=await Promise.all(n.map((t=>e.retrieve(t))));a=Date.now()-t,r=a/i,expect(r).toBeLessThan(3),o.forEach(((e,t)=>expect(e).toBe(t.toString()))),t=Date.now();let s=await Promise.all(n.map((t=>e.remove(t))));a=Date.now()-t,r=a/i,expect(r).toBeLessThan(5),s.forEach((e=>expect(e).toBe(""))),t=Date.now();let d=await Promise.all(n.map((t=>e.retrieve(t))));a=Date.now()-t,r=a/i,expect(r).toBeLessThan(.1),d.forEach((e=>expect(e).toBe("")))}),1e6)}))})),describe("API",(function(){let e;function c(a,r,i,c){describe(a,(function(){let a,o;beforeAll((function(){a=e[r],o=e[i]})),describe("signature",(function(){describe("of one tag",(function(){it("can sign and be verified.",(async function(){let e=await n.sign(t,a);y(e),expect(await n.verify(e,a)).toBeTruthy()})),it("can be verified with the tag included in the signature.",(async function(){let e=await n.sign(t,a);expect(await n.verify(e)).toBeTruthy()})),it("cannot sign for a different key.",(async function(){let e=await n.sign(t,o);expect(await n.verify(e,a)).toBeUndefined()})),it("distinguishes between correctly signing false and key failure.",(async function(){let e=await n.sign(!1,a),t=await n.verify(e,a);expect(t.json).toBe(!1)})),it("can sign text and produce verified result with text property.",(async function(){let e=await n.sign(t,a),r=await n.verify(e,a);y(e),expect(r.text).toBe(t)})),it("can sign json and produce verified result with json property.",(async function(){let e={x:1,y:["abc",null,!1]},t=await n.sign(e,a),r=await n.verify(t,a);y(t),expect(r.json).toEqual(e)})),it("can sign binary and produce verified result with payload property.",(async function(){let e=new Uint8Array([1,2,3]),t=await n.sign(e,a),r=await n.verify(t,a);y(t),expect(r.payload).toEqual(e)})),it("uses contentType and time if supplied.",(async function(){let e="text/html",t=Date.now(),r="<something else>",i=await n.sign(r,{tags:[a],contentType:e,time:t}),c=await n.verify(i,a);y(i),expect(c.text).toEqual(r),expect(c.protectedHeader.cty).toBe(e),expect(c.protectedHeader.iat).toBe(t)}))})),describe("of multiple tags",(function(){it("can sign and be verified.",(async function(){let e=await n.sign(t,a,o),r=await n.verify(e,o,a);expect(r).toBeTruthy(),expect(r.signers[0].payload).toBeTruthy(),expect(r.signers[1].payload).toBeTruthy()})),it("does not attempt to verify unenumerated tags if any are explicit",(async function(){let e=await n.sign(t,a,o),r=await n.verify(e,o);expect(r).toBeTruthy(),expect(r.signers[0].payload).toBeFalsy(),expect(r.signers[1].payload).toBeTruthy()})),it("can be verified with the tag included in the signature.",(async function(){let e=await n.sign(t,a,o),r=await n.verify(e);expect(r).toBeTruthy(),expect(r.signers[0].payload).toBeTruthy(),expect(r.signers[1].payload).toBeTruthy()})),describe("bad verification",(function(){let e;beforeAll((async function(){e=await n.create()})),afterAll((async function(){await n.destroy(e)})),describe("when mixing single and multi-tags",(function(){it("fails with extra signing tag.",(async function(){let e=await n.sign(t,o);expect(await n.verify(e,a)).toBeUndefined()})),it("fails with extra verifying.",(async function(){let e=await n.sign(t,a);expect(await n.verify(e,a,o)).toBeUndefined()}))})),describe("when mixing multi-tag lengths",(function(){it("fails with mismatched signing tag.",(async function(){let r=await n.sign(t,o,e),i=await n.verify(r,a,e);expect(i).toBeUndefined()})),it("fails with extra verifying tag.",(async function(){let r=await n.sign(t,a,e);expect(await n.verify(r,a,o,e)).toBeUndefined()}))}))})),it("distinguishes between correctly signing false and key failure.",(async function(){let e=await n.sign(!1,a,o),t=await n.verify(e,a,o);expect(t.json).toBe(!1)})),it("can sign text and produce verified result with text property.",(async function(){let e=await n.sign(t,a,o),r=await n.verify(e,a,o);expect(r.text).toBe(t)})),it("can sign json and produce verified result with json property.",(async function(){let e={x:1,y:["abc",null,!1]},t=await n.sign(e,a,o),r=await n.verify(t,a,o);expect(r.json).toEqual(e)})),it("can sign binary and produce verified result with payload property.",(async function(){let e=new Uint8Array([1,2,3]),t=await n.sign(e,a,o),r=await n.verify(t,a,o);expect(r.payload).toEqual(e)})),it("uses contentType and time if supplied.",(async function(){let e="text/html",t=Date.now(),r="<something else>",i=await n.sign(r,{tags:[a,o],contentType:e,time:t}),c=await n.verify(i,a,o);expect(c.text).toEqual(r),expect(c.protectedHeader.cty).toBe(e),expect(c.protectedHeader.iat).toBe(t)}))}))})),describe("encryption",(function(){describe("with a single tag",(function(){it("can decrypt what is encrypted for it.",(async function(){let e=await n.encrypt(t,a),r=await n.decrypt(e,a);y(e),expect(r.text).toBe(t)})),it("can be decrypted using the tag included in the encryption.",(async function(){let e=await n.encrypt(t,a),r=await n.decrypt(e);expect(r.text).toBe(t)})),it("is url-safe base64.",(async function(){y(await n.encrypt(t,a))})),it("specifies kid.",(async function(){let e=Xe.decodeProtectedHeader(await n.encrypt(t,a));expect(e.kid).toBe(a)})),it("cannot decrypt what is encrypted for a different key.",(async function(){let e=s(446),t=await n.encrypt(e,o),r=await n.decrypt(t,a).catch((e=>e.message));expect(r.toLowerCase()).toContain("operation")})),it("handles binary, and decrypts as same.",(async function(){let e=new Uint8Array([21,31]),t=await n.encrypt(e,a),r=await n.decrypt(t,a),i=Xe.decodeProtectedHeader(t);expect(i.cty).toBeUndefined(),p(r,e)})),it("handles text, and decrypts as same.",(async function(){let e=await n.encrypt(t,a),r=await n.decrypt(e,a),i=Xe.decodeProtectedHeader(e);expect(i.cty).toBe("text/plain"),expect(r.text).toBe(t)})),it("handles json, and decrypts as same.",(async function(){let e={foo:"bar"},t=await n.encrypt(e,a),r=await n.decrypt(t,a),i=Xe.decodeProtectedHeader(t);expect(i.cty).toBe("json"),expect(r.json).toEqual(e)})),it("uses contentType and time if supplied.",(async function(){let e="text/html",t=Date.now(),r="<something else>",i=await n.encrypt(r,{tags:[a],contentType:e,time:t}),c=await n.decrypt(i,a),o=Xe.decodeProtectedHeader(i);expect(o.cty).toBe(e),expect(o.iat).toBe(t),expect(c.text).toBe(r)}))})),describe("with multiple tags",(function(){it("can be decrypted by any one of them.",(async function(){let e=await n.encrypt(t,a,o),r=await n.decrypt(e,a),i=await n.decrypt(e,o);expect(r.text).toBe(t),expect(i.text).toBe(t)})),it("can be decrypted using the tag included in the encryption.",(async function(){let e=await n.encrypt(t,a,o),r=await n.decrypt(e);expect(r.text).toBe(t)})),it("can be be made with tags you do not own.",(async function(){let r=await n.encrypt(t,a,e[c],o),i=await n.decrypt(r,a),s=await n.decrypt(r,o);expect(i.text).toBe(t),expect(s.text).toBe(t)})),it("cannot be decrypted by a different tag.",(async function(){let r=await n.encrypt(t,a,e[c]),i=await n.decrypt(r,o);expect(i).toBeUndefined()})),it("specifies kid in each recipient.",(async function(){let e=(await n.encrypt(t,a,o)).recipients;expect(e.length).toBe(2),expect(e[0].header.kid).toBe(a),expect(e[1].header.kid).toBe(o)})),it("handles binary, and decrypts as same.",(async function(){let e=new Uint8Array([21,31]),t=await n.encrypt(e,a,o),r=await n.decrypt(t,a),i=Xe.decodeProtectedHeader(t);expect(i.cty).toBeUndefined(),p(r,e)})),it("handles text, and decrypts as same.",(async function(){let e=await n.encrypt(t,a,o),r=await n.decrypt(e,a),i=Xe.decodeProtectedHeader(e);expect(i.cty).toBe("text/plain"),expect(r.text).toBe(t)})),it("handles json, and decrypts as same.",(async function(){let e={foo:"bar"},t=await n.encrypt(e,a,o),r=await n.decrypt(t,a),i=Xe.decodeProtectedHeader(t);expect(i.cty).toBe("json"),expect(r.json).toEqual(e)})),it("uses contentType and time if supplied.",(async function(){let e="text/html",t=Date.now(),r="<something else>",i=await n.encrypt(r,{tags:[a,o],contentType:e,time:t}),c=await n.decrypt(i,a),s=Xe.decodeProtectedHeader(i);expect(s.cty).toBe(e),expect(s.iat).toBe(t),expect(c.text).toBe(r)}))}))}))}))}beforeAll((async function(){console.log(await n.ready),e=await r(n)}),a),afterAll((async function(){await i(n,e)}),a),c("DeviceKeySet","device","user","otherDevice"),c("RecoveryKeySet","recovery","otherRecovery","otherDevice"),c("User TeamKeySet","user","device","otherUser"),c("Team TeamKeySet","team","otherTeam","otherUser"),describe("auditable signatures",(function(){describe("by an explicit member",(function(){let a,r;beforeAll((async function(){a=await n.sign(t,{team:e.team,member:e.user}),r=await n.verify(a,e.team,e.user)})),it("recognizes a team with a member.",(async function(){expect(r).toBeTruthy(),expect(r.text).toBe(t)})),it("defines iss.",(function(){expect(r.protectedHeader.iss).toBe(e.team)})),it("defines act.",(function(){expect(r.protectedHeader.act).toBe(e.user)}))})),describe("automatically supplies a valid member",(function(){it("if you have access",(async function(){let a=await n.sign(t,{team:e.team}),r=Xe.decodeProtectedHeader(a.signatures[0]).act,i=await n.verify(a,e.team,r);expect(i).toBeTruthy(),expect(r).toBeTruthy(),expect(i.protectedHeader.act).toBe(r),expect(i.protectedHeader.iat).toBeTruthy()}))})),describe("with a valid user who is not a member",(function(){let a;beforeAll((async function(){a=await n.create(e.device)})),afterAll((async function(){await n.destroy(a)})),it("verifies as an ordinary dual signature.",(async function(){let r=await n.sign(t,e.team,a),i=await n.verify(r,e.team,a);expect(i.text).toBe(t),expect(i.protectedHeader.iss).toBeUndefined(),expect(i.protectedHeader.act).toBeUndefined()}),1e4),it("does not verify as a dual signature specifying team and member.",(async function(){let r=await n.sign(t,{team:e.team,member:a}),i=await n.verify(r,e.team,a);expect(i).toBeUndefined()}))})),describe("with a past member",(function(){let t,a,r;beforeAll((async function(){r=Date.now()-1,t=await n.create(),await n.changeMembership({tag:e.team,add:[t]}),a=await n.sign("message",{team:e.team,member:t,time:r}),await n.changeMembership({tag:e.team,remove:[t]})})),afterAll((async function(){await n.destroy(t)})),it("fails by default.",(async function(){let e=await n.verify(a,t);expect(e).toBeUndefined()})),it("contains act in signature but verifies if we tell it not to check membership.",(async function(){let r=await n.verify(a,{team:e.team,member:!1});expect(r).toBeTruthy(),expect(r.text).toBe("message"),expect(r.protectedHeader.act).toBe(t),expect(r.protectedHeader.iat).toBeTruthy()})),it('fails if we tell it to check notBefore:"team", even if we tell it not to check membership.',(async function(){let t=await n.verify(a,{team:e.team,member:!1,notBefore:"team"});expect(t).toBeUndefined()}))}))})),it("can safely be used when a device is removed, but not after being entirely destroyed.",(async function(){let[e,a]=await Promise.all([n.create(),n.create()]),r=await n.create(e,a),i=await n.create(r),c=await n.encrypt(t,i),o=await n.decrypt(c,i);expect(o.text).toBe(t),o=await n.decrypt(c,i),await n.changeMembership({tag:r,remove:[e]}),expect(o.text).toBe(t),await n.changeMembership({tag:r,add:[e]}),o=await n.decrypt(c,i),expect(o.text).toBe(t),await n.destroy(a),o=await n.decrypt(c,i),expect(o.text).toBe(t),await n.destroy({tag:i,recursiveMembers:!0});let s=await n.decrypt(c,i).then((()=>null),(e=>e.message));expect(s).toBeTruthy()}),a),it("device is useable as soon as it resolves.",(async function(){let e=await n.create();expect(await n.sign("anything",e)).toBeTruthy(),await n.destroy(e)}),1e4),it("team is useable as soon as it resolves.",(async function(){let t=await n.create(e.device);expect(await n.sign("anything",t)).toBeTruthy(),await n.destroy(t)})),it("allows recovery prompts that contain dot.",(async function(){let e=await n.create({prompt:"foo.bar"}),t=await n.create(e),a="red.white",r=await n.encrypt(a,t),i=await n.decrypt(r,t),c=await n.sign(a,t);expect(i.text).toBe(a),expect(await n.verify(c,t)).toBeTruthy(),await n.destroy({tag:t,recursiveMembers:!0})}),1e4),it("supports rotation.",(async function(){let t=await n.create(e.device),a=await n.create(t),r=await n.sign("some purchase order",{team:a,member:t}),i=await n.encrypt("the other set of books",a);expect(await n.verify(r)).toBeTruthy(),expect(await n.verify(r,{team:a,member:!1})).toBeTruthy(),expect(await n.decrypt(i)).toBeTruthy();let c=await n.create(e.device),o=await n.create(e.device);await n.changeMembership({tag:a,remove:[t],add:[c,o]}),await n.destroy(t),expect(await n.sign("bogus PO",{team:a,member:t}).catch((()=>{}))).toBeUndefined();let s=await n.sign("new PO",{team:a,member:c}),d=await n.sign("new PO",{team:a,member:o});expect(await n.verify(s)).toBeTruthy(),expect(await n.verify(d)).toBeTruthy(),expect(await n.verify(r).catch((()=>{}))).toBeUndefined(),expect(await n.verify(r,{team:a,member:!1})).toBeTruthy(),expect(await n.decrypt(i)).toBeTruthy();let y=await n.create(c);await n.destroy(a),expect(await n.sign("bogus PO",{team:a,member:c}).catch((()=>{}))).toBeUndefined(),expect(await n.sign("new new PO",{team:y,member:c})).toBeTruthy(),expect(await n.verify(r,{team:a,member:!1})).toBeTruthy(),expect(await n.verify(s)).toBeTruthy(),expect(await n.verify(d)).toBeTruthy(),expect(await n.decrypt(i).catch((()=>{}))).toBeUndefined()}),15e3)}))}))}));
