const e={origin:new URL(import.meta.url).origin,async store(e,t,a){let r=await this.Security.verify(a,{team:t,notBefore:"team"});if(!r)throw new Error(`Signature ${a} does not match owner of ${t}.`);return r.payload.length?this[e][t]=a:delete this[e][t],null},async retrieve(e,t){return this[e][t]},Team:{},KeyRecovery:{},EncryptionKey:{}};const t=new URL(import.meta.url).origin,a=/(\S{50})(\S{2})(\S{2})(\S+)/;async function r(e){if(404===e.status)return"";if(!e.ok)return Promise.reject(e.statusText);let t=await e.text();return t?JSON.parse(t):t}const i={get origin(){return t},tagPath:function(e,t,r="json"){if(!t)return e;let i=t.match(a);if(!i)return`${e}/${t}`;let[n,c,o,s,d]=i;return`${e}/${o}/${s}/${c}/${d}.${r}`},mkdir:undefined,uri(e,a){return`${t}/db/${this.tagPath(e,a)}`},store(e,t,a,i={}){return fetch(this.uri(e,t),{method:"PUT",body:JSON.stringify(a),headers:{"Content-Type":"application/json",...i.headers||{}}}).then(r)},retrieve(e,t,a={}){return fetch(this.uri(e,t),{cache:"default",headers:{Accept:"application/json",...a.headers||{}}}).then(r)}};var n=e=>e;function c(e,t){return t?e+n(t):e}"undefined"!=typeof window&&(n=window.prompt);var o=crypto,s=crypto;const d=e=>e instanceof CryptoKey,y=async(e,t)=>{const a=`SHA-${e.slice(-3)}`;return new Uint8Array(await s.subtle.digest(a,t))},p=new TextEncoder,l=new TextDecoder,u=2**32;function w(...e){const t=e.reduce(((e,{length:t})=>e+t),0),a=new Uint8Array(t);let r=0;for(const t of e)a.set(t,r),r+=t.length;return a}function h(e,t,a){if(t<0||t>=u)throw new RangeError(`value must be >= 0 and <= ${u-1}. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,255&t],a)}function f(e){const t=Math.floor(e/u),a=e%u,r=new Uint8Array(8);return h(r,t,0),h(r,a,4),r}function g(e){const t=new Uint8Array(4);return h(t,e),t}function m(e){return w(g(e.length),e)}const b=e=>(e=>{let t=e;"string"==typeof t&&(t=p.encode(t));const a=[];for(let e=0;e<t.length;e+=32768)a.push(String.fromCharCode.apply(null,t.subarray(e,e+32768)));return btoa(a.join(""))})(e).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),v=e=>{let t=e;t instanceof Uint8Array&&(t=l.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return(e=>{const t=atob(e),a=new Uint8Array(t.length);for(let e=0;e<t.length;e++)a[e]=t.charCodeAt(e);return a})(t)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}};class E extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(e){super(e),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,Error.captureStackTrace?.(this,this.constructor)}}class S extends E{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class x extends E{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class K extends E{constructor(){super(...arguments),this.code="ERR_JWE_DECRYPTION_FAILED",this.message="decryption operation failed"}static get code(){return"ERR_JWE_DECRYPTION_FAILED"}}class A extends E{constructor(){super(...arguments),this.code="ERR_JWE_INVALID"}static get code(){return"ERR_JWE_INVALID"}}class H extends E{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class B extends E{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}var P=s.getRandomValues.bind(s);function k(e){switch(e){case"A128GCM":case"A128GCMKW":case"A192GCM":case"A192GCMKW":case"A256GCM":case"A256GCMKW":return 96;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return 128;default:throw new x(`Unsupported JWE Algorithm: ${e}`)}}const C=(e,t)=>{if(t.length<<3!==k(e))throw new A("Invalid Initialization Vector length")},T=(e,t)=>{const a=e.byteLength<<3;if(a!==t)throw new A(`Invalid Content Encryption Key length. Expected ${t} bits, got ${a} bits`)};function U(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function W(e,t){return e.name===t}function _(e){return parseInt(e.name.slice(4),10)}function J(e,t){if(t.length&&!t.some((t=>e.usages.includes(t)))){let e="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const a=t.pop();e+=`one of ${t.join(", ")}, or ${a}.`}else 2===t.length?e+=`one of ${t[0]} or ${t[1]}.`:e+=`${t[0]}.`;throw new TypeError(e)}}function D(e,t,...a){switch(t){case"HS256":case"HS384":case"HS512":{if(!W(e.algorithm,"HMAC"))throw U("HMAC");const a=parseInt(t.slice(2),10);if(_(e.algorithm.hash)!==a)throw U(`SHA-${a}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!W(e.algorithm,"RSASSA-PKCS1-v1_5"))throw U("RSASSA-PKCS1-v1_5");const a=parseInt(t.slice(2),10);if(_(e.algorithm.hash)!==a)throw U(`SHA-${a}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!W(e.algorithm,"RSA-PSS"))throw U("RSA-PSS");const a=parseInt(t.slice(2),10);if(_(e.algorithm.hash)!==a)throw U(`SHA-${a}`,"algorithm.hash");break}case"EdDSA":if("Ed25519"!==e.algorithm.name&&"Ed448"!==e.algorithm.name)throw U("Ed25519 or Ed448");break;case"ES256":case"ES384":case"ES512":{if(!W(e.algorithm,"ECDSA"))throw U("ECDSA");const a=function(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}(t);if(e.algorithm.namedCurve!==a)throw U(a,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}J(e,a)}function R(e,t,...a){switch(t){case"A128GCM":case"A192GCM":case"A256GCM":{if(!W(e.algorithm,"AES-GCM"))throw U("AES-GCM");const a=parseInt(t.slice(1,4),10);if(e.algorithm.length!==a)throw U(a,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!W(e.algorithm,"AES-KW"))throw U("AES-KW");const a=parseInt(t.slice(1,4),10);if(e.algorithm.length!==a)throw U(a,"algorithm.length");break}case"ECDH":switch(e.algorithm.name){case"ECDH":case"X25519":case"X448":break;default:throw U("ECDH, X25519, or X448")}break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!W(e.algorithm,"PBKDF2"))throw U("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!W(e.algorithm,"RSA-OAEP"))throw U("RSA-OAEP");const a=parseInt(t.slice(9),10)||1;if(_(e.algorithm.hash)!==a)throw U(`SHA-${a}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}J(e,a)}function j(e,t,...a){if(a.length>2){const t=a.pop();e+=`one of type ${a.join(", ")}, or ${t}.`}else 2===a.length?e+=`one of type ${a[0]} or ${a[1]}.`:e+=`of type ${a[0]}.`;return null==t?e+=` Received ${t}`:"function"==typeof t&&t.name?e+=` Received function ${t.name}`:"object"==typeof t&&null!=t&&t.constructor?.name&&(e+=` Received an instance of ${t.constructor.name}`),e}var O=(e,...t)=>j("Key must be ",e,...t);function M(e,t,...a){return j(`Key for the ${e} algorithm must be `,t,...a)}var $=e=>d(e);const I=["CryptoKey"];async function G(e,t,a,r,i,n){if(!(t instanceof Uint8Array))throw new TypeError(O(t,"Uint8Array"));const c=parseInt(e.slice(1,4),10),o=await s.subtle.importKey("raw",t.subarray(c>>3),"AES-CBC",!1,["decrypt"]),d=await s.subtle.importKey("raw",t.subarray(0,c>>3),{hash:"SHA-"+(c<<1),name:"HMAC"},!1,["sign"]),y=w(n,r,a,f(n.length<<3)),p=new Uint8Array((await s.subtle.sign("HMAC",d,y)).slice(0,c>>3));let l,u;try{l=((e,t)=>{if(!(e instanceof Uint8Array))throw new TypeError("First argument must be a buffer");if(!(t instanceof Uint8Array))throw new TypeError("Second argument must be a buffer");if(e.length!==t.length)throw new TypeError("Input buffers must have the same length");const a=e.length;let r=0,i=-1;for(;++i<a;)r|=e[i]^t[i];return 0===r})(i,p)}catch{}if(!l)throw new K;try{u=new Uint8Array(await s.subtle.decrypt({iv:r,name:"AES-CBC"},o,a))}catch{}if(!u)throw new K;return u}const L=async(e,t,a,r,i,n)=>{if(!(d(t)||t instanceof Uint8Array))throw new TypeError(O(t,...I,"Uint8Array"));if(!r)throw new A("JWE Initialization Vector missing");if(!i)throw new A("JWE Authentication Tag missing");switch(C(e,r),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return t instanceof Uint8Array&&T(t,parseInt(e.slice(-3),10)),G(e,t,a,r,i,n);case"A128GCM":case"A192GCM":case"A256GCM":return t instanceof Uint8Array&&T(t,parseInt(e.slice(1,4),10)),async function(e,t,a,r,i,n){let c;t instanceof Uint8Array?c=await s.subtle.importKey("raw",t,"AES-GCM",!1,["decrypt"]):(R(t,e,"decrypt"),c=t);try{return new Uint8Array(await s.subtle.decrypt({additionalData:n,iv:r,name:"AES-GCM",tagLength:128},c,w(a,i)))}catch{throw new K}}(e,t,a,r,i,n);default:throw new x("Unsupported JWE Content Encryption Algorithm")}},N=(...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let a;for(const e of t){const t=Object.keys(e);if(a&&0!==a.size)for(const e of t){if(a.has(e))return!1;a.add(e)}else a=new Set(t)}return!0};function F(e){if("object"!=typeof(t=e)||null===t||"[object Object]"!==Object.prototype.toString.call(e))return!1;var t;if(null===Object.getPrototypeOf(e))return!0;let a=e;for(;null!==Object.getPrototypeOf(a);)a=Object.getPrototypeOf(a);return Object.getPrototypeOf(e)===a}const z=[{hash:"SHA-256",name:"HMAC"},!0,["sign"]];function q(e,t){if(e.algorithm.length!==parseInt(t.slice(1,4),10))throw new TypeError(`Invalid key size for alg: ${t}`)}function V(e,t,a){if(d(e))return R(e,t,a),e;if(e instanceof Uint8Array)return s.subtle.importKey("raw",e,"AES-KW",!0,[a]);throw new TypeError(O(e,...I,"Uint8Array"))}const X=async(e,t,a)=>{const r=await V(t,e,"wrapKey");q(r,e);const i=await s.subtle.importKey("raw",a,...z);return new Uint8Array(await s.subtle.wrapKey("raw",i,r,"AES-KW"))},Y=async(e,t,a)=>{const r=await V(t,e,"unwrapKey");q(r,e);const i=await s.subtle.unwrapKey("raw",a,r,"AES-KW",...z);return new Uint8Array(await s.subtle.exportKey("raw",i))};async function Z(e,t,a,r,i=new Uint8Array(0),n=new Uint8Array(0)){if(!d(e))throw new TypeError(O(e,...I));if(R(e,"ECDH"),!d(t))throw new TypeError(O(t,...I));R(t,"ECDH","deriveBits");const c=w(m(p.encode(a)),m(i),m(n),g(r));let o;o="X25519"===e.algorithm.name?256:"X448"===e.algorithm.name?448:Math.ceil(parseInt(e.algorithm.namedCurve.substr(-3),10)/8)<<3;return async function(e,t,a){const r=Math.ceil((t>>3)/32),i=new Uint8Array(32*r);for(let t=0;t<r;t++){const r=new Uint8Array(4+e.length+a.length);r.set(g(t+1)),r.set(e,4),r.set(a,4+e.length),i.set(await y("sha256",r),32*t)}return i.slice(0,t>>3)}(new Uint8Array(await s.subtle.deriveBits({name:e.algorithm.name,public:e},t,o)),r,c)}function Q(e){if(!d(e))throw new TypeError(O(e,...I));return["P-256","P-384","P-521"].includes(e.algorithm.namedCurve)||"X25519"===e.algorithm.name||"X448"===e.algorithm.name}async function ee(e,t,a,r){!function(e){if(!(e instanceof Uint8Array)||e.length<8)throw new A("PBES2 Salt Input must be 8 or more octets")}(e);const i=function(e,t){return w(p.encode(e),new Uint8Array([0]),t)}(t,e),n=parseInt(t.slice(13,16),10),c={hash:`SHA-${t.slice(8,11)}`,iterations:a,name:"PBKDF2",salt:i},o={length:n,name:"AES-KW"},y=await function(e,t){if(e instanceof Uint8Array)return s.subtle.importKey("raw",e,"PBKDF2",!1,["deriveBits"]);if(d(e))return R(e,t,"deriveBits","deriveKey"),e;throw new TypeError(O(e,...I,"Uint8Array"))}(r,t);if(y.usages.includes("deriveBits"))return new Uint8Array(await s.subtle.deriveBits(c,y,n));if(y.usages.includes("deriveKey"))return s.subtle.deriveKey(c,y,o,!1,["wrapKey","unwrapKey"]);throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"')}const te=async(e,t,a,r,i)=>{const n=await ee(i,e,r,t);return Y(e.slice(-6),n,a)};function ae(e){switch(e){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return"RSA-OAEP";default:throw new x(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}var re=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:a}=t.algorithm;if("number"!=typeof a||a<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};const ie=async(e,t,a)=>{if(!d(t))throw new TypeError(O(t,...I));if(R(t,e,"decrypt","unwrapKey"),re(e,t),t.usages.includes("decrypt"))return new Uint8Array(await s.subtle.decrypt(ae(e),t,a));if(t.usages.includes("unwrapKey")){const r=await s.subtle.unwrapKey("raw",a,t,ae(e),...z);return new Uint8Array(await s.subtle.exportKey("raw",r))}throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation')};function ne(e){switch(e){case"A128GCM":return 128;case"A192GCM":return 192;case"A256GCM":case"A128CBC-HS256":return 256;case"A192CBC-HS384":return 384;case"A256CBC-HS512":return 512;default:throw new x(`Unsupported JWE Algorithm: ${e}`)}}var ce=e=>P(new Uint8Array(ne(e)>>3));var oe=async e=>{if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:t,keyUsages:a}=function(e){let t,a;switch(e.kty){case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},a=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},a=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},a=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new x('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},a=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},a=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},a=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},a=e.d?["deriveBits"]:[];break;default:throw new x('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"OKP":switch(e.alg){case"EdDSA":t={name:e.crv},a=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},a=e.d?["deriveBits"]:[];break;default:throw new x('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;default:throw new x('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:a}}(e),r=[t,e.ext??!1,e.key_ops??a],i={...e};return delete i.alg,delete i.use,s.subtle.importKey("jwk",i,...r)};async function se(e,t){if(!F(e))throw new TypeError("JWK must be an object");switch(t||(t=e.alg),e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return v(e.k);case"RSA":if(void 0!==e.oth)throw new x('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return oe({...e,alg:t});default:throw new x('Unsupported "kty" (Key Type) Parameter value')}}const de=(e,t,a)=>{e.startsWith("HS")||"dir"===e||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e)?((e,t)=>{if(!(t instanceof Uint8Array)){if(!$(t))throw new TypeError(M(e,t,...I,"Uint8Array"));if("secret"!==t.type)throw new TypeError(`${I.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}})(e,t):((e,t,a)=>{if(!$(t))throw new TypeError(M(e,t,...I));if("secret"===t.type)throw new TypeError(`${I.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===a&&"public"===t.type)throw new TypeError(`${I.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===a&&"public"===t.type)throw new TypeError(`${I.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(t.algorithm&&"verify"===a&&"private"===t.type)throw new TypeError(`${I.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(t.algorithm&&"encrypt"===a&&"private"===t.type)throw new TypeError(`${I.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)})(e,t,a)};const ye=async(e,t,a,r,i)=>{if(!(d(a)||a instanceof Uint8Array))throw new TypeError(O(a,...I,"Uint8Array"));switch(r?C(e,r):r=P(new Uint8Array(k(e)>>3)),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return a instanceof Uint8Array&&T(a,parseInt(e.slice(-3),10)),async function(e,t,a,r,i){if(!(a instanceof Uint8Array))throw new TypeError(O(a,"Uint8Array"));const n=parseInt(e.slice(1,4),10),c=await s.subtle.importKey("raw",a.subarray(n>>3),"AES-CBC",!1,["encrypt"]),o=await s.subtle.importKey("raw",a.subarray(0,n>>3),{hash:"SHA-"+(n<<1),name:"HMAC"},!1,["sign"]),d=new Uint8Array(await s.subtle.encrypt({iv:r,name:"AES-CBC"},c,t)),y=w(i,r,d,f(i.length<<3));return{ciphertext:d,tag:new Uint8Array((await s.subtle.sign("HMAC",o,y)).slice(0,n>>3)),iv:r}}(e,t,a,r,i);case"A128GCM":case"A192GCM":case"A256GCM":return a instanceof Uint8Array&&T(a,parseInt(e.slice(1,4),10)),async function(e,t,a,r,i){let n;a instanceof Uint8Array?n=await s.subtle.importKey("raw",a,"AES-GCM",!1,["encrypt"]):(R(a,e,"encrypt"),n=a);const c=new Uint8Array(await s.subtle.encrypt({additionalData:i,iv:r,name:"AES-GCM",tagLength:128},n,t)),o=c.slice(-16);return{ciphertext:c.slice(0,-16),tag:o,iv:r}}(e,t,a,r,i);default:throw new x("Unsupported JWE Content Encryption Algorithm")}};async function pe(e,t,a,r,i){switch(de(e,t,"decrypt"),e){case"dir":if(void 0!==a)throw new A("Encountered unexpected JWE Encrypted Key");return t;case"ECDH-ES":if(void 0!==a)throw new A("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!F(r.epk))throw new A('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(!Q(t))throw new x("ECDH with the provided key is not allowed or not supported by your javascript runtime");const i=await se(r.epk,e);let n,c;if(void 0!==r.apu){if("string"!=typeof r.apu)throw new A('JOSE Header "apu" (Agreement PartyUInfo) invalid');try{n=v(r.apu)}catch{throw new A("Failed to base64url decode the apu")}}if(void 0!==r.apv){if("string"!=typeof r.apv)throw new A('JOSE Header "apv" (Agreement PartyVInfo) invalid');try{c=v(r.apv)}catch{throw new A("Failed to base64url decode the apv")}}const o=await Z(i,t,"ECDH-ES"===e?r.enc:e,"ECDH-ES"===e?ne(r.enc):parseInt(e.slice(-5,-2),10),n,c);if("ECDH-ES"===e)return o;if(void 0===a)throw new A("JWE Encrypted Key missing");return Y(e.slice(-6),o,a)}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":if(void 0===a)throw new A("JWE Encrypted Key missing");return ie(e,t,a);case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{if(void 0===a)throw new A("JWE Encrypted Key missing");if("number"!=typeof r.p2c)throw new A('JOSE Header "p2c" (PBES2 Count) missing or invalid');const n=i?.maxPBES2Count||1e4;if(r.p2c>n)throw new A('JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds');if("string"!=typeof r.p2s)throw new A('JOSE Header "p2s" (PBES2 Salt) missing or invalid');let c;try{c=v(r.p2s)}catch{throw new A("Failed to base64url decode the p2s")}return te(e,t,a,r.p2c,c)}case"A128KW":case"A192KW":case"A256KW":if(void 0===a)throw new A("JWE Encrypted Key missing");return Y(e,t,a);case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{if(void 0===a)throw new A("JWE Encrypted Key missing");if("string"!=typeof r.iv)throw new A('JOSE Header "iv" (Initialization Vector) missing or invalid');if("string"!=typeof r.tag)throw new A('JOSE Header "tag" (Authentication Tag) missing or invalid');let i,n;try{i=v(r.iv)}catch{throw new A("Failed to base64url decode the iv")}try{n=v(r.tag)}catch{throw new A("Failed to base64url decode the tag")}return async function(e,t,a,r,i){const n=e.slice(0,7);return L(n,t,a,r,i,new Uint8Array(0))}(e,t,a,i,n)}default:throw new x('Invalid or unsupported "alg" (JWE Algorithm) header value')}}function le(e,t,a,r,i){if(void 0!==i.crit&&void 0===r?.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!r||void 0===r.crit)return new Set;if(!Array.isArray(r.crit)||0===r.crit.length||r.crit.some((e=>"string"!=typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let n;n=void 0!==a?new Map([...Object.entries(a),...t.entries()]):t;for(const t of r.crit){if(!n.has(t))throw new x(`Extension Header Parameter "${t}" is not recognized`);if(void 0===i[t])throw new e(`Extension Header Parameter "${t}" is missing`);if(n.get(t)&&void 0===r[t])throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}return new Set(r.crit)}const ue=(e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some((e=>"string"!=typeof e))))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};async function we(e,t,a){if(!F(e))throw new A("Flattened JWE must be an object");if(void 0===e.protected&&void 0===e.header&&void 0===e.unprotected)throw new A("JOSE Header missing");if(void 0!==e.iv&&"string"!=typeof e.iv)throw new A("JWE Initialization Vector incorrect type");if("string"!=typeof e.ciphertext)throw new A("JWE Ciphertext missing or incorrect type");if(void 0!==e.tag&&"string"!=typeof e.tag)throw new A("JWE Authentication Tag incorrect type");if(void 0!==e.protected&&"string"!=typeof e.protected)throw new A("JWE Protected Header incorrect type");if(void 0!==e.encrypted_key&&"string"!=typeof e.encrypted_key)throw new A("JWE Encrypted Key incorrect type");if(void 0!==e.aad&&"string"!=typeof e.aad)throw new A("JWE AAD incorrect type");if(void 0!==e.header&&!F(e.header))throw new A("JWE Shared Unprotected Header incorrect type");if(void 0!==e.unprotected&&!F(e.unprotected))throw new A("JWE Per-Recipient Unprotected Header incorrect type");let r;if(e.protected)try{const t=v(e.protected);r=JSON.parse(l.decode(t))}catch{throw new A("JWE Protected Header is invalid")}if(!N(r,e.header,e.unprotected))throw new A("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");const i={...r,...e.header,...e.unprotected};if(le(A,new Map,a?.crit,r,i),void 0!==i.zip)throw new x('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');const{alg:n,enc:c}=i;if("string"!=typeof n||!n)throw new A("missing JWE Algorithm (alg) in JWE Header");if("string"!=typeof c||!c)throw new A("missing JWE Encryption Algorithm (enc) in JWE Header");const o=a&&ue("keyManagementAlgorithms",a.keyManagementAlgorithms),s=a&&ue("contentEncryptionAlgorithms",a.contentEncryptionAlgorithms);if(o&&!o.has(n)||!o&&n.startsWith("PBES2"))throw new S('"alg" (Algorithm) Header Parameter value not allowed');if(s&&!s.has(c))throw new S('"enc" (Encryption Algorithm) Header Parameter value not allowed');let d;if(void 0!==e.encrypted_key)try{d=v(e.encrypted_key)}catch{throw new A("Failed to base64url decode the encrypted_key")}let y,u,h,f=!1;"function"==typeof t&&(t=await t(r,e),f=!0);try{y=await pe(n,t,d,i,a)}catch(e){if(e instanceof TypeError||e instanceof A||e instanceof x)throw e;y=ce(c)}if(void 0!==e.iv)try{u=v(e.iv)}catch{throw new A("Failed to base64url decode the iv")}if(void 0!==e.tag)try{h=v(e.tag)}catch{throw new A("Failed to base64url decode the tag")}const g=p.encode(e.protected??"");let m,b;m=void 0!==e.aad?w(g,p.encode("."),p.encode(e.aad)):g;try{b=v(e.ciphertext)}catch{throw new A("Failed to base64url decode the ciphertext")}const E={plaintext:await L(c,y,b,u,h,m)};if(void 0!==e.protected&&(E.protectedHeader=r),void 0!==e.aad)try{E.additionalAuthenticatedData=v(e.aad)}catch{throw new A("Failed to base64url decode the aad")}return void 0!==e.unprotected&&(E.sharedUnprotectedHeader=e.unprotected),void 0!==e.header&&(E.unprotectedHeader=e.header),f?{...E,key:t}:E}var he=async e=>{if(e instanceof Uint8Array)return{kty:"oct",k:b(e)};if(!d(e))throw new TypeError(O(e,...I,"Uint8Array"));if(!e.extractable)throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");const{ext:t,key_ops:a,alg:r,use:i,...n}=await s.subtle.exportKey("jwk",e);return n};async function fe(e){return he(e)}async function ge(e,t,a,r,i={}){let n,c,o;switch(de(e,a,"encrypt"),e){case"dir":o=a;break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!Q(a))throw new x("ECDH with the provided key is not allowed or not supported by your javascript runtime");const{apu:y,apv:p}=i;let{epk:l}=i;l||(l=(await async function(e){if(!d(e))throw new TypeError(O(e,...I));return s.subtle.generateKey(e.algorithm,!0,["deriveBits"])}(a)).privateKey);const{x:u,y:w,crv:h,kty:f}=await fe(l),g=await Z(a,l,"ECDH-ES"===e?t:e,"ECDH-ES"===e?ne(t):parseInt(e.slice(-5,-2),10),y,p);if(c={epk:{x:u,crv:h,kty:f}},"EC"===f&&(c.epk.y=w),y&&(c.apu=b(y)),p&&(c.apv=b(p)),"ECDH-ES"===e){o=g;break}o=r||ce(t);const m=e.slice(-6);n=await X(m,g,o);break}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":o=r||ce(t),n=await(async(e,t,a)=>{if(!d(t))throw new TypeError(O(t,...I));if(R(t,e,"encrypt","wrapKey"),re(e,t),t.usages.includes("encrypt"))return new Uint8Array(await s.subtle.encrypt(ae(e),t,a));if(t.usages.includes("wrapKey")){const r=await s.subtle.importKey("raw",a,...z);return new Uint8Array(await s.subtle.wrapKey("raw",r,t,ae(e)))}throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation')})(e,a,o);break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{o=r||ce(t);const{p2c:s,p2s:d}=i;({encryptedKey:n,...c}=await(async(e,t,a,r=2048,i=P(new Uint8Array(16)))=>{const n=await ee(i,e,r,t);return{encryptedKey:await X(e.slice(-6),n,a),p2c:r,p2s:b(i)}})(e,a,o,s,d));break}case"A128KW":case"A192KW":case"A256KW":o=r||ce(t),n=await X(e,a,o);break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{o=r||ce(t);const{iv:s}=i;({encryptedKey:n,...c}=await async function(e,t,a,r){const i=e.slice(0,7),n=await ye(i,a,t,r,new Uint8Array(0));return{encryptedKey:n.ciphertext,iv:b(n.iv),tag:b(n.tag)}}(e,a,o,s));break}default:throw new x('Invalid or unsupported "alg" (JWE Algorithm) header value')}return{cek:o,encryptedKey:n,parameters:c}}const me=Symbol();class be{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("plaintext must be an instance of Uint8Array");this._plaintext=e}setKeyManagementParameters(e){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=e,this}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._sharedUnprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._sharedUnprotectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}setContentEncryptionKey(e){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=e,this}setInitializationVector(e){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=e,this}async encrypt(e,t){if(!this._protectedHeader&&!this._unprotectedHeader&&!this._sharedUnprotectedHeader)throw new A("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");if(!N(this._protectedHeader,this._unprotectedHeader,this._sharedUnprotectedHeader))throw new A("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const a={...this._protectedHeader,...this._unprotectedHeader,...this._sharedUnprotectedHeader};if(le(A,new Map,t?.crit,this._protectedHeader,a),void 0!==a.zip)throw new x('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');const{alg:r,enc:i}=a;if("string"!=typeof r||!r)throw new A('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("string"!=typeof i||!i)throw new A('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');let n,c,o,s,d;if(this._cek&&("dir"===r||"ECDH-ES"===r))throw new TypeError(`setContentEncryptionKey cannot be called with JWE "alg" (Algorithm) Header ${r}`);{let a;({cek:c,encryptedKey:n,parameters:a}=await ge(r,i,e,this._cek,this._keyManagementParameters)),a&&(t&&me in t?this._unprotectedHeader?this._unprotectedHeader={...this._unprotectedHeader,...a}:this.setUnprotectedHeader(a):this._protectedHeader?this._protectedHeader={...this._protectedHeader,...a}:this.setProtectedHeader(a))}s=this._protectedHeader?p.encode(b(JSON.stringify(this._protectedHeader))):p.encode(""),this._aad?(d=b(this._aad),o=w(s,p.encode("."),p.encode(d))):o=s;const{ciphertext:y,tag:u,iv:h}=await ye(i,this._plaintext,c,this._iv,o),f={ciphertext:b(y)};return h&&(f.iv=b(h)),u&&(f.tag=b(u)),n&&(f.encrypted_key=b(n)),d&&(f.aad=d),this._protectedHeader&&(f.protected=l.decode(s)),this._sharedUnprotectedHeader&&(f.unprotected=this._sharedUnprotectedHeader),this._unprotectedHeader&&(f.header=this._unprotectedHeader),f}}class ve{constructor(e,t,a){this.parent=e,this.key=t,this.options=a}setUnprotectedHeader(e){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=e,this}addRecipient(...e){return this.parent.addRecipient(...e)}encrypt(...e){return this.parent.encrypt(...e)}done(){return this.parent}}class Ee{constructor(e){this._recipients=[],this._plaintext=e}addRecipient(e,t){const a=new ve(this,e,{crit:t?.crit});return this._recipients.push(a),a}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}async encrypt(){if(!this._recipients.length)throw new A("at least one recipient must be added");if(1===this._recipients.length){const[e]=this._recipients,t=await new be(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(e.unprotectedHeader).encrypt(e.key,{...e.options}),a={ciphertext:t.ciphertext,iv:t.iv,recipients:[{}],tag:t.tag};return t.aad&&(a.aad=t.aad),t.protected&&(a.protected=t.protected),t.unprotected&&(a.unprotected=t.unprotected),t.encrypted_key&&(a.recipients[0].encrypted_key=t.encrypted_key),t.header&&(a.recipients[0].header=t.header),a}let e;for(let t=0;t<this._recipients.length;t++){const a=this._recipients[t];if(!N(this._protectedHeader,this._unprotectedHeader,a.unprotectedHeader))throw new A("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const r={...this._protectedHeader,...this._unprotectedHeader,...a.unprotectedHeader},{alg:i}=r;if("string"!=typeof i||!i)throw new A('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("dir"===i||"ECDH-ES"===i)throw new A('"dir" and "ECDH-ES" alg may only be used with a single recipient');if("string"!=typeof r.enc||!r.enc)throw new A('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');if(e){if(e!==r.enc)throw new A('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients')}else e=r.enc;if(le(A,new Map,a.options.crit,this._protectedHeader,r),void 0!==r.zip)throw new x('JWE "zip" (Compression Algorithm) Header Parameter is not supported.')}const t=ce(e),a={ciphertext:"",iv:"",recipients:[],tag:""};for(let r=0;r<this._recipients.length;r++){const i=this._recipients[r],n={};a.recipients.push(n);const c={...this._protectedHeader,...this._unprotectedHeader,...i.unprotectedHeader}.alg.startsWith("PBES2")?2048+r:void 0;if(0===r){const e=await new be(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(t).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(i.unprotectedHeader).setKeyManagementParameters({p2c:c}).encrypt(i.key,{...i.options,[me]:!0});a.ciphertext=e.ciphertext,a.iv=e.iv,a.tag=e.tag,e.aad&&(a.aad=e.aad),e.protected&&(a.protected=e.protected),e.unprotected&&(a.unprotected=e.unprotected),n.encrypted_key=e.encrypted_key,e.header&&(n.header=e.header);continue}const{encryptedKey:o,parameters:s}=await ge(i.unprotectedHeader?.alg||this._protectedHeader?.alg||this._unprotectedHeader?.alg,e,i.key,t,{p2c:c});n.encrypted_key=b(o),(i.unprotectedHeader||s)&&(n.header={...i.unprotectedHeader,...s})}return a}}function Se(e,t){const a=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:a,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:a,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:a,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:a,name:"ECDSA",namedCurve:t.namedCurve};case"EdDSA":return{name:t.name};default:throw new x(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}function xe(e,t,a){if(d(t))return D(t,e,a),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(O(t,...I));return s.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[a])}throw new TypeError(O(t,...I,"Uint8Array"))}const Ke=async(e,t,a,r)=>{const i=await xe(e,t,"verify");re(e,i);const n=Se(e,i.algorithm);try{return await s.subtle.verify(n,i,a,r)}catch{return!1}};async function Ae(e,t,a){if(!F(e))throw new H("Flattened JWS must be an object");if(void 0===e.protected&&void 0===e.header)throw new H('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==e.protected&&"string"!=typeof e.protected)throw new H("JWS Protected Header incorrect type");if(void 0===e.payload)throw new H("JWS Payload missing");if("string"!=typeof e.signature)throw new H("JWS Signature missing or incorrect type");if(void 0!==e.header&&!F(e.header))throw new H("JWS Unprotected Header incorrect type");let r={};if(e.protected)try{const t=v(e.protected);r=JSON.parse(l.decode(t))}catch{throw new H("JWS Protected Header is invalid")}if(!N(r,e.header))throw new H("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const i={...r,...e.header};let n=!0;if(le(H,new Map([["b64",!0]]),a?.crit,r,i).has("b64")&&(n=r.b64,"boolean"!=typeof n))throw new H('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:c}=i;if("string"!=typeof c||!c)throw new H('JWS "alg" (Algorithm) Header Parameter missing or invalid');const o=a&&ue("algorithms",a.algorithms);if(o&&!o.has(c))throw new S('"alg" (Algorithm) Header Parameter value not allowed');if(n){if("string"!=typeof e.payload)throw new H("JWS Payload must be a string")}else if("string"!=typeof e.payload&&!(e.payload instanceof Uint8Array))throw new H("JWS Payload must be a string or an Uint8Array instance");let s=!1;"function"==typeof t&&(t=await t(r,e),s=!0),de(c,t,"verify");const d=w(p.encode(e.protected??""),p.encode("."),"string"==typeof e.payload?p.encode(e.payload):e.payload);let y;try{y=v(e.signature)}catch{throw new H("Failed to base64url decode the signature")}if(!await Ke(c,t,y,d))throw new B;let u;if(n)try{u=v(e.payload)}catch{throw new H("Failed to base64url decode the payload")}else u="string"==typeof e.payload?p.encode(e.payload):e.payload;const h={payload:u};return void 0!==e.protected&&(h.protectedHeader=r),void 0!==e.header&&(h.unprotectedHeader=e.header),s?{...h,key:t}:h}class He{constructor(e){this._flattened=new be(e)}setContentEncryptionKey(e){return this._flattened.setContentEncryptionKey(e),this}setInitializationVector(e){return this._flattened.setInitializationVector(e),this}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}setKeyManagementParameters(e){return this._flattened.setKeyManagementParameters(e),this}async encrypt(e,t){const a=await this._flattened.encrypt(e,t);return[a.protected,a.encrypted_key,a.iv,a.ciphertext,a.tag].join(".")}}class Be{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=e}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}async sign(e,t){if(!this._protectedHeader&&!this._unprotectedHeader)throw new H("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!N(this._protectedHeader,this._unprotectedHeader))throw new H("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const a={...this._protectedHeader,...this._unprotectedHeader};let r=!0;if(le(H,new Map([["b64",!0]]),t?.crit,this._protectedHeader,a).has("b64")&&(r=this._protectedHeader.b64,"boolean"!=typeof r))throw new H('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:i}=a;if("string"!=typeof i||!i)throw new H('JWS "alg" (Algorithm) Header Parameter missing or invalid');de(i,e,"sign");let n,c=this._payload;r&&(c=p.encode(b(c))),n=this._protectedHeader?p.encode(b(JSON.stringify(this._protectedHeader))):p.encode("");const o=w(n,p.encode("."),c),d=await(async(e,t,a)=>{const r=await xe(e,t,"sign");re(e,r);const i=await s.subtle.sign(Se(e,r.algorithm),r,a);return new Uint8Array(i)})(i,e,o),y={signature:b(d),payload:""};return r&&(y.payload=l.decode(c)),this._unprotectedHeader&&(y.header=this._unprotectedHeader),this._protectedHeader&&(y.protected=l.decode(n)),y}}class Pe{constructor(e){this._flattened=new Be(e)}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}async sign(e,t){const a=await this._flattened.sign(e,t);if(void 0===a.payload)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${a.protected}.${a.payload}.${a.signature}`}}class ke{constructor(e,t,a){this.parent=e,this.key=t,this.options=a}setProtectedHeader(e){if(this.protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this.protectedHeader=e,this}setUnprotectedHeader(e){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=e,this}addSignature(...e){return this.parent.addSignature(...e)}sign(...e){return this.parent.sign(...e)}done(){return this.parent}}class Ce{constructor(e){this._signatures=[],this._payload=e}addSignature(e,t){const a=new ke(this,e,t);return this._signatures.push(a),a}async sign(){if(!this._signatures.length)throw new H("at least one signature must be added");const e={signatures:[],payload:""};for(let t=0;t<this._signatures.length;t++){const a=this._signatures[t],r=new Be(this._payload);r.setProtectedHeader(a.protectedHeader),r.setUnprotectedHeader(a.unprotectedHeader);const{payload:i,...n}=await r.sign(a.key,a.options);if(0===t)e.payload=i;else if(e.payload!==i)throw new H("inconsistent use of JWS Unencoded Payload (RFC7797)");e.signatures.push(n)}return e}}const Te=b,Ue=v;function We(e){const t=e?.modulusLength??2048;if("number"!=typeof t||t<2048)throw new x("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");return t}async function _e(e,t){return async function(e,t){let a,r;switch(e){case"PS256":case"PS384":case"PS512":a={name:"RSA-PSS",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:We(t)},r=["sign","verify"];break;case"RS256":case"RS384":case"RS512":a={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:We(t)},r=["sign","verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":a={name:"RSA-OAEP",hash:`SHA-${parseInt(e.slice(-3),10)||1}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:We(t)},r=["decrypt","unwrapKey","encrypt","wrapKey"];break;case"ES256":a={name:"ECDSA",namedCurve:"P-256"},r=["sign","verify"];break;case"ES384":a={name:"ECDSA",namedCurve:"P-384"},r=["sign","verify"];break;case"ES512":a={name:"ECDSA",namedCurve:"P-521"},r=["sign","verify"];break;case"EdDSA":{r=["sign","verify"];const e=t?.crv??"Ed25519";switch(e){case"Ed25519":case"Ed448":a={name:e};break;default:throw new x("Invalid or unsupported crv option provided")}break}case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{r=["deriveKey","deriveBits"];const e=t?.crv??"P-256";switch(e){case"P-256":case"P-384":case"P-521":a={name:"ECDH",namedCurve:e};break;case"X25519":case"X448":a={name:e};break;default:throw new x("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448")}break}default:throw new x('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return s.subtle.generateKey(a,t?.extractable??!1,r)}(e,t)}async function Je(e,t){return async function(e,t){let a,r,i;switch(e){case"HS256":case"HS384":case"HS512":a=parseInt(e.slice(-3),10),r={name:"HMAC",hash:`SHA-${a}`,length:a},i=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return a=parseInt(e.slice(-3),10),P(new Uint8Array(a>>3));case"A128KW":case"A192KW":case"A256KW":a=parseInt(e.slice(1,4),10),r={name:"AES-KW",length:a},i=["wrapKey","unwrapKey"];break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":case"A128GCM":case"A192GCM":case"A256GCM":a=parseInt(e.slice(1,4),10),r={name:"AES-GCM",length:a},i=["encrypt","decrypt"];break;default:throw new x('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return s.subtle.generateKey(r,t?.extractable??!1,i)}(e,t)}const De="ECDSA",Re="P-384",je="ES384",Oe="SHA-256",Me="RSA-OAEP-256",$e="AES-GCM",Ie="A256GCM",Ge="PBES2-HS512+A256KW",Le=!0;async function Ne(e){let t=await o.subtle.digest(Oe,e);return new Uint8Array(t)}function Fe(e){return Ne((new TextEncoder).encode(e))}function ze(e){return Te(e)}function qe(e){return Ue(e)}const Ve=new URL(import.meta.url),Xe=new URL("vault.html",Ve),Ye=Ve.href,Ze=document.createElement("iframe"),Qe=new MessageChannel,et=Object.assign({log(...e){console.log(...e)},getUserDeviceSecret:c},i),tt=new Promise((e=>{et.ready=e,Ze.style.display="none",document.body.append(Ze),Ze.setAttribute("src",Xe),Qe.port1.start(),Ze.onload=()=>Ze.contentWindow.postMessage(Ye,Xe.origin,[Qe.port2])})),at=function({target:e=self,receiver:t=e,namespace:a=t,origin:r=e!==t&&e.location.origin,dispatcherLabel:i=a.name||t.name||t.location?.href||t,targetLabel:n=e.name||r||e.location?.href||e,log:c=null,info:o=console.info.bind(console),warn:s=console.warn.bind(console),error:d=console.error.bind(console)}){const y={},p="2.0",l=e.postMessage.bind(e),u=r?e=>l(e,r):l;let w=0;return t.addEventListener("message",(async function(t){c?.(i,"got message",t.data,"from",n,t.origin);let{id:o,method:l,params:w=[],result:h,error:f,jsonrpc:g}=t.data||{};if(t.source&&t.source!==e)return d?.(i,"to",n,"got message from",t.source);if(r&&r!==t.origin)return d?.(i,r,"mismatched origin",n,t.origin);if(g!==p)return s?.(`${i} ignoring non-jsonrpc message ${JSON.stringify(t.data)}.`);if(l){let e,t=null,r=Array.isArray(w)?w:[w];try{e=await a[l](...r)}catch(e){t=function(e){let{name:t,message:a,code:r,data:i}=e;return{name:t,message:a,code:r,data:i}}(e),a[l]||t.message.includes(l)?t.message||(t.message=`${t.name||t.toString()} in ${l}.`):(t.message=`${l} is not defined.`,t.code=-32601)}if(void 0===o)return;let s=t?{id:o,error:t,jsonrpc:p}:{id:o,result:e,jsonrpc:p};return c?.(i,"answering",o,t||e,"to",n),u(s)}let m=y[o];if(delete y[o],!m)return s?.(`${i} ignoring response ${t.data}.`);f?m.reject(f):m.resolve(h)})),o?.(`${i} will dispatch to ${n}`),function(e,...t){let a=++w,r=y[a]={};return new Promise(((o,s)=>{c?.(i,"request",a,e,t,"to",n),Object.assign(r,{resolve:o,reject:s}),u({id:a,method:e,params:t,jsonrpc:p})}))}}({dispatcherLabel:"entry!"+Ye,namespace:et,target:Qe.port1,targetLabel:"vault!"+Ye}),rt={sign:(e,...t)=>at("sign",e,...t),verify:(e,...t)=>at("verify",e,...t),encrypt:(e,...t)=>at("encrypt",e,...t),decrypt:(e,...t)=>at("decrypt",e,...t),create:(...e)=>at("create",...e),changeMembership:({tag:e,add:t,remove:a}={})=>at("changeMembership",{tag:e,add:t,remove:a}),destroy:e=>at("destroy",e),clear:(e=null)=>at("clear",e),ready:tt,hashBuffer:Ne,hashText:Fe,encodeBase64url:ze,decodeBase64url:qe,get Storage(){return et},set Storage(e){Object.assign(et,e)},get getUserDeviceSecret(){return et.getUserDeviceSecret},set getUserDeviceSecret(e){et.getUserDeviceSecret=e}},nt=10485760;function ct(e=nt){return Array.from({length:e},((e,t)=>1&t)).join("")}const ot=/^[A-Za-z0-9_\-.]+$/;function st(e,t=ot){expect(t.test(e)).toBeTruthy()}function dt(e,t){expect(new Uint8Array(e.payload)).toEqual(t)}function yt(e,t=446){const a=15e3,r=t>1e3?a:5e3,i=ct();describe("signing",(function(){let t;beforeAll((async function(){t=await e.generateSigningKey()})),it("with a private key produces a base64URL signature that verifies with the public key.",(async function(){let a=await e.sign(t.privateKey,i);st(a),expect(await e.verify(t.publicKey,a)).toBeTruthy()})),it("returns undefined for verify with the wrong key.",(async function(){let a=await e.sign(t.privateKey,i),r=await e.generateSigningKey();expect(await e.verify(r.publicKey,a)).toBeUndefined()})),it("handles binary, and verifies with that as payload property.",(async function(){let a=new Uint8Array([21,31]),r=await e.sign(t.privateKey,a),i=await e.verify(t.publicKey,r);expect(i.cty).toBeUndefined(),dt(i,a)})),it('handles text, setting cty as "text/plain", and verifies with that as the text property and an encoding of that for payload.',(async function(){let a=await e.sign(t.privateKey,i),r=await e.verify(t.publicKey,a);expect(r.protectedHeader.cty).toBe("text/plain"),expect(r.text).toBe(i),expect(r.payload).toEqual((new TextEncoder).encode(i))})),it('handles json, setting cty as "json", and verifies with that as json property, the string of that as the text property, and the encoding of that string for payload.',(async function(){let a={foo:"bar"},r=await e.sign(t.privateKey,a),i=await e.verify(t.publicKey,r);expect(i.protectedHeader.cty).toBe("json"),expect(i.json).toEqual(a),expect(i.text).toBe(JSON.stringify(a)),expect(i.payload).toEqual((new TextEncoder).encode(JSON.stringify(a)))})),it("Uses specified headers if supplied, including cty.",(async function(){let a="text/html",r=Date.now(),i="<something else>",n=await e.sign(t.privateKey,i,{cty:a,iat:r,foo:17}),c=await e.verify(t.publicKey,n);expect(c.protectedHeader.cty).toBe(a),expect(c.protectedHeader.iat).toBe(r),expect(c.protectedHeader.foo).toBe(17),expect(c.text).toEqual(i)}))})),describe("encryption",(function(){let n;function c(t,a,r=a){it(`can work on much larger data with a ${t}.`,(async function(){let t=await a,n=await r,c=await e.encrypt(t,i),o=await e.decrypt(n,c);st(c),expect(o.text).toBe(i)}))}function o(r,i){it(`rejects wrong ${r}.`,(async function(){let[a,r]=await i(),n=ct(t),c=await e.encrypt(a,n);await expectAsync(e.decrypt(r,c)).toBeRejected()}),a)}beforeAll((async function(){n=await e.generateEncryptingKey()})),it(`can work up through at least ${t} bytes with an asymmetric keypair.`,(async function(){let a=ct(t),r=await e.encrypt(n.publicKey,a),i=await e.decrypt(n.privateKey,r);st(r),expect(i.text).toBe(a)}),r),c("fixed symmetric key",e.generateSymmetricKey()),c("reproducible secret",e.generateSymmetricKey("secret"),e.generateSymmetricKey("secret")),it("handles binary, and decrypts as same.",(async function(){let t=new Uint8Array([21,31]),a=await e.encrypt(n.publicKey,t),r=await e.decrypt(n.privateKey,a),i=e.decodeProtectedHeader(a);expect(i.cty).toBeUndefined(),dt(r,t)})),it("handles text, and decrypts as same.",(async function(){let t=await e.encrypt(n.publicKey,i),a=await e.decrypt(n.privateKey,t),r=e.decodeProtectedHeader(t);expect(r.cty).toBe("text/plain"),expect(a.text).toBe(i)})),it("handles json, and decrypts as same.",(async function(){let t={foo:"bar"},a=await e.encrypt(n.publicKey,t),r=e.decodeProtectedHeader(a),i=await e.decrypt(n.privateKey,a);expect(r.cty).toBe("json"),expect(i.json).toEqual(t)})),it("Uses specified headers if supplied, including cty.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await e.encrypt(n.publicKey,r,{cty:t,iat:a,foo:17}),c=await e.decrypt(n.privateKey,i),o=e.decodeProtectedHeader(i);expect(o.cty).toBe(t),expect(o.iat).toBe(a),expect(o.foo).toBe(17),expect(c.text).toBe(r)})),o("asymmetric key",(async()=>[(await e.generateEncryptingKey()).publicKey,(await e.generateEncryptingKey()).privateKey])),o("symmetric key",(async()=>[await e.generateSymmetricKey(),await e.generateSymmetricKey()])),o("secret",(async()=>[await e.generateSymmetricKey("secret"),await e.generateSymmetricKey("secretX")]))})),describe("export/import",(function(){async function t(t){return JSON.stringify(await e.exportJWK(t))}function a(t){return e.importJWK(JSON.parse(t))}describe("of signing keys",(function(){it("works with the private signing key as a 253 byte serialization.",(async function(){let r=await e.generateSigningKey(),n=await t(r.privateKey),c=await a(n),o=await e.sign(c,i);expect(n.length).toBe(253),expect(await e.verify(r.publicKey,o)).toBeTruthy()}));it("works with the public verifying key as a 182 byte serialization.",(async function(){let r=await e.generateSigningKey(),n=await t(r.publicKey),c=await a(n),o=await e.sign(r.privateKey,i);expect(n.length).toBe(182),expect(await e.verify(c,o)).toBeTruthy()}));it("works with public key as a raw verifying key as a base64URL serialization of no more that 132 bytes",(async function(){let t=await e.generateSigningKey(),a=await e.exportRaw(t.publicKey),r=await e.importRaw(a),n=await e.sign(t.privateKey,i);st(a),expect(a.length).toBeLessThanOrEqual(132),expect(await e.verify(r,n)).toBeTruthy()}))})),describe("of encryption keys",(function(){const r=[3169,3173];it(`works with the private key as a ${r[0]}-${r[1]} byte serialization.`,(async function(){let i=await e.generateEncryptingKey(),n=await t(i.privateKey),c=await a(n),o=ct(446),s=await e.encrypt(i.publicKey,o),d=await e.decrypt(c,s);expect(n.length).toBeGreaterThanOrEqual(r[0]),expect(n.length).toBeLessThanOrEqual(r[1]),expect(d.text).toBe(o)}));it("works with the public key as a 735 byte serialization.",(async function(){let r=await e.generateEncryptingKey(),i=await t(r.publicKey),n=await a(i),c=ct(446),o=await e.encrypt(n,c),s=await e.decrypt(r.privateKey,o);expect(i.length).toBe(735),expect(s.text).toBe(c)}))})),describe("of symmetric key",(function(){it("works as a 79 byte serialization.",(async function(){let r=await e.generateSymmetricKey(),n=await t(r),c=await a(n),o=await e.encrypt(r,i),s=await e.decrypt(c,o);expect(n.length).toBe(79),expect(s.text).toBe(i)}))}))})),it("wraps like export+encrypt.",(async function(){let t=await e.generateSymmetricKey(),a=await e.generateEncryptingKey(),r=await e.exportJWK(t),i=await e.encrypt(a.publicKey,r),n=await e.decrypt(a.privateKey,i),c=await e.importJWK(n.json),o=await e.wrapKey(t,a.publicKey),s=await e.unwrapKey(o,a.privateKey),d="this is a message",y=await e.encrypt(s,d),p=await e.decrypt(c,y);st(o),expect(p.text).toBe(d)}),a)}const pt={decodeProtectedHeader:function(e){let t;if("string"==typeof e){const a=e.split(".");3!==a.length&&5!==a.length||([t]=a)}else if("object"==typeof e&&e){if(!("protected"in e))throw new TypeError("Token does not contain a Protected Header");t=e.protected}try{if("string"!=typeof t||!t)throw new Error;const e=JSON.parse(l.decode(Ue(t)));if(!F(e))throw new Error;return e}catch{throw new TypeError("Invalid Token or Protected Header formatting")}},isEmptyJWSPayload:e=>!e.split(".")[1],inputBuffer(e,t){if(ArrayBuffer.isView(e))return e;let a=t.cty||"";return a.includes("text")||"string"==typeof e?t.cty=a||"text/plain":(t.cty=a||"json",e=JSON.stringify(e)),(new TextEncoder).encode(e)},recoverDataFromContentType:(e,{cty:t=e?.protectedHeader?.cty}={})=>(e&&!Object.prototype.hasOwnProperty.call(e,"payload")&&(e.payload=e.plaintext),t&&e?.payload?(e.text=(new TextDecoder).decode(e.payload),t.includes("json")&&(e.json=JSON.parse(e.text)),e):e),generateSigningKey:()=>_e(je,{extractable:Le}),async sign(e,t,a={}){let r={alg:je,...a},i=this.inputBuffer(t,r);return new Pe(i).setProtectedHeader(r).sign(e)},async verify(e,t,a){let r=await async function(e,t,a){if(e instanceof Uint8Array&&(e=l.decode(e)),"string"!=typeof e)throw new H("Compact JWS must be a string or Uint8Array");const{0:r,1:i,2:n,length:c}=e.split(".");if(3!==c)throw new H("Invalid Compact JWS");const o=await Ae({payload:i,protected:r,signature:n},t,a),s={payload:o.payload,protectedHeader:o.protectedHeader};return"function"==typeof t?{...s,key:o.key}:s}(t,e).catch((()=>{}));return this.recoverDataFromContentType(r,a)},generateEncryptingKey:()=>_e(Me,{extractable:Le,modulusLength:4096}),async encrypt(e,t,a={}){let r={alg:this.isSymmetric(e)?"dir":Me,enc:Ie,...a},i=this.inputBuffer(t,r),n=this.keySecret(e);return new He(i).setProtectedHeader(r).encrypt(n)},async decrypt(e,t,a={}){let r=this.keySecret(e),i=await async function(e,t,a){if(e instanceof Uint8Array&&(e=l.decode(e)),"string"!=typeof e)throw new A("Compact JWE must be a string or Uint8Array");const{0:r,1:i,2:n,3:c,4:o,length:s}=e.split(".");if(5!==s)throw new A("Invalid Compact JWE");const d=await we({ciphertext:c,iv:n||void 0,protected:r,tag:o||void 0,encrypted_key:i||void 0},t,a),y={plaintext:d.plaintext,protectedHeader:d.protectedHeader};return"function"==typeof t?{...y,key:d.key}:y}(t,r);return this.recoverDataFromContentType(i,a),i},generateSecretKey:async e=>({type:"secret",text:await Fe(e)}),generateSymmetricKey(e){return e?this.generateSecretKey(e):Je(Ie,{extractable:Le})},isSymmetric:e=>"secret"===e.type,keySecret:e=>e.text?e.text:e,async exportRaw(e){let t=await function(e){return o.subtle.exportKey("raw",e)}(e);return ze(new Uint8Array(t))},importRaw:async e=>function(e){const t={name:De,namedCurve:Re};return o.subtle.importKey("raw",e,t,Le,["verify"])}(qe(e)),async exportJWK(e){let t=await fe(e),a=e.algorithm;if(a)a.name===De&&a.namedCurve===Re?t.alg=je:"RSA-OAEP"===a.name&&a.hash.name===Oe?t.alg=Me:a.name===$e&&256===a.length&&(t.alg=Ie);else switch(t.kty){case"EC":t.alg=je;break;case"RSA":t.alg=Me;break;case"oct":t.alg=Ie}return t},async importJWK(e){e={ext:!0,...e};let t=await se(e);return t instanceof Uint8Array&&(t=await function(e){const t={name:$e,length:256};return o.subtle.importKey("raw",e,t,!0,["encrypt","decrypt"])}(t)),t},async wrapKey(e,t,a={}){let r=await this.exportJWK(e);return this.encrypt(t,r,a)},async unwrapKey(e,t){let a=await this.decrypt(t,e);return this.importJWK(a.json)}};const lt={isMultiKey:e=>"multi"===(e.type||"multi"),keyTags:e=>Object.keys(e).filter((e=>"type"!==e)),async exportJWK(e){if(!this.isMultiKey(e))return super.exportJWK(e);let t=this.keyTags(e),a=await Promise.all(t.map((async t=>{let a=await this.exportJWK(e[t]);return a.kid=t,a})));return{keys:a}},async importJWK(e){if(!e.keys)return super.importJWK(e);let t={};return await Promise.all(e.keys.map((async e=>t[e.kid]=await this.importJWK(e)))),t},async encrypt(e,t,a={}){if(!this.isMultiKey(e))return super.encrypt(e,t,a);let r={enc:Ie,...a},i=this.inputBuffer(t,r),n=new Ee(i).setProtectedHeader(r);for(let t of this.keyTags(e)){let a=e[t],r="string"==typeof a,i=r||this.isSymmetric(a),c=r?(new TextEncoder).encode(a):this.keySecret(a),o=r?Ge:i?"A256GCMKW":Me;n.addRecipient(c).setUnprotectedHeader({kid:t,alg:o})}return await n.encrypt()},async decrypt(e,t,a){if(!this.isMultiKey(e))return super.decrypt(e,t,a);let r=t,{recipients:i}=r,n=i.map((async({header:t})=>{let{kid:a}=t,i=e[a],n={};if(!i)return Promise.reject("missing");"string"==typeof i&&(i=(new TextEncoder).encode(i),n.keyManagementAlgorithms=[Ge]);let c=await async function(e,t,a){if(!F(e))throw new A("General JWE must be an object");if(!Array.isArray(e.recipients)||!e.recipients.every(F))throw new A("JWE Recipients missing or incorrect type");if(!e.recipients.length)throw new A("JWE Recipients has no members");for(const r of e.recipients)try{return await we({aad:e.aad,ciphertext:e.ciphertext,encrypted_key:r.encrypted_key,header:r.header,iv:e.iv,protected:e.protected,tag:e.tag,unprotected:e.unprotected},t,a)}catch{}throw new K}(r,this.keySecret(i),n),o=c.unprotectedHeader.kid;return o!==a?function(e,t){let a=`Key ${e} does not match encoded ${t}.`;return Promise.reject(a)}(a,o):c}));return await Promise.any(n).then((e=>(this.recoverDataFromContentType(e,a),e)),(()=>{}))},async sign(e,t,a={}){if(!this.isMultiKey(e))return super.sign(e,t,a);let r=this.inputBuffer(t,a),i=new Ce(r);for(let t of this.keyTags(e)){let r=e[t],n={kid:t,alg:je,...a};i.addSignature(r).setProtectedHeader(n)}return i.sign()},verifySubSignature(e,t,a,r){let i=t.protectedHeader??this.decodeProtectedHeader(t),n=t.unprotectedHeader,c=i?.kid||n?.kid,o={...e,signatures:[t]},s={protectedHeader:i,unprotectedHeader:n,kid:c},d=c?[c]:r,y=Promise.any(d.map((async e=>async function(e,t,a){if(!F(e))throw new H("General JWS must be an object");if(!Array.isArray(e.signatures)||!e.signatures.every(F))throw new H("JWS Signatures missing or incorrect type");for(const r of e.signatures)try{return await Ae({header:r.header,payload:e.payload,protected:r.protected,signature:r.signature},t,a)}catch{}throw new B}(o,a[e]).then((t=>({kid:e,...t}))))));return y.catch((()=>s))},async verify(e,t,a={}){if(!this.isMultiKey(e))return super.verify(e,t,a);if(!t.signatures)return;let r=t,i=this.keyTags(e),n=await Promise.all(r.signatures.map((t=>this.verifySubSignature(r,t,e,i))));if(!n.find((e=>e.payload)))return;let[c,...o]=n,s={protectedHeader:{},unprotectedHeader:{},signers:n},d=e=>{let t=c[e],a=s[e];for(let r in t){let i=t[r];o.some((t=>t[e][r]!==i))||(a[r]=i)}};return d("protectedHeader"),d("protectedHeader"),s.payload=n.find((e=>e.payload)).payload,this.recoverDataFromContentType(s,a)}};Object.setPrototypeOf(lt,pt);class ut{constructor({collectionName:e="collection",dbName:t="asyncLocalStorage"}={}){this.collectionName=e,this.dbName=t,this.version=1}get db(){return this._db??=new Promise((e=>{const t=indexedDB.open(this.dbName,this.version);t.onupgradeneeded=e=>e.target.result.createObjectStore(this.collectionName),this.result(e,t)}))}transaction(e="read"){const t=this.collectionName;return this.db.then((a=>a.transaction(t,e).objectStore(t)))}result(e,t){t.onsuccess=t=>e(t.target.result||"")}retrieve(e){return new Promise((t=>{this.transaction("readonly").then((a=>this.result(t,a.get(e))))}))}store(e,t){return new Promise((a=>{this.transaction("readwrite").then((r=>this.result(a,r.put(t,e))))}))}remove(e){return new Promise((t=>{this.transaction("readwrite").then((a=>this.result(t,a.delete(e))))}))}}function wt(e,t,a=void 0){let r=e(t.slice(0,16)+"...");return Promise.reject(new Error(r,{cause:a}))}function ht(e){return wt((e=>`The tag ${e} is not available.`),e)}class ft{static keySets={};static cached(e){return ft.keySets[e]}static clear(e=null){if(!e)return ft.keySets={};delete ft.keySets[e]}constructor(e){this.tag=e,this.memberTags=[],ft.keySets[e]=this}static getUserDeviceSecret=c;static Storage=i;static async create(e){let{time:t,...a}=await this.createKeys(e),{tag:r}=a;return await this.persist(r,a,e,t),r}async destroy(e={}){let{tag:t,memberTags:a,signingKey:r}=this,i=await this.constructor.signForStorage({...e,message:"",tag:t,memberTags:a,signingKey:r,time:Date.now(),recovery:!0});await this.constructor.store("EncryptionKey",t,i),await this.constructor.store(this.constructor.collection,t,i),this.constructor.clear(t),e.recursiveMembers&&await Promise.allSettled(this.memberTags.map((async t=>{let a=await ft.ensure(t,{...e,recovery:!0});await a.destroy(e)})))}decrypt(e,t){let{tag:a,decryptingKey:r}=this,i=e.recipients?{[a]:r}:r;return lt.decrypt(i,e,t)}static async sign(e,{tags:t=[],team:a,member:r,subject:i="hash",time:n=a&&Date.now(),memberTags:c,signingKey:o,...s}){if(a&&!r){c||(c=(await ft.ensure(a)).memberTags),r=c.find((e=>this.cached(e)))||await this.ensure1(c).then((e=>e.tag))}a&&!t.includes(a)&&(t=[a,...t]),r&&!t.includes(r)&&(t=[...t,r]);let d=await this.produceKey(t,(async e=>{let t=o||(await ft.ensure(e,s)).signingKey;return o=null,t}),s),y=lt.inputBuffer(e,s);if("hash"===i){const e=await Ne(y);i=await ze(e)}else i||(i=void 0);return lt.sign(d,y,{iss:a,act:r,iat:n,sub:i,...s})}static async verify(e,t,a){let r=!e.signatures,i=await this.produceKey(t,(e=>ft.verifyingKey(e)),a,r),n=await lt.verify(i,e,a),c=void 0===a.member?n?.protectedHeader.act:a.member,o=a.notBefore;function s(e){if(a.hardError)return Promise.reject(new Error(e))}if(!n)return s("Incorrect signature.");if(c){if("team"===a.member&&(c=n.protecteHeader.act,!c))return s("No member identified in signature.");if(!t.includes(c)){let r=await ft.verifyingKey(c),i={[c]:r};if(!await lt.verify(i,e,a))return s("Incorrect member signature.");t.push(c),n.signers.find((e=>e.protectedHeader.kid===c)).payload=n.payload}}if(c||"team"===o){let e=n.protectedHeader.iss||n.protectedHeader.kid,t=await this.retrieve(Et.collection,e),a=t?.json;if(c&&!e)return s("No team or main tag identified in signature");if(c&&a&&!a.recipients.find((e=>e.header.kid===c)))return s("Signer is not a member.");"team"===o&&(o=t?.protectedHeader.iat||(await this.retrieve("EncryptionKey",e))?.protectedHeader.iat)}if(o){let{iat:e}=n.protectedHeader;if(e<o)return s("Signature predates required timestamp.")}return(n.signers?.filter((e=>e.payload)).length||1)!==t.length?s("Unverified signer"):n}static async produceKey(e,t,a,r=1===e.length){if(r){let r=e[0];return a.kid=r,t(r)}let i={},n=await Promise.all(e.map((e=>t(e))));return e.forEach(((e,t)=>i[e]=n[t])),i}static verifyingKey(e){return lt.importRaw(e).catch((()=>ht(e)))}static async encryptingKey(e){let t=await this.retrieve("EncryptionKey",e);return t?await lt.importJWK(t.json):ht(e)}static async createKeys(e){let{publicKey:t,privateKey:a}=await lt.generateSigningKey(),{publicKey:r,privateKey:i}=await lt.generateEncryptingKey(),n=await lt.exportRaw(t),c=await lt.exportJWK(r),o=Date.now(),s=await this.signForStorage({message:c,tag:n,signingKey:a,memberTags:e,time:o,recovery:!0});return await this.store("EncryptionKey",n,s),{signingKey:a,decryptingKey:i,tag:n,time:o}}static getWrapped(e){return this.retrieve(this.collection,e)}static async ensure(e,{device:t=!0,team:a=!0,recovery:r=!1}={}){let i=this.cached(e),n=t&&await bt.getWrapped(e);return n?i||=new bt(e):a&&(n=await Et.getWrapped(e))?i||=new Et(e):r&&(n=await mt.getWrapped(e))&&(i||=new mt(e)),i?.cached&&i.cached.protectedHeader.iat===n.protectedHeader.iat&&i.cached.text===n.text&&i.decryptingKey&&i.signingKey?i:n?(i.cached=n,i.unwrap(i.cached).then((e=>Object.assign(i,e)),(e=>(this.clear(i.tag),wt((e=>`You do not have access to the private key for ${e}.`),i.tag,e))))):(this.clear(e),ht(e))}static ensure1(e){return Promise.any(e.map((e=>ft.ensure(e)))).catch((async t=>{for(let t of e){let e=await ft.ensure(t,{device:!1,team:!1,recovery:!0}).catch((()=>null));if(e)return e}throw t}))}static async persist(e,t,a,r=Date.now(),i=a){let{signingKey:n}=t,c=await this.wrap(t,a),o=await this.signForStorage({message:c,tag:e,signingKey:n,memberTags:i,time:r,recovery:!0});await this.store(this.collection,e,o)}static async store(e,t,a){return e===bt.collection?lt.isEmptyJWSPayload(a)?vt.remove(t):vt.store(t,a):ft.Storage.store(e,t,a)}static async retrieve(e,t){let a=e===bt.collection?vt.retrieve(t):ft.Storage.retrieve(e,t),r=await a,i=r&&await ft.verifyingKey(t);if(r)return r.signatures&&(i={[t]:i}),await lt.verify(i,r)}}class gt extends ft{static signForStorage({message:e,tag:t,signingKey:a,time:r}){return this.sign(e,{tags:[t],signingKey:a,time:r})}static async wrappingKey(e,t){let a=await this.getSecret(e,t);return lt.generateSecretKey(a)}static async wrap(e,t=""){let{decryptingKey:a,signingKey:r,tag:i}=e,n={decryptingKey:a,signingKey:r},c=await this.wrappingKey(i,t);return lt.wrapKey(n,c,{prompt:t})}async unwrap(e){let t=e.json||e.text,a=lt.decodeProtectedHeader(t).prompt,r=await this.constructor.wrappingKey(this.tag,a),i=(await lt.decrypt(r,t)).json;return await lt.importJWK(i,{decryptingKey:"decrypt",signingKey:"sign"})}static async getSecret(e,t){return ft.getUserDeviceSecret(e,t)}}class mt extends gt{static collection="KeyRecovery"}class bt extends gt{static collection="Device"}const vt=new ut({collectionName:bt.collection});class Et extends ft{static collection="Team";static signForStorage({message:e,tag:t,...a}){return this.sign(e,{team:t,...a})}static async wrap(e,t){let{decryptingKey:a,signingKey:r}=e,i={decryptingKey:a,signingKey:r},n={};return await Promise.all(t.map((e=>ft.encryptingKey(e).then((t=>n[e]=t))))),await lt.wrapKey(i,n)}async unwrap(e){let{recipients:t}=e.json,a=this.memberTags=t.map((e=>e.header.kid)),r=await this.constructor.ensure1(a),i=await r.decrypt(e.json);return await lt.importJWK(i.json)}async changeMembership({add:e=[],remove:t=[]}={}){let{memberTags:a}=this,r=a.concat(e).filter((e=>!t.includes(e)));await this.constructor.persist(this.tag,this,r,Date.now(),a),this.memberTags=r}}const St={get KeySet(){return ft},set Storage(e){ft.Storage=e},get Storage(){return ft.Storage},set getUserDeviceSecret(e){ft.getUserDeviceSecret=e},get getUserDeviceSecret(){return ft.getUserDeviceSecret},ready:{name:"@ki1r0y/distributed-security",version:"1.0.7",origin:ft.Storage.origin},async encrypt(e,...t){let a={},r=this.canonicalizeParameters(t,a),i=await ft.produceKey(r,(e=>ft.encryptingKey(e)),a);return lt.encrypt(i,e,a)},async decrypt(e,...t){let a={},[r]=this.canonicalizeParameters(t,a,e),{recovery:i,...n}=a;return(await ft.ensure(r,{recovery:i})).decrypt(e,n)},async sign(e,...t){let a={},r=this.canonicalizeParameters(t,a);return ft.sign(e,{tags:r,...a})},async verify(e,...t){let a={},r=this.canonicalizeParameters(t,a,e);return ft.verify(e,r,a)},async create(...e){if(!e.length)return await bt.create();let t=e[0].prompt;return t?await mt.create(t):await Et.create(e)},changeMembership:async({tag:e,recovery:t=!1,...a})=>(await ft.ensure(e,{recovery:t,...a})).changeMembership(a),async destroy(e){"string"==typeof e&&(e={tag:e});let{tag:t,recovery:a=!0,...r}=e,i={recovery:a,...r};return(await ft.ensure(t,i)).destroy(i)},clear(e){ft.clear(e)},decodeProtectedHeader:lt.decodeProtectedHeader,hashBuffer:Ne,hashText:Fe,encodeBase64url:ze,decodeBase64url:qe,canonicalizeParameters(e,t,a){if(e.length>1||void 0!==e[0]?.length)return e;let{tags:r=[],contentType:i,time:n,...c}=e[0]||{},{team:o}=c;if(!r.length)if(e.length&&e[0].length)r=e;else if(a)if(a.signatures)r=a.signatures.map((e=>this.decodeProtectedHeader(e).kid));else if(a.recipients)r=a.recipients.map((e=>e.header.kid));else{let e=this.decodeProtectedHeader(a).kid;e&&(r=[e])}return o&&!r.includes(o)&&(r=[o,...r]),i&&(t.cty=i),n&&(t.iat=n),Object.assign(t,c),r}};let xt="secret",Kt=xt;async function At(e){Kt="other",await e(),Kt=xt}function Ht(e,t=""){return t+Kt}async function Bt(e){const t=(new TextEncoder).encode(e),a=await o.subtle.digest("SHA-256",t),r=new Uint8Array(a),i=Array.from(r,(e=>String.fromCodePoint(e))).join("");return btoa(i).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}"undefined"!=typeof window&&Object.assign(window,{Security:rt,Krypto:pt,MultiKrypto:lt,Storage:e}),describe("Distributed Security",(function(){let t=ct(),a=rt.Storage,r=rt.getUserDeviceSecret;beforeAll((function(){e.Security=rt,rt.Storage=e,rt.getUserDeviceSecret=Ht,St.Storage=e,St.getUserDeviceSecret=Ht})),afterAll((function(){rt.Storage=a,rt.getUserDeviceSecret=r})),describe("Krypto",(function(){yt(pt)})),describe("MultiKrypto",(function(){!function(e){const t=2e4,a=ct();describe("falls through to krypto with single keys",(function(){yt(e,nt)})),describe("multi-way keys",(function(){describe("multi-signature",(function(){let t,r;beforeAll((async function(){t=await e.generateSigningKey(),r=await e.generateSigningKey()})),it("is a multi-signature.",(async function(){let i={a:t.privateKey,b:r.privateKey},n={b:r.publicKey,a:t.publicKey},c=await e.sign(i,a),o=await e.verify(n,c);expect(o).toBeTruthy()})),it('can specify type:"multi" in the signing key for clarify.',(async function(){let i={a:t.privateKey,b:r.privateKey,type:"multi"},n={a:t.publicKey,b:r.publicKey},c=await e.sign(i,a),o=await e.verify(n,c);expect(o).toBeTruthy()})),it('can specify type:"multi" in the verifying key for clarify.',(async function(){let i={a:t.privateKey,b:r.privateKey},n={a:t.publicKey,b:r.publicKey,type:"multi"},c=await e.sign(i,a),o=await e.verify(n,c);expect(o).toBeTruthy()})),it("can specify iss, act, iat in the key, which will appear in the signature.",(async function(){let i=Date.now(),n={a:t.privateKey,b:r.privateKey},c={a:t.publicKey,b:r.publicKey},o=await e.sign(n,a,{iss:"a",act:"b",iat:i}),s=await e.verify(c,o);expect(s).toBeTruthy(),o.signatures.forEach((t=>{let a=e.decodeProtectedHeader(t);expect(a.iss).toBe("a"),expect(a.act).toBe("b"),expect(a.iat).toBe(i)}))})),it("can sign binary and it is recovery as binary from payload property of verfication.",(async function(){let a=new Uint8Array([1],[2],[3]),i=await e.sign({a:t.privateKey,b:r.privateKey},a),n=await e.verify({a:t.publicKey,b:r.publicKey},i);expect(n.payload).toEqual(a)})),it("can sign string type and it is recoverable as string from text property of verification.",(async function(){let a="a string",i=await e.sign({a:t.privateKey,b:r.privateKey},a),n=await e.verify({a:t.publicKey,b:r.publicKey},i);expect(n.text).toEqual(a),expect(n.payload).toEqual((new TextEncoder).encode(a))})),it("can sign a jsonable object and it is recovery as same from json property of result.",(async function(){let a={foo:"a string",bar:!1,baz:["a",2,null]},i=await e.sign({a:t.privateKey,b:r.privateKey},a),n=await e.verify({a:t.publicKey,b:r.publicKey},i);expect(n.json).toEqual(a),expect(n.payload).toEqual((new TextEncoder).encode(JSON.stringify(a)))})),it("can specify a specific cty that will pass through to verify.",(async function(){let a={foo:"a string",bar:!1,baz:["a",2,null]},i="application/foo+json",n=await e.sign({a:t.privateKey,b:r.privateKey},a,{cty:i}),c=await e.verify({a:t.publicKey,b:r.publicKey},n);expect(c.json).toEqual(a),expect(c.protectedHeader.cty).toBe(i),expect(c.payload).toEqual((new TextEncoder).encode(JSON.stringify(a)))})),it("fails verification if the signature is mislabeled.",(async function(){let i={a:r.privateKey,b:t.privateKey},n={a:t.publicKey,b:r.publicKey},c=await e.sign(i,a),o=await e.verify(n,c);expect(o).toBeUndefined()})),it("gives enough information that we can tell if a verifying sub key is missing.",(async function(){let i={a:t.privateKey,b:r.privateKey},n={b:r.publicKey},c=await e.sign(i,a),o=await e.verify(n,c);expect(o.payload).toBeTruthy(),expect(o.text).toBe(a),expect(o.signers[1].payload).toBeTruthy(),expect(o.signers[0].payload).toBeUndefined()})),it("gives enough information that we can tell if a signature sub key is missing.",(async function(){let i={a:t.privateKey},n={a:t.publicKey,b:r.publicKey},c=await e.sign(i,a),o=await e.verify(n,c);expect(o.payload).toBeTruthy(),expect(o.text).toBe(a),expect(o.signers.length).toBe(1),expect(o.signers[0].protectedHeader.kid).toBe("a"),expect(o.signers[0].payload).toBeTruthy()}))})),describe("multi-way encryption",(function(){let r,i,n,c,o,s,d="shh!";beforeAll((async function(){n=await e.generateSymmetricKey(),i=await e.generateEncryptingKey(),r=await e.encrypt({a:n,b:i.publicKey,c:d},a),c=r.recipients;let t=await e.generateEncryptingKey();o={a:i.publicKey,b:t.publicKey},s={a:i.privateKey,b:t.privateKey}}),t),it("works with symmetric members.",(async function(){let t=await e.decrypt({a:n},r);expect(t.text).toBe(a),expect(c[0].header.kid).toBe("a"),expect(c[0].header.alg).toBe("A256GCMKW")})),it("works with keypair members.",(async function(){let t=await e.decrypt({b:i.privateKey},r);expect(t.text).toBe(a),expect(c[1].header.kid).toBe("b"),expect(c[1].header.alg).toBe("RSA-OAEP-256")})),it("works with secret text members.",(async function(){let t=await e.decrypt({c:d},r);expect(t.text).toBe(a),expect(c[2].header.kid).toBe("c"),expect(c[2].header.alg).toBe("PBES2-HS512+A256KW")})),it("handles binary, and decrypts as same.",(async function(){let t=new Uint8Array([21,31]),a=await e.encrypt(o,t),r=await e.decrypt(s,a),i=e.decodeProtectedHeader(a);expect(i.cty).toBeUndefined(),dt(r,t)})),it("handles text, and decrypts as same.",(async function(){let t=await e.encrypt(o,a),r=await e.decrypt(s,t),i=e.decodeProtectedHeader(t);expect(i.cty).toBe("text/plain"),expect(r.text).toBe(a)})),it("handles json, and decrypts as same.",(async function(){let t={foo:"bar"},a=await e.encrypt(o,t),r=e.decodeProtectedHeader(a),i=await e.decrypt(s,a);expect(r.cty).toBe("json"),expect(i.json).toEqual(t)})),it("Uses specified headers if supplied, including cty.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await e.encrypt(o,r,{cty:t,iat:a,foo:17}),n=await e.decrypt(s,i),c=e.decodeProtectedHeader(i);expect(c.cty).toBe(t),expect(c.iat).toBe(a),expect(c.foo).toBe(17),expect(n.text).toBe(r)})),it("produces undefined for wrong symmetric key.",(async function(){let t=await e.generateSymmetricKey(),a=await e.decrypt({a:t},r);expect(a).toBeUndefined()})),it("produces undefined for wrong keypair.",(async function(){let t=await e.generateEncryptingKey(),a=await e.decrypt({b:t.privateKey},r);expect(a).toBeUndefined()})),it("produces undefined for wrong secret text.",(async function(){let t=await e.decrypt({c:"shh! "},r);expect(t).toBeUndefined()})),it("produces undefined for mislabeled key.",(async function(){let t=await e.decrypt({a:d},r);expect(t).toBeUndefined()}))}))})),describe("export/wrap",(function(){let r,i;beforeAll((async function(){let t=await e.generateEncryptingKey(),a=await e.generateEncryptingKey(),n=await e.generateEncryptingKey();r={a:t.publicKey,b:a.publicKey},i={c:n.privateKey,b:a.privateKey}}),t),it("exports homogenous member.",(async function(){let t=await e.exportJWK(r),n=await e.importJWK(t),c=await e.encrypt(n,a),o=await e.decrypt(i,c);expect(t.keys[0].kid).toBe("a"),expect(t.keys[1].kid).toBe("b"),expect(o.text).toBe(a)})),it("export heterogenous members.",(async function(){let t=await e.generateEncryptingKey(),a=await e.generateSigningKey(),r=await e.exportJWK({myDecrypt:t.privateKey,mySign:a.privateKey}),i=await e.importJWK(r),n="a smaller message for asymmetric encryption",c=await e.encrypt(t.publicKey,n),o=await e.decrypt(i.myDecrypt,c),s=await e.sign(i.mySign,n);expect(r.keys[0].kid).toBe("myDecrypt"),expect(r.keys[1].kid).toBe("mySign"),expect(o.text).toBe(n),expect(await e.verify(a.publicKey,s)).toBeTruthy()}),1e4),it("can wrap/unwrap a simple key.",(async function(){let t=await e.generateSymmetricKey(),n=await e.wrapKey(t,r),c=await e.unwrapKey(n,i),o=await e.encrypt(c,a),s=await e.decrypt(t,o);expect(s.text).toBe(a)})),it("can be wrapped/unwrapped by a symmetric key with homogenous members.",(async function(){let t=await e.generateSymmetricKey(),n=await e.wrapKey(r,t),c=await e.unwrapKey(n,t),o=await e.encrypt(c,a),s=await e.decrypt(i,o);expect(s.text).toBe(a)})),it("can wrap/unwrap a symmetric multikey with homogenous members.",(async function(){let t={x:await e.generateSymmetricKey(),y:await e.generateSymmetricKey()},a=await e.wrapKey(t,r),n=await e.unwrapKey(a,i),c=ct(),o=await e.encrypt(n,c),s=await e.decrypt(t,o);expect(s.text).toBe(c)})),it("can wrap/unwrap a heterogeneous multikey.",(async function(){let t=await e.generateEncryptingKey(),a=await e.generateSigningKey(),n=await e.wrapKey({myDecrypt:t.privateKey,mySign:a.privateKey},r),c=await e.unwrapKey(n,i),o="a shorter message",s=await e.encrypt(t.publicKey,o),d=await e.decrypt(c.myDecrypt,s),y=await e.sign(c.mySign,o);expect(d.text).toBe(o),expect(await e.verify(a.publicKey,y)).toBeTruthy()}),t)}))}(lt)})),describe("Security",(function(){const a=6e4;async function r(e){let t,a,r={},[i,n,c]=await Promise.all([e.create(),e.create({prompt:"what?"}),e.create({prompt:"nope!"})]);await At((async function(){t=await e.create(),a=await e.create(t)}));let o=await e.create(i),[s,d]=await Promise.all([e.create(o,a),e.create(a,o)]);return r.device=i,r.otherDevice=t,r.recovery=n,r.otherRecovery=c,r.user=o,r.otherUser=a,r.team=s,r.otherTeam=d,r}async function i(e,t){await e.destroy(t.otherTeam),await e.destroy(t.team),await e.destroy(t.user),await e.destroy(t.device),await e.destroy(t.recovery),await e.destroy(t.otherRecovery),await At((async function(){await e.destroy(t.otherUser),await e.destroy(t.otherDevice)}))}describe("internal machinery",(function(){let n;function c(a,r,i={}){describe(a,(function(){let a,c;beforeAll((async function(){c=n[r],a=await ft.ensure(c,{recovery:!0})})),it("tag is exported verify key, and sign() pairs with it.",(async function(){let e=await lt.importRaw(c),a=await lt.exportRaw(e);expect(typeof c).toBe("string"),expect(a).toBe(c);let r=await ft.ensure(c,{recovery:!0}),n=await ft.sign(t,{tags:[c],signingKey:r.signingKey,...i}),o=await lt.verify(e,n);st(n),expect(o).toBeTruthy()})),it("public encryption tag can be retrieved externally, and vault.decrypt() pairs with it.",(async function(){let r=a.tag,n=await e.retrieve("EncryptionKey",r),c=await rt.verify(n,r),o=await lt.importJWK(c.json),s=await lt.encrypt(o,t),d=await a.decrypt(s,i);expect(d.text).toBe(t)}))}))}beforeAll((async function(){n=await r(St)}),a),afterAll((async function(){await i(St,n)}),a),c("DeviceKeySet","device"),c("RecoveryKeySet","recovery",{recovery:!0}),c("TeamKeySet","user"),describe("local store",(function(){var e;beforeAll((async function(){e=new ut({dbName:"testStore",collectionName:"Foo"}),await new Promise((e=>setTimeout(e,2e3)))})),it("can remove without existing.",(async function(){expect(await e.remove("nonExistant")).toBe("")})),it("can retrieve without existing.",(async function(){expect(await e.retrieve("nonExistant")).toBe("")})),it("retrieves and can remove what is stored.",(async function(){let t="x",a="hello";expect(await e.store(t,a)).not.toBeUndefined(),expect(await e.retrieve(t)).toBe(a),expect(await e.remove(t)).toBe(""),expect(await e.retrieve(t)).toBe("")})),it("can write a lot without getting jumbled.",(async function(){let t,a,r,i=1e3,n=[];for(let e=0;e<i;e++)n.push("y"+e);t=Date.now();let c=await Promise.all(n.map(((t,a)=>e.store(t,a.toString()))));a=Date.now()-t,r=a/i,expect(r).toBeLessThan(60),c.forEach((e=>expect(e).not.toBeUndefined())),t=Date.now();let o=await Promise.all(n.map((t=>e.retrieve(t))));a=Date.now()-t,r=a/i,expect(r).toBeLessThan(3),o.forEach(((e,t)=>expect(e).toBe(t.toString()))),t=Date.now();let s=await Promise.all(n.map((t=>e.remove(t))));a=Date.now()-t,r=a/i,expect(r).toBeLessThan(8),s.forEach((e=>expect(e).toBe(""))),t=Date.now();let d=await Promise.all(n.map((t=>e.retrieve(t))));a=Date.now()-t,r=a/i,expect(r).toBeLessThan(.1),d.forEach((e=>expect(e).toBe("")))}),15e5)}))})),describe("API",(function(){let n;function c(e,a,r,i,c={}){describe(e,(function(){let e,o;beforeAll((function(){e=n[a],o=n[r]})),describe("signature",(function(){describe("of one tag",(function(){it("can sign and be verified.",(async function(){let a=await rt.sign(t,{tags:[e],...c});st(a),expect(await rt.verify(a,e)).toBeTruthy()})),it("can be verified with the tag included in the signature.",(async function(){let a=await rt.sign(t,{tags:[e],...c});expect(await rt.verify(a)).toBeTruthy()})),it("cannot sign for a different key.",(async function(){let a=await rt.sign(t,{tags:[o],...c});expect(await rt.verify(a,e)).toBeUndefined()})),it("cannot sign with an unowned key.",(async function(){expect(await rt.sign("something",{tags:n[i],...c}).catch((()=>{}))).toBeUndefined()})),it("distinguishes between correctly signing false and key failure.",(async function(){let t=await rt.sign(!1,{tags:[e],...c}),a=await rt.verify(t,e);expect(a.json).toBe(!1)})),it("can sign text and produce verified result with text property.",(async function(){let a=await rt.sign(t,{tags:[e],...c}),r=await rt.verify(a,e);st(a),expect(r.text).toBe(t)})),it("can sign json and produce verified result with json property.",(async function(){let t={x:1,y:["abc",null,!1]},a=await rt.sign(t,{tags:[e],...c}),r=await rt.verify(a,e);st(a),expect(r.json).toEqual(t)})),it("can sign binary and produce verified result with payload property.",(async function(){let t=new Uint8Array([1,2,3]),a=await rt.sign(t,{tags:[e],...c}),r=await rt.verify(a,e);st(a),expect(r.payload).toEqual(t)})),it("uses contentType and time if supplied.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await rt.sign(r,{tags:[e],contentType:t,time:a,...c}),n=await rt.verify(i,e);st(i),expect(n.text).toEqual(r),expect(n.protectedHeader.cty).toBe(t),expect(n.protectedHeader.iat).toBe(a)})),describe('includes payload hash as "sub" header',(function(){it("by default.",(async function(){let t=await rt.sign("foo",{tags:[e],...c}),a=await rt.verify(t);expect(a.protectedHeader.sub).toBe(await Bt("foo"))})),it("unless specified otherwise.",(async function(){let t=await rt.sign("foo",{subject:"bar",tags:[e],...c}),a=await rt.verify(t),r=await rt.sign("foo",{subject:!1,tags:[e],...c}),i=await rt.verify(r);expect(a.protectedHeader.sub).toBe("bar"),expect(i.protectedHeader.sub).toBeUndefined()}))}))})),describe("of multiple tags",(function(){it("can sign and be verified.",(async function(){let a=await rt.sign(t,{tags:[e,o],...c}),r=await rt.verify(a,o,e);expect(r).toBeTruthy(),expect(r.signers[0].payload).toBeTruthy(),expect(r.signers[1].payload).toBeTruthy()})),it("does not attempt to verify unenumerated tags if any are explicit",(async function(){let a=await rt.sign(t,{tags:[e,o],...c}),r=await rt.verify(a,o);expect(r).toBeTruthy(),expect(r.signers[0].payload).toBeFalsy(),expect(r.signers[1].payload).toBeTruthy()})),it("can be verified with the tag included in the signature.",(async function(){let a=await rt.sign(t,{tags:[e,o],...c}),r=await rt.verify(a);expect(r).toBeTruthy(),expect(r.signers[0].payload).toBeTruthy(),expect(r.signers[1].payload).toBeTruthy()})),describe("bad verification",(function(){let a;beforeAll((async function(){a=await rt.create()})),afterAll((async function(){await rt.destroy(a)})),describe("when mixing single and multi-tags",(function(){it("fails with extra signing tag.",(async function(){let a=await rt.sign(t,{tags:[o],...c});expect(await rt.verify(a,e)).toBeUndefined()})),it("fails with extra verifying.",(async function(){let a=await rt.sign(t,{tags:[e],...c});expect(await rt.verify(a,e,o)).toBeUndefined()}))})),describe("when mixing multi-tag lengths",(function(){it("fails with mismatched signing tag.",(async function(){let r=await rt.sign(t,{tags:[o,a],...c}),i=await rt.verify(r,e,a);expect(i).toBeUndefined()})),it("fails with extra verifying tag.",(async function(){let r=await rt.sign(t,{tags:[e,a],...c});expect(await rt.verify(r,e,o,a)).toBeUndefined()}))}))})),it("distinguishes between correctly signing false and key failure.",(async function(){let t=await rt.sign(!1,{tags:[e,o],...c}),a=await rt.verify(t,e,o);expect(a.json).toBe(!1)})),it("can sign text and produce verified result with text property.",(async function(){let a=await rt.sign(t,{tags:[e,o],...c}),r=await rt.verify(a,e,o);expect(r.text).toBe(t)})),it("can sign json and produce verified result with json property.",(async function(){let t={x:1,y:["abc",null,!1]},a=await rt.sign(t,{tags:[e,o],...c}),r=await rt.verify(a,e,o);expect(r.json).toEqual(t)})),it("can sign binary and produce verified result with payload property.",(async function(){let t=new Uint8Array([1,2,3]),a=await rt.sign(t,{tags:[e,o],...c}),r=await rt.verify(a,e,o);expect(r.payload).toEqual(t)})),it("uses contentType and time if supplied.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await rt.sign(r,{tags:[e,o],contentType:t,time:a,...c}),n=await rt.verify(i,e,o);expect(n.text).toEqual(r),expect(n.protectedHeader.cty).toBe(t),expect(n.protectedHeader.iat).toBe(a)})),describe('includes payload hash as "sub" header',(function(){it("by default.",(async function(){let t=await rt.sign("foo",{tags:[e,o],...c}),a=await rt.verify(t);expect(a.protectedHeader.sub).toBe(await Bt("foo"))})),it("unless specified otherwise.",(async function(){let t=await rt.sign("foo",{tags:[e,o],subject:"bar",...c}),a=await rt.verify(t),r=await rt.sign("foo",{tags:[e,o],subject:!1,...c}),i=await rt.verify(r);expect(a.protectedHeader.sub).toBe("bar"),expect(i.protectedHeader.sub).toBeUndefined()}))}))}))})),describe("encryption",(function(){describe("with a single tag",(function(){it("can decrypt what is encrypted for it.",(async function(){let a=await rt.encrypt(t,e),r=await rt.decrypt(a,{tags:[e],...c});st(a),expect(r.text).toBe(t)})),it("can be decrypted using the tag included in the encryption.",(async function(){let a=await rt.encrypt(t,e),r=await rt.decrypt(a,c);expect(r.text).toBe(t)})),it("is url-safe base64.",(async function(){st(await rt.encrypt(t,e))})),it("specifies kid.",(async function(){let a=pt.decodeProtectedHeader(await rt.encrypt(t,e));expect(a.kid).toBe(e)})),it("cannot decrypt what is encrypted for a different key.",(async function(){let t=ct(446),a=await rt.encrypt(t,o),r=await rt.decrypt(a,{tags:[e],...c}).catch((e=>e.message));expect(r.toLowerCase()).toContain("operation")})),it("handles binary, and decrypts as same.",(async function(){let t=new Uint8Array([21,31]),a=await rt.encrypt(t,e),r=await rt.decrypt(a,{tags:[e],...c}),i=pt.decodeProtectedHeader(a);expect(i.cty).toBeUndefined(),dt(r,t)})),it("handles text, and decrypts as same.",(async function(){let a=await rt.encrypt(t,e),r=await rt.decrypt(a,{tags:[e],...c}),i=pt.decodeProtectedHeader(a);expect(i.cty).toBe("text/plain"),expect(r.text).toBe(t)})),it("handles json, and decrypts as same.",(async function(){let t={foo:"bar"},a=await rt.encrypt(t,e),r=await rt.decrypt(a,{tags:[e],...c}),i=pt.decodeProtectedHeader(a);expect(i.cty).toBe("json"),expect(r.json).toEqual(t)})),it("uses contentType and time if supplied.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await rt.encrypt(r,{tags:[e],contentType:t,time:a}),n=await rt.decrypt(i,{tags:[e],...c}),o=pt.decodeProtectedHeader(i);expect(o.cty).toBe(t),expect(o.iat).toBe(a),expect(n.text).toBe(r)}))})),describe("with multiple tags",(function(){it("can be decrypted by any one of them.",(async function(){let a=await rt.encrypt(t,e,o),r=await rt.decrypt(a,{tags:[e],...c}),i=await rt.decrypt(a,{tags:[o],...c});expect(r.text).toBe(t),expect(i.text).toBe(t)})),it("can be decrypted using the tag included in the encryption.",(async function(){let a=await rt.encrypt(t,e,o),r=await rt.decrypt(a,c);expect(r.text).toBe(t)})),it("can be be made with tags you do not own.",(async function(){let a=await rt.encrypt(t,e,n[i],o),r=await rt.decrypt(a,{tags:[e],...c}),s=await rt.decrypt(a,{tags:[o],...c});expect(r.text).toBe(t),expect(s.text).toBe(t)})),it("cannot be decrypted by a different tag.",(async function(){let a=await rt.encrypt(t,e,n[i]),r=await rt.decrypt(a,{tags:[o],...c});expect(r).toBeUndefined()})),it("specifies kid in each recipient.",(async function(){let a=(await rt.encrypt(t,e,o)).recipients;expect(a.length).toBe(2),expect(a[0].header.kid).toBe(e),expect(a[1].header.kid).toBe(o)})),it("handles binary, and decrypts as same.",(async function(){let t=new Uint8Array([21,31]),a=await rt.encrypt(t,e,o),r=await rt.decrypt(a,{tags:[e],...c}),i=pt.decodeProtectedHeader(a);expect(i.cty).toBeUndefined(),dt(r,t)})),it("handles text, and decrypts as same.",(async function(){let a=await rt.encrypt(t,e,o),r=await rt.decrypt(a,{tags:[e],...c}),i=pt.decodeProtectedHeader(a);expect(i.cty).toBe("text/plain"),expect(r.text).toBe(t)})),it("handles json, and decrypts as same.",(async function(){let t={foo:"bar"},a=await rt.encrypt(t,e,o),r=await rt.decrypt(a,{tags:[e],...c}),i=pt.decodeProtectedHeader(a);expect(i.cty).toBe("json"),expect(r.json).toEqual(t)})),it("uses contentType and time if supplied.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await rt.encrypt(r,{tags:[e,o],contentType:t,time:a}),n=await rt.decrypt(i,{tags:[e],...c}),s=pt.decodeProtectedHeader(i);expect(s.cty).toBe(t),expect(s.iat).toBe(a),expect(n.text).toBe(r)}))}))}))}))}beforeAll((async function(){console.log(await rt.ready),n=await r(rt)}),a),afterAll((async function(){await i(rt,n)}),a),c("DeviceKeySet","device","user","otherDevice"),c("RecoveryKeySet","recovery","otherRecovery","otherDevice",{recovery:!0}),c("User TeamKeySet","user","device","otherUser"),c("Team TeamKeySet","team","otherTeam","otherUser"),describe("storage",(function(){it("will only let a current member write new keys.",(async function(){let t=await rt.create(),a=n.team,r=await e.retrieve("Team",a),i=await rt.verify(r),c=i?.json;if(!i)throw new Error(`Unable to verify '${r?.text}'`);function o(){return rt.sign(c,{team:a,member:t,time:Date.now()})}await rt.changeMembership({tag:a,add:[t]});let s=await o();expect(await e.store("Team",n.team,s)).toBeDefined(),await rt.changeMembership({tag:a,remove:[t]});let d=await o();expect(await e.store("Team",a,d).catch((()=>"failed"))).toBe("failed"),expect(await e.store("Team",a,s).catch((()=>"failed"))).toBe("failed"),expect(await e.store("Team",a,r).catch((()=>"failed"))).toBe("failed"),await rt.destroy(t)})),it("will only let a current member write new public encryption key.",(async function(){let t=await rt.create(),a=n.team,r=await e.retrieve("EncryptionKey",a),i=(await rt.verify(r)).json;function c(){return rt.sign(i,{team:a,member:t,time:Date.now()})}await rt.changeMembership({tag:a,add:[t]});let o=await c();expect(await e.store("EncryptionKey",n.team,o)).toBeDefined(),await rt.changeMembership({tag:a,remove:[t]});let s=await c();expect(await e.store("EncryptionKey",a,s).catch((()=>"failed"))).toBe("failed"),expect(await e.store("EncryptionKey",a,o).catch((()=>"failed"))).toBe("failed"),expect(await e.store("EncryptionKey",a,r).catch((()=>"failed"))).toBe("failed"),await rt.destroy(t)}),1e4),it("will only let owner of a device write new public device encryption key.",(async function(){let t=await rt.create(),a=await rt.create(),r=await e.retrieve("EncryptionKey",t),i=(await rt.verify(r)).json;function n(e){return rt.sign(i,{tags:[e],time:Date.now()})}let c=await n(t);expect(await e.store("EncryptionKey",t,c)).toBeDefined();let o=await n(a);expect(await e.store("EncryptionKey",t,o).catch((()=>"failed"))).toBe("failed"),expect(await e.store("EncryptionKey",t,c)).toBeDefined,expect(await e.store("EncryptionKey",t,r).catch((()=>"failed"))).toBe("failed"),await rt.destroy(t),await rt.destroy(a)}),1e4)})),describe("auditable signatures",(function(){describe("by an explicit member",(function(){let e,a;beforeAll((async function(){e=await rt.sign(t,{team:n.team,member:n.user}),a=await rt.verify(e,n.team,n.user)})),it("recognizes a team with a member.",(async function(){expect(a).toBeTruthy(),expect(a.text).toBe(t)})),it("defines iss.",(function(){expect(a.protectedHeader.iss).toBe(n.team)})),it("defines act.",(function(){expect(a.protectedHeader.act).toBe(n.user)}))})),describe("automatically supplies a valid member",(function(){it("if you have access",(async function(){let e=await rt.sign(t,{team:n.team}),a=pt.decodeProtectedHeader(e.signatures[0]).act,r=await rt.verify(e,n.team,a);expect(r).toBeTruthy(),expect(a).toBeTruthy(),expect(r.protectedHeader.act).toBe(a),expect(r.protectedHeader.iat).toBeTruthy()}))})),describe("with a valid user who is not a member",(function(){let e;beforeAll((async function(){e=await rt.create(n.device)})),afterAll((async function(){await rt.destroy(e)})),it("verifies as an ordinary dual signature.",(async function(){let a=await rt.sign(t,n.team,e),r=await rt.verify(a,n.team,e);expect(r.text).toBe(t),expect(r.protectedHeader.iss).toBeUndefined(),expect(r.protectedHeader.act).toBeUndefined()}),1e4),it("does not verify as a dual signature specifying team and member.",(async function(){let a=await rt.sign(t,{team:n.team,member:e}),r=await rt.verify(a,n.team,e);expect(r).toBeUndefined()}))}),1e4),describe("with a past member",(function(){let e,t,a;beforeAll((async function(){a=Date.now()-1,e=await rt.create(),await rt.changeMembership({tag:n.team,add:[e]}),t=await rt.sign("message",{team:n.team,member:e,time:a}),await rt.changeMembership({tag:n.team,remove:[e]})})),afterAll((async function(){await rt.destroy(e)})),it("fails by default.",(async function(){let a=await rt.verify(t,e);expect(a).toBeUndefined()})),it("contains act in signature but verifies if we tell it not to check membership.",(async function(){let a=await rt.verify(t,{team:n.team,member:!1});expect(a).toBeTruthy(),expect(a.text).toBe("message"),expect(a.protectedHeader.act).toBe(e),expect(a.protectedHeader.iat).toBeTruthy()})),it('fails if we tell it to check notBefore:"team", even if we tell it not to check membership.',(async function(){let e=await rt.verify(t,{team:n.team,member:!1,notBefore:"team"});expect(e).toBeUndefined()}))}))})),describe("miscellaneous",(function(){it("can safely be used when a device is removed, but not after being entirely destroyed.",(async function(){let[e,a]=await Promise.all([rt.create(),rt.create()]),r=await rt.create(e,a),i=await rt.create(r),n=await rt.encrypt(t,i),c=await rt.decrypt(n,i);expect(c.text).toBe(t),c=await rt.decrypt(n,i),await rt.changeMembership({tag:r,remove:[e]}),expect(c.text).toBe(t),await rt.changeMembership({tag:r,add:[e]}),c=await rt.decrypt(n,i),expect(c.text).toBe(t),await rt.destroy(a),c=await rt.decrypt(n,i),expect(c.text).toBe(t),await rt.destroy({tag:i,recursiveMembers:!0});let o=await rt.decrypt(n,i).then((()=>null),(e=>e.message));expect(o).toBeTruthy()}),a),it("device is useable as soon as it resolves.",(async function(){let e=await rt.create();expect(await rt.sign("anything",e)).toBeTruthy(),await rt.destroy(e)}),1e4),it("team is useable as soon as it resolves.",(async function(){let e=await rt.create(n.device);expect(await rt.sign("anything",e)).toBeTruthy(),await rt.destroy(e)})),it("allows recovery prompts that contain dot (and confirm that a team can have a single recovery tag as member).",(async function(){let e=await rt.create({prompt:"foo.bar"}),t=await rt.create(e),a="red.white",r=await rt.encrypt(a,t),i=await rt.decrypt(r,t),n=await rt.sign(a,t),c=await rt.verify(n,t);expect(i.text).toBe(a),expect(c).toBeTruthy(),await rt.destroy({tag:t,recursiveMembers:!0})}),1e4),it("supports rotation.",(async function(){let e=await rt.create(n.device),t=await rt.create(e),a=await rt.sign("some purchase order",{team:t,member:e}),r=await rt.encrypt("the other set of books",t);expect(await rt.verify(a)).toBeTruthy(),expect(await rt.verify(a,{team:t,member:!1})).toBeTruthy(),expect(await rt.decrypt(r)).toBeTruthy();let i=await rt.create(n.device),c=await rt.create(n.device);await rt.changeMembership({tag:t,remove:[e],add:[i,c]}),await rt.destroy(e),expect(await rt.sign("bogus PO",{team:t,member:e}).catch((()=>{}))).toBeUndefined();let o=await rt.sign("new PO",{team:t,member:i}),s=await rt.sign("new PO",{team:t,member:c});expect(await rt.verify(o)).toBeTruthy(),expect(await rt.verify(s)).toBeTruthy(),expect(await rt.verify(a).catch((()=>{}))).toBeUndefined(),expect(await rt.verify(a,{team:t,member:!1})).toBeTruthy(),expect(await rt.decrypt(r)).toBeTruthy();let d=await rt.create(i);await rt.destroy(t),expect(await rt.sign("bogus PO",{team:t,member:i}).catch((()=>{}))).toBeUndefined(),expect(await rt.sign("new new PO",{team:d,member:i})).toBeTruthy(),expect(await rt.verify(a,{team:t,member:!1})).toBeTruthy(),expect(await rt.verify(o)).toBeTruthy(),expect(await rt.verify(s)).toBeTruthy(),expect(await rt.decrypt(r).catch((()=>{}))).toBeUndefined()}),15e3)}))}))}))}));
