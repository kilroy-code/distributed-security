const e={origin:new URL(import.meta.url).origin,async store(e,t,a){let r=await this.Security.verify(a,{team:t,notBefore:"team"});if(!r)throw new Error(`Signature ${a} does not match owner of ${t}.`);return r.payload.length?this[e][t]=a:delete this[e][t],null},async retrieve(e,t){return this[e][t]},Team:{},KeyRecovery:{},EncryptionKey:{}};const t=new URL(import.meta.url).origin;async function a(e){if(404===e.status)return"";if(!e.ok)return Promise.reject(e.statusText);let t=await e.text();return t?JSON.parse(t):t}const r={get origin(){return t},tagPath:function(e,t,a="json"){return t?`${e}/${t}.${a}`:e},uri(e,a){return`${t}/Storage/${this.tagPath(e,a)}`},store(e,t,r,i={}){return fetch(this.uri(e,t),{method:"PUT",body:JSON.stringify(r),headers:{"Content-Type":"application/json",...i.headers||{}}}).then(a)},retrieve(e,t,r={}){return fetch(this.uri(e,t),{cache:"default",headers:{Accept:"application/json",...r.headers||{}}}).then(a)}};var i=e=>e;function n(e,t){return t?e+i(t):e}"undefined"!=typeof window&&(i=window.prompt);var c=crypto,s=crypto;const o=e=>e instanceof CryptoKey,d=async(e,t)=>{const a=`SHA-${e.slice(-3)}`;return new Uint8Array(await s.subtle.digest(a,t))},y=new TextEncoder,p=new TextDecoder,l=2**32;function u(...e){const t=e.reduce(((e,{length:t})=>e+t),0),a=new Uint8Array(t);let r=0;for(const t of e)a.set(t,r),r+=t.length;return a}function h(e,t,a){if(t<0||t>=l)throw new RangeError(`value must be >= 0 and <= 4294967295. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,255&t],a)}function w(e){const t=Math.floor(e/l),a=e%l,r=new Uint8Array(8);return h(r,t,0),h(r,a,4),r}function f(e){const t=new Uint8Array(4);return h(t,e),t}function g(e){return u(f(e.length),e)}const m=e=>(e=>{let t=e;"string"==typeof t&&(t=y.encode(t));const a=[];for(let e=0;e<t.length;e+=32768)a.push(String.fromCharCode.apply(null,t.subarray(e,e+32768)));return btoa(a.join(""))})(e).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),b=e=>{let t=e;t instanceof Uint8Array&&(t=p.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return(e=>{const t=atob(e),a=new Uint8Array(t.length);for(let e=0;e<t.length;e++)a[e]=t.charCodeAt(e);return a})(t)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}};class v extends Error{constructor(e,t){super(e,t),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,Error.captureStackTrace?.(this,this.constructor)}}v.code="ERR_JOSE_GENERIC";(class extends v{constructor(e,t,a="unspecified",r="unspecified"){super(e,{cause:{claim:a,reason:r,payload:t}}),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=a,this.reason=r,this.payload=t}}).code="ERR_JWT_CLAIM_VALIDATION_FAILED";(class extends v{constructor(e,t,a="unspecified",r="unspecified"){super(e,{cause:{claim:a,reason:r,payload:t}}),this.code="ERR_JWT_EXPIRED",this.claim=a,this.reason=r,this.payload=t}}).code="ERR_JWT_EXPIRED";class E extends v{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}}E.code="ERR_JOSE_ALG_NOT_ALLOWED";class S extends v{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}}S.code="ERR_JOSE_NOT_SUPPORTED";class x extends v{constructor(e="decryption operation failed",t){super(e,t),this.code="ERR_JWE_DECRYPTION_FAILED"}}x.code="ERR_JWE_DECRYPTION_FAILED";class K extends v{constructor(){super(...arguments),this.code="ERR_JWE_INVALID"}}K.code="ERR_JWE_INVALID";class A extends v{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}}A.code="ERR_JWS_INVALID";(class extends v{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}}).code="ERR_JWT_INVALID";(class extends v{constructor(){super(...arguments),this.code="ERR_JWK_INVALID"}}).code="ERR_JWK_INVALID";(class extends v{constructor(){super(...arguments),this.code="ERR_JWKS_INVALID"}}).code="ERR_JWKS_INVALID";(class extends v{constructor(e="no applicable key found in the JSON Web Key Set",t){super(e,t),this.code="ERR_JWKS_NO_MATCHING_KEY"}}).code="ERR_JWKS_NO_MATCHING_KEY";(class extends v{constructor(e="multiple matching keys found in the JSON Web Key Set",t){super(e,t),this.code="ERR_JWKS_MULTIPLE_MATCHING_KEYS"}}).code="ERR_JWKS_MULTIPLE_MATCHING_KEYS";(class extends v{constructor(e="request timed out",t){super(e,t),this.code="ERR_JWKS_TIMEOUT"}}).code="ERR_JWKS_TIMEOUT";class H extends v{constructor(e="signature verification failed",t){super(e,t),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}H.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED";var B=s.getRandomValues.bind(s);function k(e){switch(e){case"A128GCM":case"A128GCMKW":case"A192GCM":case"A192GCMKW":case"A256GCM":case"A256GCMKW":return 96;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return 128;default:throw new S(`Unsupported JWE Algorithm: ${e}`)}}const P=(e,t)=>{if(t.length<<3!==k(e))throw new K("Invalid Initialization Vector length")},_=(e,t)=>{const a=e.byteLength<<3;if(a!==t)throw new K(`Invalid Content Encryption Key length. Expected ${t} bits, got ${a} bits`)};function T(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function W(e,t){return e.name===t}function C(e){return parseInt(e.name.slice(4),10)}function U(e,t){if(t.length&&!t.some((t=>e.usages.includes(t)))){let e="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const a=t.pop();e+=`one of ${t.join(", ")}, or ${a}.`}else 2===t.length?e+=`one of ${t[0]} or ${t[1]}.`:e+=`${t[0]}.`;throw new TypeError(e)}}function R(e,t,...a){switch(t){case"HS256":case"HS384":case"HS512":{if(!W(e.algorithm,"HMAC"))throw T("HMAC");const a=parseInt(t.slice(2),10);if(C(e.algorithm.hash)!==a)throw T(`SHA-${a}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!W(e.algorithm,"RSASSA-PKCS1-v1_5"))throw T("RSASSA-PKCS1-v1_5");const a=parseInt(t.slice(2),10);if(C(e.algorithm.hash)!==a)throw T(`SHA-${a}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!W(e.algorithm,"RSA-PSS"))throw T("RSA-PSS");const a=parseInt(t.slice(2),10);if(C(e.algorithm.hash)!==a)throw T(`SHA-${a}`,"algorithm.hash");break}case"EdDSA":if("Ed25519"!==e.algorithm.name&&"Ed448"!==e.algorithm.name)throw T("Ed25519 or Ed448");break;case"ES256":case"ES384":case"ES512":{if(!W(e.algorithm,"ECDSA"))throw T("ECDSA");const a=function(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}(t);if(e.algorithm.namedCurve!==a)throw T(a,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}U(e,a)}function J(e,t,...a){switch(t){case"A128GCM":case"A192GCM":case"A256GCM":{if(!W(e.algorithm,"AES-GCM"))throw T("AES-GCM");const a=parseInt(t.slice(1,4),10);if(e.algorithm.length!==a)throw T(a,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!W(e.algorithm,"AES-KW"))throw T("AES-KW");const a=parseInt(t.slice(1,4),10);if(e.algorithm.length!==a)throw T(a,"algorithm.length");break}case"ECDH":switch(e.algorithm.name){case"ECDH":case"X25519":case"X448":break;default:throw T("ECDH, X25519, or X448")}break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!W(e.algorithm,"PBKDF2"))throw T("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!W(e.algorithm,"RSA-OAEP"))throw T("RSA-OAEP");const a=parseInt(t.slice(9),10)||1;if(C(e.algorithm.hash)!==a)throw T(`SHA-${a}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}U(e,a)}function D(e,t,...a){if((a=a.filter(Boolean)).length>2){const t=a.pop();e+=`one of type ${a.join(", ")}, or ${t}.`}else 2===a.length?e+=`one of type ${a[0]} or ${a[1]}.`:e+=`of type ${a[0]}.`;return null==t?e+=` Received ${t}`:"function"==typeof t&&t.name?e+=` Received function ${t.name}`:"object"==typeof t&&null!=t&&t.constructor?.name&&(e+=` Received an instance of ${t.constructor.name}`),e}var O=(e,...t)=>D("Key must be ",e,...t);function I(e,t,...a){return D(`Key for the ${e} algorithm must be `,t,...a)}var j=e=>!!o(e)||"KeyObject"===e?.[Symbol.toStringTag];const M=["CryptoKey"];async function $(e,t,a,r,i,n){if(!(t instanceof Uint8Array))throw new TypeError(O(t,"Uint8Array"));const c=parseInt(e.slice(1,4),10),o=await s.subtle.importKey("raw",t.subarray(c>>3),"AES-CBC",!1,["decrypt"]),d=await s.subtle.importKey("raw",t.subarray(0,c>>3),{hash:"SHA-"+(c<<1),name:"HMAC"},!1,["sign"]),y=u(n,r,a,w(n.length<<3)),p=new Uint8Array((await s.subtle.sign("HMAC",d,y)).slice(0,c>>3));let l,h;try{l=((e,t)=>{if(!(e instanceof Uint8Array))throw new TypeError("First argument must be a buffer");if(!(t instanceof Uint8Array))throw new TypeError("Second argument must be a buffer");if(e.length!==t.length)throw new TypeError("Input buffers must have the same length");const a=e.length;let r=0,i=-1;for(;++i<a;)r|=e[i]^t[i];return 0===r})(i,p)}catch{}if(!l)throw new x;try{h=new Uint8Array(await s.subtle.decrypt({iv:r,name:"AES-CBC"},o,a))}catch{}if(!h)throw new x;return h}const L=async(e,t,a,r,i,n)=>{if(!(o(t)||t instanceof Uint8Array))throw new TypeError(O(t,...M,"Uint8Array"));if(!r)throw new K("JWE Initialization Vector missing");if(!i)throw new K("JWE Authentication Tag missing");switch(P(e,r),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return t instanceof Uint8Array&&_(t,parseInt(e.slice(-3),10)),$(e,t,a,r,i,n);case"A128GCM":case"A192GCM":case"A256GCM":return t instanceof Uint8Array&&_(t,parseInt(e.slice(1,4),10)),async function(e,t,a,r,i,n){let c;t instanceof Uint8Array?c=await s.subtle.importKey("raw",t,"AES-GCM",!1,["decrypt"]):(J(t,e,"decrypt"),c=t);try{return new Uint8Array(await s.subtle.decrypt({additionalData:n,iv:r,name:"AES-GCM",tagLength:128},c,u(a,i)))}catch{throw new x}}(e,t,a,r,i,n);default:throw new S("Unsupported JWE Content Encryption Algorithm")}},N=(...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let a;for(const e of t){const t=Object.keys(e);if(a&&0!==a.size)for(const e of t){if(a.has(e))return!1;a.add(e)}else a=new Set(t)}return!0};function G(e){if("object"!=typeof(t=e)||null===t||"[object Object]"!==Object.prototype.toString.call(e))return!1;var t;if(null===Object.getPrototypeOf(e))return!0;let a=e;for(;null!==Object.getPrototypeOf(a);)a=Object.getPrototypeOf(a);return Object.getPrototypeOf(e)===a}const z=[{hash:"SHA-256",name:"HMAC"},!0,["sign"]];function F(e,t){if(e.algorithm.length!==parseInt(t.slice(1,4),10))throw new TypeError(`Invalid key size for alg: ${t}`)}function q(e,t,a){if(o(e))return J(e,t,a),e;if(e instanceof Uint8Array)return s.subtle.importKey("raw",e,"AES-KW",!0,[a]);throw new TypeError(O(e,...M,"Uint8Array"))}const V=async(e,t,a)=>{const r=await q(t,e,"wrapKey");F(r,e);const i=await s.subtle.importKey("raw",a,...z);return new Uint8Array(await s.subtle.wrapKey("raw",i,r,"AES-KW"))},X=async(e,t,a)=>{const r=await q(t,e,"unwrapKey");F(r,e);const i=await s.subtle.unwrapKey("raw",a,r,"AES-KW",...z);return new Uint8Array(await s.subtle.exportKey("raw",i))};async function Y(e,t,a,r,i=new Uint8Array(0),n=new Uint8Array(0)){if(!o(e))throw new TypeError(O(e,...M));if(J(e,"ECDH"),!o(t))throw new TypeError(O(t,...M));J(t,"ECDH","deriveBits");const c=u(g(y.encode(a)),g(i),g(n),f(r));let p;p="X25519"===e.algorithm.name?256:"X448"===e.algorithm.name?448:Math.ceil(parseInt(e.algorithm.namedCurve.substr(-3),10)/8)<<3;return async function(e,t,a){const r=Math.ceil((t>>3)/32),i=new Uint8Array(32*r);for(let t=0;t<r;t++){const r=new Uint8Array(4+e.length+a.length);r.set(f(t+1)),r.set(e,4),r.set(a,4+e.length),i.set(await d("sha256",r),32*t)}return i.slice(0,t>>3)}(new Uint8Array(await s.subtle.deriveBits({name:e.algorithm.name,public:e},t,p)),r,c)}function Z(e){if(!o(e))throw new TypeError(O(e,...M));return["P-256","P-384","P-521"].includes(e.algorithm.namedCurve)||"X25519"===e.algorithm.name||"X448"===e.algorithm.name}async function Q(e,t,a,r){!function(e){if(!(e instanceof Uint8Array)||e.length<8)throw new K("PBES2 Salt Input must be 8 or more octets")}(e);const i=function(e,t){return u(y.encode(e),new Uint8Array([0]),t)}(t,e),n=parseInt(t.slice(13,16),10),c={hash:`SHA-${t.slice(8,11)}`,iterations:a,name:"PBKDF2",salt:i},d={length:n,name:"AES-KW"},p=await function(e,t){if(e instanceof Uint8Array)return s.subtle.importKey("raw",e,"PBKDF2",!1,["deriveBits"]);if(o(e))return J(e,t,"deriveBits","deriveKey"),e;throw new TypeError(O(e,...M,"Uint8Array"))}(r,t);if(p.usages.includes("deriveBits"))return new Uint8Array(await s.subtle.deriveBits(c,p,n));if(p.usages.includes("deriveKey"))return s.subtle.deriveKey(c,p,d,!1,["wrapKey","unwrapKey"]);throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"')}function ee(e){switch(e){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return"RSA-OAEP";default:throw new S(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}var te=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:a}=t.algorithm;if("number"!=typeof a||a<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};function ae(e){return G(e)&&"string"==typeof e.kty}const re=async e=>{if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:t,keyUsages:a}=function(e){let t,a;switch(e.kty){case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},a=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},a=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},a=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new S('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},a=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},a=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},a=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},a=e.d?["deriveBits"]:[];break;default:throw new S('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"OKP":switch(e.alg){case"EdDSA":t={name:e.crv},a=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},a=e.d?["deriveBits"]:[];break;default:throw new S('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;default:throw new S('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:a}}(e),r=[t,e.ext??!1,e.key_ops??a],i={...e};return delete i.alg,delete i.use,s.subtle.importKey("jwk",i,...r)},ie=e=>b(e);let ne,ce;const se=e=>"KeyObject"===e?.[Symbol.toStringTag],oe=async(e,t,a,r,i=!1)=>{let n=e.get(t);if(n?.[r])return n[r];const c=await re({...a,alg:r});return i&&Object.freeze(t),n?n[r]=c:e.set(t,{[r]:c}),c};var de=(e,t)=>{if(se(e)){let a=e.export({format:"jwk"});return delete a.d,delete a.dp,delete a.dq,delete a.p,delete a.q,delete a.qi,a.k?ie(a.k):(ce||(ce=new WeakMap),oe(ce,e,a,t))}if(ae(e)){if(e.k)return b(e.k);ce||(ce=new WeakMap);return oe(ce,e,e,t,!0)}return e},ye=(e,t)=>{if(se(e)){let a=e.export({format:"jwk"});return a.k?ie(a.k):(ne||(ne=new WeakMap),oe(ne,e,a,t))}if(ae(e)){if(e.k)return b(e.k);ne||(ne=new WeakMap);return oe(ne,e,e,t,!0)}return e};function pe(e){switch(e){case"A128GCM":return 128;case"A192GCM":return 192;case"A256GCM":case"A128CBC-HS256":return 256;case"A192CBC-HS384":return 384;case"A256CBC-HS512":return 512;default:throw new S(`Unsupported JWE Algorithm: ${e}`)}}var le=e=>B(new Uint8Array(pe(e)>>3));async function ue(e,t){if(!G(e))throw new TypeError("JWK must be an object");switch(t||(t=e.alg),e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return b(e.k);case"RSA":if(void 0!==e.oth)throw new S('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return re({...e,alg:t});default:throw new S('Unsupported "kty" (Key Type) Parameter value')}}const he=e=>e?.[Symbol.toStringTag],we=(e,t,a)=>{if(void 0!==t.use&&"sig"!==t.use)throw new TypeError("Invalid key for this operation, when present its use must be sig");if(void 0!==t.key_ops&&!0!==t.key_ops.includes?.(a))throw new TypeError(`Invalid key for this operation, when present its key_ops must include ${a}`);if(void 0!==t.alg&&t.alg!==e)throw new TypeError(`Invalid key for this operation, when present its alg must be ${e}`);return!0},fe=(e,t,a,r)=>{if(!(t instanceof Uint8Array)){if(r&&ae(t)){if(function(e){return ae(e)&&"oct"===e.kty&&"string"==typeof e.k}(t)&&we(e,t,a))return;throw new TypeError('JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present')}if(!j(t))throw new TypeError(I(e,t,...M,"Uint8Array",r?"JSON Web Key":null));if("secret"!==t.type)throw new TypeError(`${he(t)} instances for symmetric algorithms must be of type "secret"`)}};function ge(e,t,a,r){t.startsWith("HS")||"dir"===t||t.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(t)?fe(t,a,r,e):((e,t,a,r)=>{if(r&&ae(t))switch(a){case"sign":if(function(e){return"oct"!==e.kty&&"string"==typeof e.d}(t)&&we(e,t,a))return;throw new TypeError("JSON Web Key for this operation be a private JWK");case"verify":if(function(e){return"oct"!==e.kty&&void 0===e.d}(t)&&we(e,t,a))return;throw new TypeError("JSON Web Key for this operation be a public JWK")}if(!j(t))throw new TypeError(I(e,t,...M,r?"JSON Web Key":null));if("secret"===t.type)throw new TypeError(`${he(t)} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===a&&"public"===t.type)throw new TypeError(`${he(t)} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===a&&"public"===t.type)throw new TypeError(`${he(t)} instances for asymmetric algorithm decryption must be of type "private"`);if(t.algorithm&&"verify"===a&&"private"===t.type)throw new TypeError(`${he(t)} instances for asymmetric algorithm verifying must be of type "public"`);if(t.algorithm&&"encrypt"===a&&"private"===t.type)throw new TypeError(`${he(t)} instances for asymmetric algorithm encryption must be of type "public"`)})(t,a,r,e)}var me=ge.bind(void 0,!1);const be=ge.bind(void 0,!0);const ve=async(e,t,a,r,i)=>{if(!(o(a)||a instanceof Uint8Array))throw new TypeError(O(a,...M,"Uint8Array"));switch(r?P(e,r):r=B(new Uint8Array(k(e)>>3)),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return a instanceof Uint8Array&&_(a,parseInt(e.slice(-3),10)),async function(e,t,a,r,i){if(!(a instanceof Uint8Array))throw new TypeError(O(a,"Uint8Array"));const n=parseInt(e.slice(1,4),10),c=await s.subtle.importKey("raw",a.subarray(n>>3),"AES-CBC",!1,["encrypt"]),o=await s.subtle.importKey("raw",a.subarray(0,n>>3),{hash:"SHA-"+(n<<1),name:"HMAC"},!1,["sign"]),d=new Uint8Array(await s.subtle.encrypt({iv:r,name:"AES-CBC"},c,t)),y=u(i,r,d,w(i.length<<3));return{ciphertext:d,tag:new Uint8Array((await s.subtle.sign("HMAC",o,y)).slice(0,n>>3)),iv:r}}(e,t,a,r,i);case"A128GCM":case"A192GCM":case"A256GCM":return a instanceof Uint8Array&&_(a,parseInt(e.slice(1,4),10)),async function(e,t,a,r,i){let n;a instanceof Uint8Array?n=await s.subtle.importKey("raw",a,"AES-GCM",!1,["encrypt"]):(J(a,e,"encrypt"),n=a);const c=new Uint8Array(await s.subtle.encrypt({additionalData:i,iv:r,name:"AES-GCM",tagLength:128},n,t)),o=c.slice(-16);return{ciphertext:c.slice(0,-16),tag:o,iv:r}}(e,t,a,r,i);default:throw new S("Unsupported JWE Content Encryption Algorithm")}};async function Ee(e,t,a,r,i){switch(me(e,t,"decrypt"),t=await(ye?.(t,e))||t,e){case"dir":if(void 0!==a)throw new K("Encountered unexpected JWE Encrypted Key");return t;case"ECDH-ES":if(void 0!==a)throw new K("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!G(r.epk))throw new K('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(!Z(t))throw new S("ECDH with the provided key is not allowed or not supported by your javascript runtime");const i=await ue(r.epk,e);let n,c;if(void 0!==r.apu){if("string"!=typeof r.apu)throw new K('JOSE Header "apu" (Agreement PartyUInfo) invalid');try{n=b(r.apu)}catch{throw new K("Failed to base64url decode the apu")}}if(void 0!==r.apv){if("string"!=typeof r.apv)throw new K('JOSE Header "apv" (Agreement PartyVInfo) invalid');try{c=b(r.apv)}catch{throw new K("Failed to base64url decode the apv")}}const s=await Y(i,t,"ECDH-ES"===e?r.enc:e,"ECDH-ES"===e?pe(r.enc):parseInt(e.slice(-5,-2),10),n,c);if("ECDH-ES"===e)return s;if(void 0===a)throw new K("JWE Encrypted Key missing");return X(e.slice(-6),s,a)}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":if(void 0===a)throw new K("JWE Encrypted Key missing");return(async(e,t,a)=>{if(!o(t))throw new TypeError(O(t,...M));if(J(t,e,"decrypt","unwrapKey"),te(e,t),t.usages.includes("decrypt"))return new Uint8Array(await s.subtle.decrypt(ee(e),t,a));if(t.usages.includes("unwrapKey")){const r=await s.subtle.unwrapKey("raw",a,t,ee(e),...z);return new Uint8Array(await s.subtle.exportKey("raw",r))}throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation')})(e,t,a);case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{if(void 0===a)throw new K("JWE Encrypted Key missing");if("number"!=typeof r.p2c)throw new K('JOSE Header "p2c" (PBES2 Count) missing or invalid');const n=i?.maxPBES2Count||1e4;if(r.p2c>n)throw new K('JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds');if("string"!=typeof r.p2s)throw new K('JOSE Header "p2s" (PBES2 Salt) missing or invalid');let c;try{c=b(r.p2s)}catch{throw new K("Failed to base64url decode the p2s")}return(async(e,t,a,r,i)=>{const n=await Q(i,e,r,t);return X(e.slice(-6),n,a)})(e,t,a,r.p2c,c)}case"A128KW":case"A192KW":case"A256KW":if(void 0===a)throw new K("JWE Encrypted Key missing");return X(e,t,a);case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{if(void 0===a)throw new K("JWE Encrypted Key missing");if("string"!=typeof r.iv)throw new K('JOSE Header "iv" (Initialization Vector) missing or invalid');if("string"!=typeof r.tag)throw new K('JOSE Header "tag" (Authentication Tag) missing or invalid');let i,n;try{i=b(r.iv)}catch{throw new K("Failed to base64url decode the iv")}try{n=b(r.tag)}catch{throw new K("Failed to base64url decode the tag")}return async function(e,t,a,r,i){const n=e.slice(0,7);return L(n,t,a,r,i,new Uint8Array(0))}(e,t,a,i,n)}default:throw new S('Invalid or unsupported "alg" (JWE Algorithm) header value')}}function Se(e,t,a,r,i){if(void 0!==i.crit&&void 0===r?.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!r||void 0===r.crit)return new Set;if(!Array.isArray(r.crit)||0===r.crit.length||r.crit.some((e=>"string"!=typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let n;n=void 0!==a?new Map([...Object.entries(a),...t.entries()]):t;for(const t of r.crit){if(!n.has(t))throw new S(`Extension Header Parameter "${t}" is not recognized`);if(void 0===i[t])throw new e(`Extension Header Parameter "${t}" is missing`);if(n.get(t)&&void 0===r[t])throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}return new Set(r.crit)}const xe=(e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some((e=>"string"!=typeof e))))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};async function Ke(e,t,a){if(!G(e))throw new K("Flattened JWE must be an object");if(void 0===e.protected&&void 0===e.header&&void 0===e.unprotected)throw new K("JOSE Header missing");if(void 0!==e.iv&&"string"!=typeof e.iv)throw new K("JWE Initialization Vector incorrect type");if("string"!=typeof e.ciphertext)throw new K("JWE Ciphertext missing or incorrect type");if(void 0!==e.tag&&"string"!=typeof e.tag)throw new K("JWE Authentication Tag incorrect type");if(void 0!==e.protected&&"string"!=typeof e.protected)throw new K("JWE Protected Header incorrect type");if(void 0!==e.encrypted_key&&"string"!=typeof e.encrypted_key)throw new K("JWE Encrypted Key incorrect type");if(void 0!==e.aad&&"string"!=typeof e.aad)throw new K("JWE AAD incorrect type");if(void 0!==e.header&&!G(e.header))throw new K("JWE Shared Unprotected Header incorrect type");if(void 0!==e.unprotected&&!G(e.unprotected))throw new K("JWE Per-Recipient Unprotected Header incorrect type");let r;if(e.protected)try{const t=b(e.protected);r=JSON.parse(p.decode(t))}catch{throw new K("JWE Protected Header is invalid")}if(!N(r,e.header,e.unprotected))throw new K("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");const i={...r,...e.header,...e.unprotected};if(Se(K,new Map,a?.crit,r,i),void 0!==i.zip)throw new S('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');const{alg:n,enc:c}=i;if("string"!=typeof n||!n)throw new K("missing JWE Algorithm (alg) in JWE Header");if("string"!=typeof c||!c)throw new K("missing JWE Encryption Algorithm (enc) in JWE Header");const s=a&&xe("keyManagementAlgorithms",a.keyManagementAlgorithms),o=a&&xe("contentEncryptionAlgorithms",a.contentEncryptionAlgorithms);if(s&&!s.has(n)||!s&&n.startsWith("PBES2"))throw new E('"alg" (Algorithm) Header Parameter value not allowed');if(o&&!o.has(c))throw new E('"enc" (Encryption Algorithm) Header Parameter value not allowed');let d;if(void 0!==e.encrypted_key)try{d=b(e.encrypted_key)}catch{throw new K("Failed to base64url decode the encrypted_key")}let l,h,w,f=!1;"function"==typeof t&&(t=await t(r,e),f=!0);try{l=await Ee(n,t,d,i,a)}catch(e){if(e instanceof TypeError||e instanceof K||e instanceof S)throw e;l=le(c)}if(void 0!==e.iv)try{h=b(e.iv)}catch{throw new K("Failed to base64url decode the iv")}if(void 0!==e.tag)try{w=b(e.tag)}catch{throw new K("Failed to base64url decode the tag")}const g=y.encode(e.protected??"");let m,v;m=void 0!==e.aad?u(g,y.encode("."),y.encode(e.aad)):g;try{v=b(e.ciphertext)}catch{throw new K("Failed to base64url decode the ciphertext")}const x={plaintext:await L(c,l,v,h,w,m)};if(void 0!==e.protected&&(x.protectedHeader=r),void 0!==e.aad)try{x.additionalAuthenticatedData=b(e.aad)}catch{throw new K("Failed to base64url decode the aad")}return void 0!==e.unprotected&&(x.sharedUnprotectedHeader=e.unprotected),void 0!==e.header&&(x.unprotectedHeader=e.header),f?{...x,key:t}:x}const Ae=Symbol();async function He(e){return(async e=>{if(e instanceof Uint8Array)return{kty:"oct",k:m(e)};if(!o(e))throw new TypeError(O(e,...M,"Uint8Array"));if(!e.extractable)throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");const{ext:t,key_ops:a,alg:r,use:i,...n}=await s.subtle.exportKey("jwk",e);return n})(e)}async function Be(e,t,a,r,i={}){let n,c,d;switch(me(e,a,"encrypt"),a=await(de?.(a,e))||a,e){case"dir":d=a;break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!Z(a))throw new S("ECDH with the provided key is not allowed or not supported by your javascript runtime");const{apu:y,apv:p}=i;let{epk:l}=i;l||(l=(await async function(e){if(!o(e))throw new TypeError(O(e,...M));return s.subtle.generateKey(e.algorithm,!0,["deriveBits"])}(a)).privateKey);const{x:u,y:h,crv:w,kty:f}=await He(l),g=await Y(a,l,"ECDH-ES"===e?t:e,"ECDH-ES"===e?pe(t):parseInt(e.slice(-5,-2),10),y,p);if(c={epk:{x:u,crv:w,kty:f}},"EC"===f&&(c.epk.y=h),y&&(c.apu=m(y)),p&&(c.apv=m(p)),"ECDH-ES"===e){d=g;break}d=r||le(t);const b=e.slice(-6);n=await V(b,g,d);break}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":d=r||le(t),n=await(async(e,t,a)=>{if(!o(t))throw new TypeError(O(t,...M));if(J(t,e,"encrypt","wrapKey"),te(e,t),t.usages.includes("encrypt"))return new Uint8Array(await s.subtle.encrypt(ee(e),t,a));if(t.usages.includes("wrapKey")){const r=await s.subtle.importKey("raw",a,...z);return new Uint8Array(await s.subtle.wrapKey("raw",r,t,ee(e)))}throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation')})(e,a,d);break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{d=r||le(t);const{p2c:s,p2s:o}=i;({encryptedKey:n,...c}=await(async(e,t,a,r=2048,i=B(new Uint8Array(16)))=>{const n=await Q(i,e,r,t);return{encryptedKey:await V(e.slice(-6),n,a),p2c:r,p2s:m(i)}})(e,a,d,s,o));break}case"A128KW":case"A192KW":case"A256KW":d=r||le(t),n=await V(e,a,d);break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{d=r||le(t);const{iv:s}=i;({encryptedKey:n,...c}=await async function(e,t,a,r){const i=e.slice(0,7),n=await ve(i,a,t,r,new Uint8Array(0));return{encryptedKey:n.ciphertext,iv:m(n.iv),tag:m(n.tag)}}(e,a,d,s));break}default:throw new S('Invalid or unsupported "alg" (JWE Algorithm) header value')}return{cek:d,encryptedKey:n,parameters:c}}class ke{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("plaintext must be an instance of Uint8Array");this._plaintext=e}setKeyManagementParameters(e){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=e,this}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._sharedUnprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._sharedUnprotectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}setContentEncryptionKey(e){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=e,this}setInitializationVector(e){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=e,this}async encrypt(e,t){if(!this._protectedHeader&&!this._unprotectedHeader&&!this._sharedUnprotectedHeader)throw new K("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");if(!N(this._protectedHeader,this._unprotectedHeader,this._sharedUnprotectedHeader))throw new K("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const a={...this._protectedHeader,...this._unprotectedHeader,...this._sharedUnprotectedHeader};if(Se(K,new Map,t?.crit,this._protectedHeader,a),void 0!==a.zip)throw new S('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');const{alg:r,enc:i}=a;if("string"!=typeof r||!r)throw new K('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("string"!=typeof i||!i)throw new K('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');let n,c,s,o,d;if(this._cek&&("dir"===r||"ECDH-ES"===r))throw new TypeError(`setContentEncryptionKey cannot be called with JWE "alg" (Algorithm) Header ${r}`);{let a;({cek:c,encryptedKey:n,parameters:a}=await Be(r,i,e,this._cek,this._keyManagementParameters)),a&&(t&&Ae in t?this._unprotectedHeader?this._unprotectedHeader={...this._unprotectedHeader,...a}:this.setUnprotectedHeader(a):this._protectedHeader?this._protectedHeader={...this._protectedHeader,...a}:this.setProtectedHeader(a))}o=this._protectedHeader?y.encode(m(JSON.stringify(this._protectedHeader))):y.encode(""),this._aad?(d=m(this._aad),s=u(o,y.encode("."),y.encode(d))):s=o;const{ciphertext:l,tag:h,iv:w}=await ve(i,this._plaintext,c,this._iv,s),f={ciphertext:m(l)};return w&&(f.iv=m(w)),h&&(f.tag=m(h)),n&&(f.encrypted_key=m(n)),d&&(f.aad=d),this._protectedHeader&&(f.protected=p.decode(o)),this._sharedUnprotectedHeader&&(f.unprotected=this._sharedUnprotectedHeader),this._unprotectedHeader&&(f.header=this._unprotectedHeader),f}}class Pe{constructor(e,t,a){this.parent=e,this.key=t,this.options=a}setUnprotectedHeader(e){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=e,this}addRecipient(...e){return this.parent.addRecipient(...e)}encrypt(...e){return this.parent.encrypt(...e)}done(){return this.parent}}class _e{constructor(e){this._recipients=[],this._plaintext=e}addRecipient(e,t){const a=new Pe(this,e,{crit:t?.crit});return this._recipients.push(a),a}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}async encrypt(){if(!this._recipients.length)throw new K("at least one recipient must be added");if(1===this._recipients.length){const[e]=this._recipients,t=await new ke(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(e.unprotectedHeader).encrypt(e.key,{...e.options}),a={ciphertext:t.ciphertext,iv:t.iv,recipients:[{}],tag:t.tag};return t.aad&&(a.aad=t.aad),t.protected&&(a.protected=t.protected),t.unprotected&&(a.unprotected=t.unprotected),t.encrypted_key&&(a.recipients[0].encrypted_key=t.encrypted_key),t.header&&(a.recipients[0].header=t.header),a}let e;for(let t=0;t<this._recipients.length;t++){const a=this._recipients[t];if(!N(this._protectedHeader,this._unprotectedHeader,a.unprotectedHeader))throw new K("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const r={...this._protectedHeader,...this._unprotectedHeader,...a.unprotectedHeader},{alg:i}=r;if("string"!=typeof i||!i)throw new K('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("dir"===i||"ECDH-ES"===i)throw new K('"dir" and "ECDH-ES" alg may only be used with a single recipient');if("string"!=typeof r.enc||!r.enc)throw new K('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');if(e){if(e!==r.enc)throw new K('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients')}else e=r.enc;if(Se(K,new Map,a.options.crit,this._protectedHeader,r),void 0!==r.zip)throw new S('JWE "zip" (Compression Algorithm) Header Parameter is not supported.')}const t=le(e),a={ciphertext:"",iv:"",recipients:[],tag:""};for(let r=0;r<this._recipients.length;r++){const i=this._recipients[r],n={};a.recipients.push(n);const c={...this._protectedHeader,...this._unprotectedHeader,...i.unprotectedHeader}.alg.startsWith("PBES2")?2048+r:void 0;if(0===r){const e=await new ke(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(t).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(i.unprotectedHeader).setKeyManagementParameters({p2c:c}).encrypt(i.key,{...i.options,[Ae]:!0});a.ciphertext=e.ciphertext,a.iv=e.iv,a.tag=e.tag,e.aad&&(a.aad=e.aad),e.protected&&(a.protected=e.protected),e.unprotected&&(a.unprotected=e.unprotected),n.encrypted_key=e.encrypted_key,e.header&&(n.header=e.header);continue}const{encryptedKey:s,parameters:o}=await Be(i.unprotectedHeader?.alg||this._protectedHeader?.alg||this._unprotectedHeader?.alg,e,i.key,t,{p2c:c});n.encrypted_key=m(s),(i.unprotectedHeader||o)&&(n.header={...i.unprotectedHeader,...o})}return a}}function Te(e,t){const a=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:a,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:a,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:a,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:a,name:"ECDSA",namedCurve:t.namedCurve};case"EdDSA":return{name:t.name};default:throw new S(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}async function We(e,t,a){if("sign"===a&&(t=await ye(t,e)),"verify"===a&&(t=await de(t,e)),o(t))return R(t,e,a),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(O(t,...M));return s.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[a])}throw new TypeError(O(t,...M,"Uint8Array","JSON Web Key"))}async function Ce(e,t,a){if(!G(e))throw new A("Flattened JWS must be an object");if(void 0===e.protected&&void 0===e.header)throw new A('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==e.protected&&"string"!=typeof e.protected)throw new A("JWS Protected Header incorrect type");if(void 0===e.payload)throw new A("JWS Payload missing");if("string"!=typeof e.signature)throw new A("JWS Signature missing or incorrect type");if(void 0!==e.header&&!G(e.header))throw new A("JWS Unprotected Header incorrect type");let r={};if(e.protected)try{const t=b(e.protected);r=JSON.parse(p.decode(t))}catch{throw new A("JWS Protected Header is invalid")}if(!N(r,e.header))throw new A("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const i={...r,...e.header};let n=!0;if(Se(A,new Map([["b64",!0]]),a?.crit,r,i).has("b64")&&(n=r.b64,"boolean"!=typeof n))throw new A('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:c}=i;if("string"!=typeof c||!c)throw new A('JWS "alg" (Algorithm) Header Parameter missing or invalid');if(n){if("string"!=typeof e.payload)throw new A("JWS Payload must be a string")}else if("string"!=typeof e.payload&&!(e.payload instanceof Uint8Array))throw new A("JWS Payload must be a string or an Uint8Array instance");let o=!1;"function"==typeof t?(t=await t(r,e),o=!0,be(c,t,"verify"),ae(t)&&(t=await ue(t,c))):be(c,t,"verify");const d=u(y.encode(e.protected??""),y.encode("."),"string"==typeof e.payload?y.encode(e.payload):e.payload);let l;try{l=b(e.signature)}catch{throw new A("Failed to base64url decode the signature")}const h=await(async(e,t,a,r)=>{const i=await We(e,t,"verify");te(e,i);const n=Te(e,i.algorithm);try{return await s.subtle.verify(n,i,a,r)}catch{return!1}})(c,t,l,d);if(!h)throw new H;let w;if(n)try{w=b(e.payload)}catch{throw new A("Failed to base64url decode the payload")}else w="string"==typeof e.payload?y.encode(e.payload):e.payload;const f={payload:w};return void 0!==e.protected&&(f.protectedHeader=r),void 0!==e.header&&(f.unprotectedHeader=e.header),o?{...f,key:t}:f}class Ue{constructor(e){this._flattened=new ke(e)}setContentEncryptionKey(e){return this._flattened.setContentEncryptionKey(e),this}setInitializationVector(e){return this._flattened.setInitializationVector(e),this}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}setKeyManagementParameters(e){return this._flattened.setKeyManagementParameters(e),this}async encrypt(e,t){const a=await this._flattened.encrypt(e,t);return[a.protected,a.encrypted_key,a.iv,a.ciphertext,a.tag].join(".")}}class Re{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=e}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}async sign(e,t){if(!this._protectedHeader&&!this._unprotectedHeader)throw new A("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!N(this._protectedHeader,this._unprotectedHeader))throw new A("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const a={...this._protectedHeader,...this._unprotectedHeader};let r=!0;if(Se(A,new Map([["b64",!0]]),t?.crit,this._protectedHeader,a).has("b64")&&(r=this._protectedHeader.b64,"boolean"!=typeof r))throw new A('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:i}=a;if("string"!=typeof i||!i)throw new A('JWS "alg" (Algorithm) Header Parameter missing or invalid');be(i,e,"sign");let n,c=this._payload;r&&(c=y.encode(m(c))),n=this._protectedHeader?y.encode(m(JSON.stringify(this._protectedHeader))):y.encode("");const o=u(n,y.encode("."),c),d=await(async(e,t,a)=>{const r=await We(e,t,"sign");te(e,r);const i=await s.subtle.sign(Te(e,r.algorithm),r,a);return new Uint8Array(i)})(i,e,o),l={signature:m(d),payload:""};return r&&(l.payload=p.decode(c)),this._unprotectedHeader&&(l.header=this._unprotectedHeader),this._protectedHeader&&(l.protected=p.decode(n)),l}}class Je{constructor(e){this._flattened=new Re(e)}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}async sign(e,t){const a=await this._flattened.sign(e,t);if(void 0===a.payload)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${a.protected}.${a.payload}.${a.signature}`}}class De{constructor(e,t,a){this.parent=e,this.key=t,this.options=a}setProtectedHeader(e){if(this.protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this.protectedHeader=e,this}setUnprotectedHeader(e){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=e,this}addSignature(...e){return this.parent.addSignature(...e)}sign(...e){return this.parent.sign(...e)}done(){return this.parent}}class Oe{constructor(e){this._signatures=[],this._payload=e}addSignature(e,t){const a=new De(this,e,t);return this._signatures.push(a),a}async sign(){if(!this._signatures.length)throw new A("at least one signature must be added");const e={signatures:[],payload:""};for(let t=0;t<this._signatures.length;t++){const a=this._signatures[t],r=new Re(this._payload);r.setProtectedHeader(a.protectedHeader),r.setUnprotectedHeader(a.unprotectedHeader);const{payload:i,...n}=await r.sign(a.key,a.options);if(0===t)e.payload=i;else if(e.payload!==i)throw new A("inconsistent use of JWS Unencoded Payload (RFC7797)");e.signatures.push(n)}return e}}const Ie=m,je=b;function Me(e){let t;if("string"==typeof e){const a=e.split(".");3!==a.length&&5!==a.length||([t]=a)}else if("object"==typeof e&&e){if(!("protected"in e))throw new TypeError("Token does not contain a Protected Header");t=e.protected}try{if("string"!=typeof t||!t)throw new Error;const e=JSON.parse(p.decode(je(t)));if(!G(e))throw new Error;return e}catch{throw new TypeError("Invalid Token or Protected Header formatting")}}function $e(e){const t=e?.modulusLength??2048;if("number"!=typeof t||t<2048)throw new S("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");return t}async function Le(e,t){return async function(e,t){let a,r;switch(e){case"PS256":case"PS384":case"PS512":a={name:"RSA-PSS",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:$e(t)},r=["sign","verify"];break;case"RS256":case"RS384":case"RS512":a={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:$e(t)},r=["sign","verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":a={name:"RSA-OAEP",hash:`SHA-${parseInt(e.slice(-3),10)||1}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:$e(t)},r=["decrypt","unwrapKey","encrypt","wrapKey"];break;case"ES256":a={name:"ECDSA",namedCurve:"P-256"},r=["sign","verify"];break;case"ES384":a={name:"ECDSA",namedCurve:"P-384"},r=["sign","verify"];break;case"ES512":a={name:"ECDSA",namedCurve:"P-521"},r=["sign","verify"];break;case"EdDSA":{r=["sign","verify"];const e=t?.crv??"Ed25519";switch(e){case"Ed25519":case"Ed448":a={name:e};break;default:throw new S("Invalid or unsupported crv option provided")}break}case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{r=["deriveKey","deriveBits"];const e=t?.crv??"P-256";switch(e){case"P-256":case"P-384":case"P-521":a={name:"ECDH",namedCurve:e};break;case"X25519":case"X448":a={name:e};break;default:throw new S("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448")}break}default:throw new S('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return s.subtle.generateKey(a,t?.extractable??!1,r)}(e,t)}async function Ne(e,t){return async function(e,t){let a,r,i;switch(e){case"HS256":case"HS384":case"HS512":a=parseInt(e.slice(-3),10),r={name:"HMAC",hash:`SHA-${a}`,length:a},i=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return a=parseInt(e.slice(-3),10),B(new Uint8Array(a>>3));case"A128KW":case"A192KW":case"A256KW":a=parseInt(e.slice(1,4),10),r={name:"AES-KW",length:a},i=["wrapKey","unwrapKey"];break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":case"A128GCM":case"A192GCM":case"A256GCM":a=parseInt(e.slice(1,4),10),r={name:"AES-GCM",length:a},i=["encrypt","decrypt"];break;default:throw new S('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return s.subtle.generateKey(r,t?.extractable,i)}(e,t)}const Ge="Ed25519",ze="EdDSA",Fe="SHA-256",qe="RSA-OAEP-256",Ve="AES-GCM",Xe="A256GCM",Ye="PBES2-HS512+A256KW",Ze=!0;async function Qe(e){let t=await c.subtle.digest(Fe,e);return new Uint8Array(t)}function et(e){return Qe((new TextEncoder).encode(e))}function tt(e){return Ie(e)}function at(e){return je(e)}function rt(e,t=0){return Me(e.signatures?.[t]||e)}const nt=new URL(import.meta.url),ct=new URL("vault.html",nt),st=nt.href,ot=document.createElement("iframe"),dt=new MessageChannel,yt=Object.assign({log(...e){console.log(...e)},getUserDeviceSecret:n},r),pt=new Promise((e=>{yt.ready=e,ot.style.display="none",document.body.append(ot),ot.setAttribute("src",ct),dt.port1.start(),ot.onload=()=>ot.contentWindow.postMessage(st,ct.origin,[dt.port2])})),lt=function({target:e=self,receiver:t=e,namespace:a=t,origin:r=e!==t&&e.location.origin,dispatcherLabel:i=a.name||t.name||t.location?.href||t,targetLabel:n=e.name||r||e.location?.href||e,log:c=null,info:s=console.info.bind(console),warn:o=console.warn.bind(console),error:d=console.error.bind(console)}){const y={},p="2.0",l=e.postMessage.bind(e),u=r?e=>l(e,r):l;let h=0;return t.addEventListener("message",(async function(t){c?.(i,"got message",t.data,"from",n,t.origin);let{id:s,method:l,params:h=[],result:w,error:f,jsonrpc:g}=t.data||{};if(t.source&&t.source!==e)return d?.(i,"to",n,"got message from",t.source);if(r&&r!==t.origin)return d?.(i,r,"mismatched origin",n,t.origin);if(g!==p)return o?.(`${i} ignoring non-jsonrpc message ${JSON.stringify(t.data)}.`);if(l){let e,t=null,r=Array.isArray(h)?h:[h];try{e=await a[l](...r)}catch(e){t=function(e){let{name:t,message:a,code:r,data:i}=e;return{name:t,message:a,code:r,data:i}}(e),a[l]||t.message.includes(l)?t.message||(t.message=`${t.name||t.toString()} in ${l}.`):(t.message=`${l} is not defined.`,t.code=-32601)}if(void 0===s)return;let o=t?{id:s,error:t,jsonrpc:p}:{id:s,result:e,jsonrpc:p};return c?.(i,"answering",s,t||e,"to",n),u(o)}let m=y[s];if(delete y[s],!m)return o?.(`${i} ignoring response ${t.data}.`);f?m.reject(f):m.resolve(w)})),s?.(`${i} will dispatch to ${n}`),function(e,...t){let a=++h,r=y[a]={};return new Promise(((s,o)=>{c?.(i,"request",a,e,t,"to",n),Object.assign(r,{resolve:s,reject:o}),u({id:a,method:e,params:t,jsonrpc:p})}))}}({dispatcherLabel:"entry!"+st,namespace:yt,target:dt.port1,targetLabel:"vault!"+st}),ut={sign:(e,...t)=>lt("sign",e,...t),verify:(e,...t)=>lt("verify",e,...t),encrypt:(e,...t)=>lt("encrypt",e,...t),decrypt:(e,...t)=>lt("decrypt",e,...t),create:(...e)=>lt("create",...e),changeMembership:({tag:e,add:t,remove:a}={})=>lt("changeMembership",{tag:e,add:t,remove:a}),destroy:e=>lt("destroy",e),clear:(e=null)=>lt("clear",e),ready:pt,hashBuffer:Qe,hashText:et,encodeBase64url:tt,decodeBase64url:at,decodeClaims:rt,get Storage(){return yt},set Storage(e){Object.assign(yt,e)},get getUserDeviceSecret(){return yt.getUserDeviceSecret},set getUserDeviceSecret(e){yt.getUserDeviceSecret=e}},ht=10485760;function wt(e=ht){return Array.from({length:e},((e,t)=>1&t)).join("")}const ft=/^[A-Za-z0-9_\-.]+$/;function gt(e,t=ft){expect(t.test(e)).toBeTruthy()}function mt(e,t){expect(new Uint8Array(e.payload)).toEqual(t)}function bt(e,t=446){const a=15e3,r=t>1e3?a:5e3,i=wt();describe("signing",(function(){let t;beforeAll((async function(){t=await e.generateSigningKey()})),it("with a private key produces a base64URL signature that verifies with the public key.",(async function(){let a=await e.sign(t.privateKey,i);gt(a),expect(await e.verify(t.publicKey,a)).toBeTruthy()})),it("returns undefined for verify with the wrong key.",(async function(){let a=await e.sign(t.privateKey,i),r=await e.generateSigningKey();expect(await e.verify(r.publicKey,a)).toBeUndefined()})),it("handles binary, and verifies with that as payload property.",(async function(){let a=new Uint8Array([21,31]),r=await e.sign(t.privateKey,a),i=await e.verify(t.publicKey,r);expect(i.cty).toBeUndefined(),mt(i,a)})),it('handles text, setting cty as "text/plain", and verifies with that as the text property and an encoding of that for payload.',(async function(){let a=await e.sign(t.privateKey,i),r=await e.verify(t.publicKey,a);expect(r.protectedHeader.cty).toBe("text/plain"),expect(r.text).toBe(i),expect(r.payload).toEqual((new TextEncoder).encode(i))})),it('handles json, setting cty as "json", and verifies with that as json property, the string of that as the text property, and the encoding of that string for payload.',(async function(){let a={foo:"bar"},r=await e.sign(t.privateKey,a),i=await e.verify(t.publicKey,r);expect(i.protectedHeader.cty).toBe("json"),expect(i.json).toEqual(a),expect(i.text).toBe(JSON.stringify(a)),expect(i.payload).toEqual((new TextEncoder).encode(JSON.stringify(a)))})),it("Uses specified headers if supplied, including cty.",(async function(){let a="text/html",r=Date.now(),i="<something else>",n=await e.sign(t.privateKey,i,{cty:a,iat:r,foo:17}),c=await e.verify(t.publicKey,n);expect(c.protectedHeader.cty).toBe(a),expect(c.protectedHeader.iat).toBe(r),expect(c.protectedHeader.foo).toBe(17),expect(c.text).toEqual(i)}))})),describe("encryption",(function(){let n;function c(t,a,r=a){it(`can work on much larger data with a ${t}.`,(async function(){let t=await a,n=await r,c=await e.encrypt(t,i),s=await e.decrypt(n,c);gt(c),expect(s.text).toBe(i)}))}function s(r,i){it(`rejects wrong ${r}.`,(async function(){let[a,r]=await i(),n=wt(t),c=await e.encrypt(a,n);await expectAsync(e.decrypt(r,c)).toBeRejected()}),a)}beforeAll((async function(){n=await e.generateEncryptingKey()})),it(`can work up through at least ${t} bytes with an asymmetric keypair.`,(async function(){let a=wt(t),r=await e.encrypt(n.publicKey,a),i=await e.decrypt(n.privateKey,r);gt(r),expect(i.text).toBe(a)}),r),c("fixed symmetric key",e.generateSymmetricKey()),c("reproducible secret",e.generateSymmetricKey("secret"),e.generateSymmetricKey("secret")),it("handles binary, and decrypts as same.",(async function(){let t=new Uint8Array([21,31]),a=await e.encrypt(n.publicKey,t),r=await e.decrypt(n.privateKey,a),i=e.decodeProtectedHeader(a);expect(i.cty).toBeUndefined(),mt(r,t)})),it("handles text, and decrypts as same.",(async function(){let t=await e.encrypt(n.publicKey,i),a=await e.decrypt(n.privateKey,t),r=e.decodeProtectedHeader(t);expect(r.cty).toBe("text/plain"),expect(a.text).toBe(i)})),it("handles json, and decrypts as same.",(async function(){let t={foo:"bar"},a=await e.encrypt(n.publicKey,t),r=e.decodeProtectedHeader(a),i=await e.decrypt(n.privateKey,a);expect(r.cty).toBe("json"),expect(i.json).toEqual(t)})),it("Uses specified headers if supplied, including cty.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await e.encrypt(n.publicKey,r,{cty:t,iat:a,foo:17}),c=await e.decrypt(n.privateKey,i),s=e.decodeProtectedHeader(i);expect(s.cty).toBe(t),expect(s.iat).toBe(a),expect(s.foo).toBe(17),expect(c.text).toBe(r)})),s("asymmetric key",(async()=>[(await e.generateEncryptingKey()).publicKey,(await e.generateEncryptingKey()).privateKey])),s("symmetric key",(async()=>[await e.generateSymmetricKey(),await e.generateSymmetricKey()])),s("secret",(async()=>[await e.generateSymmetricKey("secret"),await e.generateSymmetricKey("secretX")]))})),describe("export/import",(function(){async function t(t){return JSON.stringify(await e.exportJWK(t))}function a(t){return e.importJWK(JSON.parse(t))}describe("of signing keys",(function(){it("works with the private signing key as a 143 byte serialization.",(async function(){let r=await e.generateSigningKey(),n=await t(r.privateKey),c=await a(n),s=await e.sign(c,i);expect(n.length).toBe(143),expect(await e.verify(r.publicKey,s)).toBeTruthy()}));it("works with the public verifying key as a 93 byte serialization.",(async function(){let r=await e.generateSigningKey(),n=await t(r.publicKey),c=await a(n),s=await e.sign(r.privateKey,i);expect(n.length).toBe(93),expect(await e.verify(c,s)).toBeTruthy()}));it("works with public key as a raw verifying key as a base64URL serialization of no more that 132 bytes",(async function(){let t=await e.generateSigningKey(),a=await e.exportRaw(t.publicKey),r=await e.importRaw(a),n=await e.sign(t.privateKey,i);gt(a),expect(a.length).toBeLessThanOrEqual(132),expect(await e.verify(r,n)).toBeTruthy()}))})),describe("of encryption keys",(function(){const r=[3169,3173];it(`works with the private key as a ${r[0]}-${r[1]} byte serialization.`,(async function(){let i=await e.generateEncryptingKey(),n=await t(i.privateKey),c=await a(n),s=wt(446),o=await e.encrypt(i.publicKey,s),d=await e.decrypt(c,o);expect(n.length).toBeGreaterThanOrEqual(r[0]),expect(n.length).toBeLessThanOrEqual(r[1]),expect(d.text).toBe(s)}));it("works with the public key as a 735 byte serialization.",(async function(){let r=await e.generateEncryptingKey(),i=await t(r.publicKey),n=await a(i),c=wt(446),s=await e.encrypt(n,c),o=await e.decrypt(r.privateKey,s);expect(i.length).toBe(735),expect(o.text).toBe(c)}))})),describe("of symmetric key",(function(){it("works as a 79 byte serialization.",(async function(){let r=await e.generateSymmetricKey(),n=await t(r),c=await a(n),s=await e.encrypt(r,i),o=await e.decrypt(c,s);expect(n.length).toBe(79),expect(o.text).toBe(i)}))}))})),it("wraps like export+encrypt.",(async function(){let t=await e.generateSymmetricKey(),a=await e.generateEncryptingKey(),r=await e.exportJWK(t),i=await e.encrypt(a.publicKey,r),n=await e.decrypt(a.privateKey,i),c=await e.importJWK(n.json),s=await e.wrapKey(t,a.publicKey),o=await e.unwrapKey(s,a.privateKey),d="this is a message",y=await e.encrypt(o,d),p=await e.decrypt(c,y);gt(s),expect(p.text).toBe(d)}),a)}const vt={decodeProtectedHeader:Me,isEmptyJWSPayload:e=>!e.split(".")[1],inputBuffer(e,t){if(ArrayBuffer.isView(e))return e;let a=t.cty||"";return a.includes("text")||"string"==typeof e?t.cty=a||"text/plain":(t.cty=a||"json",e=JSON.stringify(e)),(new TextEncoder).encode(e)},recoverDataFromContentType:(e,{cty:t=e?.protectedHeader?.cty}={})=>(e&&!Object.prototype.hasOwnProperty.call(e,"payload")&&(e.payload=e.plaintext),t&&e?.payload?(e.text=(new TextDecoder).decode(e.payload),t.includes("json")&&(e.json=JSON.parse(e.text)),e):e),generateSigningKey:()=>Le(ze,{extractable:Ze}),async sign(e,t,a={}){let r={alg:ze,...a},i=this.inputBuffer(t,r);return new Je(i).setProtectedHeader(r).sign(e)},async verify(e,t,a){let r=await async function(e,t,a){if(e instanceof Uint8Array&&(e=p.decode(e)),"string"!=typeof e)throw new A("Compact JWS must be a string or Uint8Array");const{0:r,1:i,2:n,length:c}=e.split(".");if(3!==c)throw new A("Invalid Compact JWS");const s=await Ce({payload:i,protected:r,signature:n},t,a),o={payload:s.payload,protectedHeader:s.protectedHeader};return"function"==typeof t?{...o,key:s.key}:o}(t,e).catch((()=>{}));return this.recoverDataFromContentType(r,a)},generateEncryptingKey:()=>Le(qe,{extractable:Ze,modulusLength:4096}),async encrypt(e,t,a={}){let r={alg:this.isSymmetric(e)?"dir":qe,enc:Xe,...a},i=this.inputBuffer(t,r),n=this.keySecret(e);return new Ue(i).setProtectedHeader(r).encrypt(n)},async decrypt(e,t,a={}){let r=this.keySecret(e),i=await async function(e,t,a){if(e instanceof Uint8Array&&(e=p.decode(e)),"string"!=typeof e)throw new K("Compact JWE must be a string or Uint8Array");const{0:r,1:i,2:n,3:c,4:s,length:o}=e.split(".");if(5!==o)throw new K("Invalid Compact JWE");const d=await Ke({ciphertext:c,iv:n||void 0,protected:r,tag:s||void 0,encrypted_key:i||void 0},t,a),y={plaintext:d.plaintext,protectedHeader:d.protectedHeader};return"function"==typeof t?{...y,key:d.key}:y}(t,r);return this.recoverDataFromContentType(i,a),i},generateSecretKey:async e=>({type:"secret",text:await et(e)}),generateSymmetricKey(e){return e?this.generateSecretKey(e):Ne(Xe,{extractable:Ze})},isSymmetric:e=>"secret"===e.type,keySecret:e=>e.text?e.text:e,async exportRaw(e){let t=await function(e){return c.subtle.exportKey("raw",e)}(e);return tt(new Uint8Array(t))},importRaw:async e=>function(e){const t={name:Ge};return c.subtle.importKey("raw",e,t,Ze,["verify"])}(at(e)),async exportJWK(e){let t=await He(e),a=e.algorithm;if(a)"EdDSA"===a.name&&a.namedCurve===Ge||a.name===Ge?t.alg=ze:"RSA-OAEP"===a.name&&a.hash.name===Fe?t.alg=qe:a.name===Ve&&256===a.length&&(t.alg=Xe);else switch(t.kty){case"EC":case"OKP":t.alg=ze;break;case"RSA":t.alg=qe;break;case"oct":t.alg=Xe}return t},async importJWK(e){e={ext:!0,...e};let t=await ue(e);return t instanceof Uint8Array&&(t=await function(e){const t={name:Ve,length:256};return c.subtle.importKey("raw",e,t,!0,["encrypt","decrypt"])}(t)),t},async wrapKey(e,t,a={}){let r=await this.exportJWK(e);return this.encrypt(t,r,a)},async unwrapKey(e,t){let a=await this.decrypt(t,e);return this.importJWK(a.json)}};const Et={isMultiKey:e=>"multi"===(e.type||"multi"),keyTags:e=>Object.keys(e).filter((e=>"type"!==e)),async exportJWK(e){if(!this.isMultiKey(e))return super.exportJWK(e);let t=this.keyTags(e),a=await Promise.all(t.map((async t=>{let a=await this.exportJWK(e[t]);return a.kid=t,a})));return{keys:a}},async importJWK(e){if(!e.keys)return super.importJWK(e);let t={};return await Promise.all(e.keys.map((async e=>t[e.kid]=await this.importJWK(e)))),t},async encrypt(e,t,a={}){if(!this.isMultiKey(e))return super.encrypt(e,t,a);let r={enc:Xe,...a},i=this.inputBuffer(t,r),n=new _e(i).setProtectedHeader(r);for(let t of this.keyTags(e)){let a=e[t],r="string"==typeof a,i=r||this.isSymmetric(a),c=r?(new TextEncoder).encode(a):this.keySecret(a),s=r?Ye:i?"A256GCMKW":qe;n.addRecipient(c).setUnprotectedHeader({kid:t,alg:s})}return await n.encrypt()},async decrypt(e,t,a){if(!this.isMultiKey(e))return super.decrypt(e,t,a);let r=t,{recipients:i}=r,n=i.map((async({header:t})=>{let{kid:a}=t,i=e[a],n={};if(!i)return Promise.reject("missing");"string"==typeof i&&(i=(new TextEncoder).encode(i),n.keyManagementAlgorithms=[Ye]);let c=await async function(e,t,a){if(!G(e))throw new K("General JWE must be an object");if(!Array.isArray(e.recipients)||!e.recipients.every(G))throw new K("JWE Recipients missing or incorrect type");if(!e.recipients.length)throw new K("JWE Recipients has no members");for(const r of e.recipients)try{return await Ke({aad:e.aad,ciphertext:e.ciphertext,encrypted_key:r.encrypted_key,header:r.header,iv:e.iv,protected:e.protected,tag:e.tag,unprotected:e.unprotected},t,a)}catch{}throw new x}(r,this.keySecret(i),n),s=c.unprotectedHeader.kid;return s!==a?function(e,t){let a=`Key ${e} does not match encoded ${t}.`;return Promise.reject(a)}(a,s):c}));return await Promise.any(n).then((e=>(this.recoverDataFromContentType(e,a),e)),(()=>{}))},async sign(e,t,a={}){if(!this.isMultiKey(e))return super.sign(e,t,a);let r=this.inputBuffer(t,a),i=new Oe(r);for(let t of this.keyTags(e)){let r=e[t],n={kid:t,alg:ze,...a};i.addSignature(r).setProtectedHeader(n)}return i.sign()},verifySubSignature(e,t,a,r){let i=t.protectedHeader??this.decodeProtectedHeader(t),n=t.unprotectedHeader,c=i?.kid||n?.kid,s={...e,signatures:[t]},o={protectedHeader:i,unprotectedHeader:n,kid:c},d=c?[c]:r,y=Promise.any(d.map((async e=>async function(e,t,a){if(!G(e))throw new A("General JWS must be an object");if(!Array.isArray(e.signatures)||!e.signatures.every(G))throw new A("JWS Signatures missing or incorrect type");for(const r of e.signatures)try{return await Ce({header:r.header,payload:e.payload,protected:r.protected,signature:r.signature},t,a)}catch{}throw new H}(s,a[e]).then((t=>({kid:e,...t}))))));return y.catch((()=>o))},async verify(e,t,a={}){if(!this.isMultiKey(e))return super.verify(e,t,a);if(!t.signatures)return;let r=t,i=this.keyTags(e),n=await Promise.all(r.signatures.map((t=>this.verifySubSignature(r,t,e,i))));if(!n.find((e=>e.payload)))return;let[c,...s]=n,o={protectedHeader:{},unprotectedHeader:{},signers:n},d=e=>{let t=c[e],a=o[e];for(let r in t){let i=t[r];s.some((t=>t[e][r]!==i))||(a[r]=i)}};return d("protectedHeader"),d("protectedHeader"),o.payload=n.find((e=>e.payload)).payload,this.recoverDataFromContentType(o,a)}};Object.setPrototypeOf(Et,vt);let St=class extends Map{constructor(e,t=0){super(),this.maxSize=e,this.defaultTimeToLive=t,this._nextWriteIndex=0,this._keyList=Array(e),this._timers=new Map}set(e,t,a=this.defaultTimeToLive){let r=this._nextWriteIndex;this.delete(this._keyList[r]),this._keyList[r]=e,this._nextWriteIndex=(r+1)%this.maxSize,this._timers.has(e)&&clearTimeout(this._timers.get(e)),super.set(e,t),a&&this._timers.set(e,setTimeout((()=>this.delete(e)),a))}delete(e){return this._timers.has(e)&&clearTimeout(this._timers.get(e)),this._timers.delete(e),super.delete(e)}clear(e=this.maxSize){this.maxSize=e,this._keyList=Array(e),this._nextWriteIndex=0,super.clear();for(const e of this._timers.values())clearTimeout(e);this._timers.clear()}};class xt extends Map{constructor(e,t=0){super(),this.maxSize=e,this.defaultTimeToLive=t,this._nextWriteIndex=0,this._keyList=Array(e),this._timers=new Map}set(e,t,a=this.defaultTimeToLive){let r=this._nextWriteIndex;this.delete(this._keyList[r]),this._keyList[r]=e,this._nextWriteIndex=(r+1)%this.maxSize,this._timers.has(e)&&clearTimeout(this._timers.get(e)),super.set(e,t),a&&this._timers.set(e,setTimeout((()=>this.delete(e)),a))}delete(e){return this._timers.has(e)&&clearTimeout(this._timers.get(e)),this._timers.delete(e),super.delete(e)}clear(e=this.maxSize){this.maxSize=e,this._keyList=Array(e),this._nextWriteIndex=0,super.clear();for(const e of this._timers.values())clearTimeout(e);this._timers.clear()}}class Kt{constructor({name:e,baseName:t="Storage",maxSerializerSize:a=1e3,debug:r=!1}){const i=`${t}/${e}`,n=new xt(a);Object.assign(this,{name:e,baseName:t,fullName:i,debug:r,serializer:n})}async list(){return this.serialize("",((e,t)=>this.listInternal(t,e)))}async get(e){return this.serialize(e,((e,t)=>this.getInternal(t,e)))}async delete(e){return this.serialize(e,((e,t)=>this.deleteInternal(t,e)))}async put(e,t){return this.serialize(e,((e,a)=>this.putInternal(a,t,e)))}log(...e){this.debug&&console.log(this.name,...e)}async serialize(e,t){const{serializer:a,ready:r}=this;let i=a.get(e)||r;return i=i.then((async()=>t(await this.ready,this.path(e)))),a.set(e,i),await i}}const{Response:At,URL:Ht}=globalThis;class Bt extends Kt{constructor(...e){super(...e),this.stripper=new RegExp(`^/${this.fullName}/`),this.ready=caches.open(this.fullName)}async listInternal(e,t){return(await t.keys()||[]).map((e=>this.tag(e.url)))}async getInternal(e,t){const a=await t.match(e);return a?.json()}deleteInternal(e,t){return t.delete(e)}putInternal(e,t,a){return a.put(e,At.json(t))}path(e){return`/${this.fullName}/${e}`}tag(e){return new Ht(e).pathname.replace(this.stripper,"")}destroy(){return caches.delete(this.fullName)}}function kt(e,t,a=void 0){let r=e(t?t.slice(0,16)+"...":"<empty tag>");return Promise.reject(new Error(r,{cause:a}))}function Pt(e,t){return kt((e=>`The ${t} tag ${e} is not available.`),e)}class _t{static keySets=new St(500,36e5);static cached(e){return _t.keySets.get(e)}static cache(e,t){_t.keySets.set(e,t)}static clear(e=null){return e?_t.keySets.delete(e):_t.keySets.clear()}constructor(e){this.tag=e,this.memberTags=[],_t.cache(e,this)}static getUserDeviceSecret=n;static Storage=r;static async create(e){let{time:t,...a}=await this.createKeys(e),{tag:r}=a;return await this.persist(r,a,e,t),r}async destroy(e={}){let{tag:t,memberTags:a,signingKey:r}=this,i=await this.constructor.signForStorage({...e,message:"",tag:t,memberTags:a,signingKey:r,time:Date.now(),recovery:!0});await this.constructor.store("EncryptionKey",t,i),await this.constructor.store(this.constructor.collection,t,i),this.constructor.clear(t),e.recursiveMembers&&await Promise.allSettled(this.memberTags.map((async t=>{let a=await _t.ensure(t,{...e,recovery:!0});await a.destroy(e)})))}decrypt(e,t){let{tag:a,decryptingKey:r}=this,i=e.recipients?{[a]:r}:r;return Et.decrypt(i,e,t)}static async sign(e,{tags:t=[],team:a,member:r,subject:i="hash",time:n=a&&Date.now(),memberTags:c,signingKey:s,recovery:o,...d}){if(a&&!r){c||(c=(await _t.ensure(a)).memberTags);let e=c.find((e=>this.cached(e)));r=e||await this.ensure1(c).then((e=>e.tag))}a&&!t.includes(a)&&(t=[a,...t]),r&&!t.includes(r)&&(t=[...t,r]);let y=await this.produceKey(t,(async e=>{let t=s||(await _t.ensure(e,{recovery:o,...d})).signingKey;return s=null,t}),d),p=Et.inputBuffer(e,d);if("hash"===i){const e=await Qe(p);i=await tt(e)}else i||(i=void 0);return Et.sign(y,p,{iss:a,act:r,iat:n,sub:i,...d})}static async verify(e,t,a){let r=!e.signatures,i=await this.produceKey(t,(e=>_t.verifyingKey(e)),a,r),n=await Et.verify(i,e,a),c=void 0===a.member?n?.protectedHeader.act:a.member,s=a.notBefore;function o(e){if(a.hardError)return Promise.reject(new Error(e))}if(!n)return o("Incorrect signature.");if(c){if("team"===a.member&&(c=n.protectedHeader.act,!c))return o("No member identified in signature.");if(!t.includes(c)){let r=await _t.verifyingKey(c),i={[c]:r};if(!await Et.verify(i,e,a))return o("Incorrect member signature.");t.push(c),n.signers.find((e=>e.protectedHeader.kid===c)).payload=n.payload}}if(c||"team"===s){let e=n.protectedHeader.iss||n.protectedHeader.kid,t=await this.retrieve(Rt.collection,e),a=t?.json;if(c&&!e)return o("No team or main tag identified in signature");if(c&&a&&!a.recipients.find((e=>e.header.kid===c)))return o("Signer is not a member.");"team"===s&&(s=t?.protectedHeader.iat||(await this.retrieve("EncryptionKey",e,"force"))?.protectedHeader.iat)}if(s){let{iat:e}=n.protectedHeader;if(e<s)return o("Signature predates required timestamp.")}return(n.signers?.filter((e=>e.payload)).length||1)!==t.length?o("Unverified signer"):n}static async produceKey(e,t,a,r=1===e.length){if(r){let r=e[0];return a.kid=r,t(r)}let i={},n=await Promise.all(e.map((e=>t(e))));return e.forEach(((e,t)=>i[e]=n[t])),i}static verifyingKey(e){return Et.importRaw(e).catch((()=>Pt(e,"verification")))}static async encryptingKey(e){let t=await this.retrieve("EncryptionKey",e);return t?await Et.importJWK(t.json):Pt(e,"encryption")}static async createKeys(e){let{publicKey:t,privateKey:a}=await Et.generateSigningKey(),{publicKey:r,privateKey:i}=await Et.generateEncryptingKey(),n=await Et.exportRaw(t),c=await Et.exportJWK(r),s=Date.now(),o=await this.signForStorage({message:c,tag:n,signingKey:a,memberTags:e,time:s,recovery:!0});return await this.store("EncryptionKey",n,o),{signingKey:a,decryptingKey:i,tag:n,time:s}}static getWrapped(e){return this.retrieve(this.collection,e)}static async ensure(e,{device:t=!0,team:a=!0,recovery:r=!1}={}){let i=this.cached(e),n=t&&await Ct.getWrapped(e);return n?i||=new Ct(e):a&&(n=await Rt.getWrapped(e))?i||=new Rt(e):r&&(n=await Wt.getWrapped(e))&&(i||=new Wt(e)),i?.cached&&i.cached.protectedHeader.iat===n?.protectedHeader.iat&&i.cached.text===n?.text&&i.decryptingKey&&i.signingKey?i:n?(i.cached=n,i.unwrap(i.cached).then((e=>Object.assign(i,e)),(e=>(this.clear(i.tag),kt((e=>`You do not have access to the private key for ${e}.`),i.tag,e))))):(this.clear(e),Pt(e,"private"))}static ensure1(e){return Promise.any(e.map((e=>_t.ensure(e)))).catch((async t=>{for(let t of e){let e=await _t.ensure(t,{device:!1,team:!1,recovery:!0}).catch((()=>null));if(e)return e}throw t}))}static async persist(e,t,a,r=Date.now(),i=a){let{signingKey:n}=t,c=await this.wrap(t,a),s=await this.signForStorage({message:c,tag:e,signingKey:n,memberTags:i,time:r,recovery:!0});await this.store(this.collection,e,s)}static async store(e,t,a){return e===Ct.collection?Et.isEmptyJWSPayload(a)?Ut.delete(t):Ut.put(t,a):_t.Storage.store(e,t,a)}static async retrieve(e,t,a=!1){let r=!a&&this.cached(t);if(r?.constructor.collection===e)return r.cached;let i=e===Ct.collection?Ut.get(t):_t.Storage.retrieve(e,t),n=await i,c=n&&await _t.verifyingKey(t);return n?(n.signatures&&(c={[t]:c}),await Et.verify(c,n)):void 0}}class Tt extends _t{static signForStorage({message:e,tag:t,signingKey:a,time:r}){return this.sign(e,{tags:[t],signingKey:a,time:r})}static async wrappingKey(e,t){let a=await this.getSecret(e,t);return Et.generateSecretKey(a)}static async wrap(e,t=""){let{decryptingKey:a,signingKey:r,tag:i}=e,n={decryptingKey:a,signingKey:r},c=await this.wrappingKey(i,t);return Et.wrapKey(n,c,{prompt:t})}async unwrap(e){let t=e.json||e.text,a=Et.decodeProtectedHeader(t).prompt,r=await this.constructor.wrappingKey(this.tag,a),i=(await Et.decrypt(r,t)).json;return await Et.importJWK(i,{decryptingKey:"decrypt",signingKey:"sign"})}static async getSecret(e,t){return _t.getUserDeviceSecret(e,t)}}class Wt extends Tt{static collection="KeyRecovery"}class Ct extends Tt{static collection="Device"}const Ut=new Bt({name:Ct.collection});class Rt extends _t{static collection="Team";static signForStorage({message:e,tag:t,...a}){return this.sign(e,{team:t,...a})}static async wrap(e,t){let{decryptingKey:a,signingKey:r}=e,i={decryptingKey:a,signingKey:r},n={};return await Promise.all(t.map((e=>_t.encryptingKey(e).then((t=>n[e]=t))))),await Et.wrapKey(i,n)}async unwrap(e){let{recipients:t}=e.json,a=this.memberTags=t.map((e=>e.header.kid)),r=await this.constructor.ensure1(a),i=await r.decrypt(e.json);return await Et.importJWK(i.json)}async changeMembership({add:e=[],remove:t=[]}={}){let{memberTags:a}=this,r=a.concat(e).filter((e=>!t.includes(e)));await this.constructor.persist(this.tag,this,r,Date.now(),a),this.memberTags=r,this.constructor.clear(this.tag)}}var Jt={name:"@ki1r0y/distributed-security",version:"1.2.2"};const{name:Dt,version:Ot}=Jt,It={get KeySet(){return _t},set Storage(e){_t.Storage=e},get Storage(){return _t.Storage},set getUserDeviceSecret(e){_t.getUserDeviceSecret=e},get getUserDeviceSecret(){return _t.getUserDeviceSecret},ready:{name:Dt,version:Ot,origin:_t.Storage.origin},async encrypt(e,...t){let a={},r=this.canonicalizeParameters(t,a),i=await _t.produceKey(r,(e=>_t.encryptingKey(e)),a);return Et.encrypt(i,e,a)},async decrypt(e,...t){let a={},[r]=this.canonicalizeParameters(t,a,e),{recovery:i,...n}=a;return(await _t.ensure(r,{recovery:i})).decrypt(e,n)},async sign(e,...t){let a={},r=this.canonicalizeParameters(t,a);return _t.sign(e,{tags:r,...a})},async verify(e,...t){let a={},r=this.canonicalizeParameters(t,a,e);return _t.verify(e,r,a)},async create(...e){if(!e.length)return await Ct.create();let t=e[0].prompt;return t?await Wt.create(t):await Rt.create(e)},changeMembership:async({tag:e,recovery:t=!1,...a})=>(await _t.ensure(e,{recovery:t,...a})).changeMembership(a),async destroy(e){"string"==typeof e&&(e={tag:e});let{tag:t,recovery:a=!0,...r}=e,i={recovery:a,...r};return(await _t.ensure(t,i)).destroy(i)},clear(e){_t.clear(e)},hashBuffer:Qe,hashText:et,encodeBase64url:tt,decodeBase64url:at,decodeClaims:rt,canonicalizeParameters(e,t,a){if(e.length>1||void 0!==e[0]?.length)return e;let{tags:r=[],contentType:i,time:n,...c}=e[0]||{},{team:s}=c;if(!r.length)if(e.length&&e[0].length)r=e;else if(a)if(a.signatures)r=a.signatures.map((e=>Et.decodeProtectedHeader(e).kid));else if(a.recipients)r=a.recipients.map((e=>e.header.kid));else{let e=Et.decodeProtectedHeader(a).kid;e&&(r=[e])}return s&&!r.includes(s)&&(r=[s,...r]),i&&(t.cty=i),n&&(t.iat=n),Object.assign(t,c),r}};let jt="secret",Mt=jt;async function $t(e){Mt="other",await e(),Mt=jt}function Lt(e,t=""){return t+Mt}async function Nt(e){const t=(new TextEncoder).encode(e),a=await c.subtle.digest("SHA-256",t),r=new Uint8Array(a),i=Array.from(r,(e=>String.fromCodePoint(e))).join("");return btoa(i).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}"undefined"!=typeof window&&Object.assign(window,{Security:ut,Krypto:vt,MultiKrypto:Et,Storage:e,LocalCollection:Bt}),describe("Distributed Security",(function(){let t=wt(),a=ut.Storage,r=ut.getUserDeviceSecret;beforeAll((function(){e.Security=ut,ut.Storage=e,ut.getUserDeviceSecret=Lt,It.Storage=e,It.getUserDeviceSecret=Lt})),afterAll((function(){ut.Storage=a,ut.getUserDeviceSecret=r})),describe("Krypto",(function(){bt(vt)})),describe("MultiKrypto",(function(){!function(e){const t=2e4,a=wt();describe("falls through to krypto with single keys",(function(){bt(e,ht)})),describe("multi-way keys",(function(){describe("multi-signature",(function(){let t,r;beforeAll((async function(){t=await e.generateSigningKey(),r=await e.generateSigningKey()})),it("is a multi-signature.",(async function(){let i={a:t.privateKey,b:r.privateKey},n={b:r.publicKey,a:t.publicKey},c=await e.sign(i,a),s=await e.verify(n,c);expect(s).toBeTruthy()})),it('can specify type:"multi" in the signing key for clarify.',(async function(){let i={a:t.privateKey,b:r.privateKey,type:"multi"},n={a:t.publicKey,b:r.publicKey},c=await e.sign(i,a),s=await e.verify(n,c);expect(s).toBeTruthy()})),it('can specify type:"multi" in the verifying key for clarify.',(async function(){let i={a:t.privateKey,b:r.privateKey},n={a:t.publicKey,b:r.publicKey,type:"multi"},c=await e.sign(i,a),s=await e.verify(n,c);expect(s).toBeTruthy()})),it("can specify iss, act, iat in the key, which will appear in the signature.",(async function(){let i=Date.now(),n={a:t.privateKey,b:r.privateKey},c={a:t.publicKey,b:r.publicKey},s=await e.sign(n,a,{iss:"a",act:"b",iat:i}),o=await e.verify(c,s);expect(o).toBeTruthy(),s.signatures.forEach((t=>{let a=e.decodeProtectedHeader(t);expect(a.iss).toBe("a"),expect(a.act).toBe("b"),expect(a.iat).toBe(i)}))})),it("can sign binary and it is recovery as binary from payload property of verfication.",(async function(){let a=new Uint8Array([1],[2],[3]),i=await e.sign({a:t.privateKey,b:r.privateKey},a),n=await e.verify({a:t.publicKey,b:r.publicKey},i);expect(n.payload).toEqual(a)})),it("can sign string type and it is recoverable as string from text property of verification.",(async function(){let a="a string",i=await e.sign({a:t.privateKey,b:r.privateKey},a),n=await e.verify({a:t.publicKey,b:r.publicKey},i);expect(n.text).toEqual(a),expect(n.payload).toEqual((new TextEncoder).encode(a))})),it("can sign a jsonable object and it is recovery as same from json property of result.",(async function(){let a={foo:"a string",bar:!1,baz:["a",2,null]},i=await e.sign({a:t.privateKey,b:r.privateKey},a),n=await e.verify({a:t.publicKey,b:r.publicKey},i);expect(n.json).toEqual(a),expect(n.payload).toEqual((new TextEncoder).encode(JSON.stringify(a)))})),it("can specify a specific cty that will pass through to verify.",(async function(){let a={foo:"a string",bar:!1,baz:["a",2,null]},i="application/foo+json",n=await e.sign({a:t.privateKey,b:r.privateKey},a,{cty:i}),c=await e.verify({a:t.publicKey,b:r.publicKey},n);expect(c.json).toEqual(a),expect(c.protectedHeader.cty).toBe(i),expect(c.payload).toEqual((new TextEncoder).encode(JSON.stringify(a)))})),it("fails verification if the signature is mislabeled.",(async function(){let i={a:r.privateKey,b:t.privateKey},n={a:t.publicKey,b:r.publicKey},c=await e.sign(i,a),s=await e.verify(n,c);expect(s).toBeUndefined()})),it("gives enough information that we can tell if a verifying sub key is missing.",(async function(){let i={a:t.privateKey,b:r.privateKey},n={b:r.publicKey},c=await e.sign(i,a),s=await e.verify(n,c);expect(s.payload).toBeTruthy(),expect(s.text).toBe(a),expect(s.signers[1].payload).toBeTruthy(),expect(s.signers[0].payload).toBeUndefined()})),it("gives enough information that we can tell if a signature sub key is missing.",(async function(){let i={a:t.privateKey},n={a:t.publicKey,b:r.publicKey},c=await e.sign(i,a),s=await e.verify(n,c);expect(s.payload).toBeTruthy(),expect(s.text).toBe(a),expect(s.signers.length).toBe(1),expect(s.signers[0].protectedHeader.kid).toBe("a"),expect(s.signers[0].payload).toBeTruthy()}))})),describe("multi-way encryption",(function(){let r,i,n,c,s,o,d="shh!";beforeAll((async function(){n=await e.generateSymmetricKey(),i=await e.generateEncryptingKey(),r=await e.encrypt({a:n,b:i.publicKey,c:d},a),c=r.recipients;let t=await e.generateEncryptingKey();s={a:i.publicKey,b:t.publicKey},o={a:i.privateKey,b:t.privateKey}}),t),it("works with symmetric members.",(async function(){let t=await e.decrypt({a:n},r);expect(t.text).toBe(a),expect(c[0].header.kid).toBe("a"),expect(c[0].header.alg).toBe("A256GCMKW")})),it("works with keypair members.",(async function(){let t=await e.decrypt({b:i.privateKey},r);expect(t.text).toBe(a),expect(c[1].header.kid).toBe("b"),expect(c[1].header.alg).toBe("RSA-OAEP-256")})),it("works with secret text members.",(async function(){let t=await e.decrypt({c:d},r);expect(t.text).toBe(a),expect(c[2].header.kid).toBe("c"),expect(c[2].header.alg).toBe("PBES2-HS512+A256KW")})),it("handles binary, and decrypts as same.",(async function(){let t=new Uint8Array([21,31]),a=await e.encrypt(s,t),r=await e.decrypt(o,a),i=e.decodeProtectedHeader(a);expect(i.cty).toBeUndefined(),mt(r,t)})),it("handles text, and decrypts as same.",(async function(){let t=await e.encrypt(s,a),r=await e.decrypt(o,t),i=e.decodeProtectedHeader(t);expect(i.cty).toBe("text/plain"),expect(r.text).toBe(a)})),it("handles json, and decrypts as same.",(async function(){let t={foo:"bar"},a=await e.encrypt(s,t),r=e.decodeProtectedHeader(a),i=await e.decrypt(o,a);expect(r.cty).toBe("json"),expect(i.json).toEqual(t)})),it("Uses specified headers if supplied, including cty.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await e.encrypt(s,r,{cty:t,iat:a,foo:17}),n=await e.decrypt(o,i),c=e.decodeProtectedHeader(i);expect(c.cty).toBe(t),expect(c.iat).toBe(a),expect(c.foo).toBe(17),expect(n.text).toBe(r)})),it("produces undefined for wrong symmetric key.",(async function(){let t=await e.generateSymmetricKey(),a=await e.decrypt({a:t},r);expect(a).toBeUndefined()})),it("produces undefined for wrong keypair.",(async function(){let t=await e.generateEncryptingKey(),a=await e.decrypt({b:t.privateKey},r);expect(a).toBeUndefined()})),it("produces undefined for wrong secret text.",(async function(){let t=await e.decrypt({c:"shh! "},r);expect(t).toBeUndefined()})),it("produces undefined for mislabeled key.",(async function(){let t=await e.decrypt({a:d},r);expect(t).toBeUndefined()}))}))})),describe("export/wrap",(function(){let r,i;beforeAll((async function(){let t=await e.generateEncryptingKey(),a=await e.generateEncryptingKey(),n=await e.generateEncryptingKey();r={a:t.publicKey,b:a.publicKey},i={c:n.privateKey,b:a.privateKey}}),t),it("exports homogenous member.",(async function(){let t=await e.exportJWK(r),n=await e.importJWK(t),c=await e.encrypt(n,a),s=await e.decrypt(i,c);expect(t.keys[0].kid).toBe("a"),expect(t.keys[1].kid).toBe("b"),expect(s.text).toBe(a)})),it("export heterogenous members.",(async function(){let t=await e.generateEncryptingKey(),a=await e.generateSigningKey(),r=await e.exportJWK({myDecrypt:t.privateKey,mySign:a.privateKey}),i=await e.importJWK(r),n="a smaller message for asymmetric encryption",c=await e.encrypt(t.publicKey,n),s=await e.decrypt(i.myDecrypt,c),o=await e.sign(i.mySign,n);expect(r.keys[0].kid).toBe("myDecrypt"),expect(r.keys[1].kid).toBe("mySign"),expect(s.text).toBe(n),expect(await e.verify(a.publicKey,o)).toBeTruthy()}),1e4),it("can wrap/unwrap a simple key.",(async function(){let t=await e.generateSymmetricKey(),n=await e.wrapKey(t,r),c=await e.unwrapKey(n,i),s=await e.encrypt(c,a),o=await e.decrypt(t,s);expect(o.text).toBe(a)})),it("can be wrapped/unwrapped by a symmetric key with homogenous members.",(async function(){let t=await e.generateSymmetricKey(),n=await e.wrapKey(r,t),c=await e.unwrapKey(n,t),s=await e.encrypt(c,a),o=await e.decrypt(i,s);expect(o.text).toBe(a)})),it("can wrap/unwrap a symmetric multikey with homogenous members.",(async function(){let t={x:await e.generateSymmetricKey(),y:await e.generateSymmetricKey()},a=await e.wrapKey(t,r),n=await e.unwrapKey(a,i),c=wt(),s=await e.encrypt(n,c),o=await e.decrypt(t,s);expect(o.text).toBe(c)})),it("can wrap/unwrap a heterogeneous multikey.",(async function(){let t=await e.generateEncryptingKey(),a=await e.generateSigningKey(),n=await e.wrapKey({myDecrypt:t.privateKey,mySign:a.privateKey},r),c=await e.unwrapKey(n,i),s="a shorter message",o=await e.encrypt(t.publicKey,s),d=await e.decrypt(c.myDecrypt,o),y=await e.sign(c.mySign,s);expect(d.text).toBe(s),expect(await e.verify(a.publicKey,y)).toBeTruthy()}),t)}))}(Et)})),describe("Security",(function(){const a=6e4;async function r(e){let t,a,r={},[i,n,c]=await Promise.all([e.create(),e.create({prompt:"what?"}),e.create({prompt:"nope!"})]);await $t((async function(){t=await e.create(),a=await e.create(t)}));let s=await e.create(i),[o,d]=await Promise.all([e.create(s,a),e.create(a,s)]);return r.device=i,r.otherDevice=t,r.recovery=n,r.otherRecovery=c,r.user=s,r.otherUser=a,r.team=o,r.otherTeam=d,r}async function i(e,t){await e.destroy(t.otherTeam),await e.destroy(t.team),await e.destroy(t.user),await e.destroy(t.device),await e.destroy(t.recovery),await e.destroy(t.otherRecovery),await $t((async function(){await e.destroy(t.otherUser),await e.destroy(t.otherDevice)}))}describe("internal machinery",(function(){let n;function c(a,r,i={}){describe(a,(function(){let a,c;beforeAll((async function(){c=n[r],a=await _t.ensure(c,{recovery:!0})})),it("tag is exported verify key, and sign() pairs with it.",(async function(){let e=await Et.importRaw(c),a=await Et.exportRaw(e);expect(typeof c).toBe("string"),expect(a).toBe(c);let r=await _t.ensure(c,{recovery:!0}),n=await _t.sign(t,{tags:[c],signingKey:r.signingKey,...i}),s=await Et.verify(e,n);gt(n),expect(s).toBeTruthy()})),it("public encryption tag can be retrieved externally, and vault.decrypt() pairs with it.",(async function(){let r=a.tag,n=await e.retrieve("EncryptionKey",r),c=await ut.verify(n,r),s=await Et.importJWK(c.json),o=await Et.encrypt(s,t),d=await a.decrypt(o,i);expect(d.text).toBe(t)}))}))}beforeAll((async function(){n=await r(It)}),a),afterAll((async function(){await i(It,n)}),a),c("DeviceKeySet","device"),c("RecoveryKeySet","recovery",{recovery:!0}),c("TeamKeySet","user"),describe("local store",(function(){var e;beforeAll((async function(){e=new Bt({name:"testFoo"}),await new Promise((e=>setTimeout(e,2e3)))})),afterAll((async function(){await e.destroy()})),it("can remove without existing.",(async function(){expect(await e.delete("nonExistant")).toBe(!1)})),it("retrieves and can remove what is stored.",(async function(){let t="x",a="hello";expect(await e.put(t,a)).toBeUndefined(),expect(await e.get(t)).toBe(a),expect(await e.delete(t)).toBe(!0),expect(await e.get(t)).toBeUndefined()})),it("can write a lot without getting jumbled.",(async function(){let t,a,r,i=1e3,n=[];for(let e=0;e<i;e++)n.push("y"+e);t=Date.now();let c=await Promise.all(n.map(((t,a)=>e.put(t,a.toString()))));a=Date.now()-t,r=a/i,expect(r).toBeLessThan(60),c.forEach((e=>expect(e).toBeUndefined())),t=Date.now();let s=await Promise.all(n.map((t=>e.get(t))));a=Date.now()-t,r=a/i,expect(r).toBeLessThan(3),s.forEach(((e,t)=>expect(e).toBe(t.toString()))),t=Date.now();let o=await Promise.all(n.map((t=>e.delete(t))));a=Date.now()-t,r=a/i,expect(r).toBeLessThan(8),o.forEach((e=>expect(e).toBe(!0))),t=Date.now();let d=await Promise.all(n.map((t=>e.get(t))));a=Date.now()-t,r=a/i,expect(r).toBeLessThan(.1),d.forEach((e=>expect(e).toBeUndefined()))}),15e5)}))})),describe("API",(function(){let n;function c(e,a,r,i,c={}){describe(e,(function(){let e,s;beforeAll((function(){e=n[a],s=n[r]})),describe("signature",(function(){describe("of one tag",(function(){it("can sign and be verified.",(async function(){let a=await ut.sign(t,{tags:[e],...c});gt(a),expect(await ut.verify(a,e)).toBeTruthy()})),it("can be verified with the tag included in the signature.",(async function(){let a=await ut.sign(t,{tags:[e],...c});expect(await ut.verify(a)).toBeTruthy()})),it("cannot sign for a different key.",(async function(){let a=await ut.sign(t,{tags:[s],...c});expect(await ut.verify(a,e)).toBeUndefined()})),it("cannot sign with an unowned key.",(async function(){expect(await ut.sign("something",{tags:n[i],...c}).catch((()=>{}))).toBeUndefined()})),it("distinguishes between correctly signing false and key failure.",(async function(){let t=await ut.sign(!1,{tags:[e],...c}),a=await ut.verify(t,e);expect(a.json).toBe(!1)})),it("can sign text and produce verified result with text property.",(async function(){let a=await ut.sign(t,{tags:[e],...c}),r=await ut.verify(a,e);gt(a),expect(r.text).toBe(t)})),it("can sign json and produce verified result with json property.",(async function(){let t={x:1,y:["abc",null,!1]},a=await ut.sign(t,{tags:[e],...c}),r=await ut.verify(a,e);gt(a),expect(r.json).toEqual(t)})),it("can sign binary and produce verified result with payload property.",(async function(){let t=new Uint8Array([1,2,3]),a=await ut.sign(t,{tags:[e],...c}),r=await ut.verify(a,e);gt(a),expect(r.payload).toEqual(t)})),it("uses contentType and time if supplied.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await ut.sign(r,{tags:[e],contentType:t,time:a,...c}),n=await ut.verify(i,e);gt(i),expect(n.text).toEqual(r),expect(n.protectedHeader.cty).toBe(t),expect(n.protectedHeader.iat).toBe(a)})),describe('includes payload hash as "sub" header',(function(){it("by default.",(async function(){let t=await ut.sign("foo",{tags:[e],...c}),a=await ut.verify(t);expect(a.protectedHeader.sub).toBe(await Nt("foo"))})),it("unless specified otherwise.",(async function(){let t=await ut.sign("foo",{subject:"bar",tags:[e],...c}),a=await ut.verify(t),r=await ut.sign("foo",{subject:!1,tags:[e],...c}),i=await ut.verify(r);expect(a.protectedHeader.sub).toBe("bar"),expect(i.protectedHeader.sub).toBeUndefined()}))}))})),describe("of multiple tags",(function(){it("can sign and be verified.",(async function(){let a=await ut.sign(t,{tags:[e,s],...c}),r=await ut.verify(a,s,e);expect(r).toBeTruthy(),expect(r.signers[0].payload).toBeTruthy(),expect(r.signers[1].payload).toBeTruthy()})),it("does not attempt to verify unenumerated tags if any are explicit",(async function(){let a=await ut.sign(t,{tags:[e,s],...c}),r=await ut.verify(a,s);expect(r).toBeTruthy(),expect(r.signers[0].payload).toBeFalsy(),expect(r.signers[1].payload).toBeTruthy()})),it("can be verified with the tag included in the signature.",(async function(){let a=await ut.sign(t,{tags:[e,s],...c}),r=await ut.verify(a);expect(r).toBeTruthy(),expect(r.signers[0].payload).toBeTruthy(),expect(r.signers[1].payload).toBeTruthy()})),describe("bad verification",(function(){let a;beforeAll((async function(){a=await ut.create()}),1e4),afterAll((async function(){await ut.destroy(a)})),describe("when mixing single and multi-tags",(function(){it("fails with extra signing tag.",(async function(){let a=await ut.sign(t,{tags:[s],...c});expect(await ut.verify(a,e)).toBeUndefined()})),it("fails with extra verifying.",(async function(){let a=await ut.sign(t,{tags:[e],...c});expect(await ut.verify(a,e,s)).toBeUndefined()}))})),describe("when mixing multi-tag lengths",(function(){it("fails with mismatched signing tag.",(async function(){let r=await ut.sign(t,{tags:[s,a],...c}),i=await ut.verify(r,e,a);expect(i).toBeUndefined()})),it("fails with extra verifying tag.",(async function(){let r=await ut.sign(t,{tags:[e,a],...c});expect(await ut.verify(r,e,s,a)).toBeUndefined()}))}))})),it("distinguishes between correctly signing false and key failure.",(async function(){let t=await ut.sign(!1,{tags:[e,s],...c}),a=await ut.verify(t,e,s);expect(a.json).toBe(!1)})),it("can sign text and produce verified result with text property.",(async function(){let a=await ut.sign(t,{tags:[e,s],...c}),r=await ut.verify(a,e,s);expect(r.text).toBe(t)})),it("can sign json and produce verified result with json property.",(async function(){let t={x:1,y:["abc",null,!1]},a=await ut.sign(t,{tags:[e,s],...c}),r=await ut.verify(a,e,s);expect(r.json).toEqual(t)})),it("can sign binary and produce verified result with payload property.",(async function(){let t=new Uint8Array([1,2,3]),a=await ut.sign(t,{tags:[e,s],...c}),r=await ut.verify(a,e,s);expect(r.payload).toEqual(t)})),it("uses contentType and time if supplied.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await ut.sign(r,{tags:[e,s],contentType:t,time:a,...c}),n=await ut.verify(i,e,s);expect(n.text).toEqual(r),expect(n.protectedHeader.cty).toBe(t),expect(n.protectedHeader.iat).toBe(a)})),describe('includes payload hash as "sub" header',(function(){it("by default.",(async function(){let t=await ut.sign("foo",{tags:[e,s],...c}),a=await ut.verify(t);expect(a.protectedHeader.sub).toBe(await Nt("foo"))})),it("unless specified otherwise.",(async function(){let t=await ut.sign("foo",{tags:[e,s],subject:"bar",...c}),a=await ut.verify(t),r=await ut.sign("foo",{tags:[e,s],subject:!1,...c}),i=await ut.verify(r);expect(a.protectedHeader.sub).toBe("bar"),expect(i.protectedHeader.sub).toBeUndefined()}))}))}))})),describe("encryption",(function(){describe("with a single tag",(function(){it("can decrypt what is encrypted for it.",(async function(){let a=await ut.encrypt(t,e),r=await ut.decrypt(a,{tags:[e],...c});gt(a),expect(r.text).toBe(t)})),it("can be decrypted using the tag included in the encryption.",(async function(){let a=await ut.encrypt(t,e),r=await ut.decrypt(a,c);expect(r.text).toBe(t)})),it("is url-safe base64.",(async function(){gt(await ut.encrypt(t,e))})),it("specifies kid.",(async function(){let a=vt.decodeProtectedHeader(await ut.encrypt(t,e));expect(a.kid).toBe(e)})),it("cannot decrypt what is encrypted for a different key.",(async function(){let t=wt(446),a=await ut.encrypt(t,s),r=await ut.decrypt(a,{tags:[e],...c}).catch((e=>e.message));expect(r.toLowerCase()).toContain("operation")})),it("handles binary, and decrypts as same.",(async function(){let t=new Uint8Array([21,31]),a=await ut.encrypt(t,e),r=await ut.decrypt(a,{tags:[e],...c}),i=vt.decodeProtectedHeader(a);expect(i.cty).toBeUndefined(),mt(r,t)})),it("handles text, and decrypts as same.",(async function(){let a=await ut.encrypt(t,e),r=await ut.decrypt(a,{tags:[e],...c}),i=vt.decodeProtectedHeader(a);expect(i.cty).toBe("text/plain"),expect(r.text).toBe(t)})),it("handles json, and decrypts as same.",(async function(){let t={foo:"bar"},a=await ut.encrypt(t,e),r=await ut.decrypt(a,{tags:[e],...c}),i=vt.decodeProtectedHeader(a);expect(i.cty).toBe("json"),expect(r.json).toEqual(t)})),it("uses contentType and time if supplied.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await ut.encrypt(r,{tags:[e],contentType:t,time:a}),n=await ut.decrypt(i,{tags:[e],...c}),s=vt.decodeProtectedHeader(i);expect(s.cty).toBe(t),expect(s.iat).toBe(a),expect(n.text).toBe(r)}))})),describe("with multiple tags",(function(){it("can be decrypted by any one of them.",(async function(){let a=await ut.encrypt(t,e,s),r=await ut.decrypt(a,{tags:[e],...c}),i=await ut.decrypt(a,{tags:[s],...c});expect(r.text).toBe(t),expect(i.text).toBe(t)})),it("can be decrypted using the tag included in the encryption.",(async function(){let a=await ut.encrypt(t,e,s),r=await ut.decrypt(a,c);expect(r.text).toBe(t)})),it("can be be made with tags you do not own.",(async function(){let a=await ut.encrypt(t,e,n[i],s),r=await ut.decrypt(a,{tags:[e],...c}),o=await ut.decrypt(a,{tags:[s],...c});expect(r.text).toBe(t),expect(o.text).toBe(t)})),it("cannot be decrypted by a different tag.",(async function(){let a=await ut.encrypt(t,e,n[i]),r=await ut.decrypt(a,{tags:[s],...c});expect(r).toBeUndefined()})),it("specifies kid in each recipient.",(async function(){let a=(await ut.encrypt(t,e,s)).recipients;expect(a.length).toBe(2),expect(a[0].header.kid).toBe(e),expect(a[1].header.kid).toBe(s)})),it("handles binary, and decrypts as same.",(async function(){let t=new Uint8Array([21,31]),a=await ut.encrypt(t,e,s),r=await ut.decrypt(a,{tags:[e],...c}),i=vt.decodeProtectedHeader(a);expect(i.cty).toBeUndefined(),mt(r,t)})),it("handles text, and decrypts as same.",(async function(){let a=await ut.encrypt(t,e,s),r=await ut.decrypt(a,{tags:[e],...c}),i=vt.decodeProtectedHeader(a);expect(i.cty).toBe("text/plain"),expect(r.text).toBe(t)})),it("handles json, and decrypts as same.",(async function(){let t={foo:"bar"},a=await ut.encrypt(t,e,s),r=await ut.decrypt(a,{tags:[e],...c}),i=vt.decodeProtectedHeader(a);expect(i.cty).toBe("json"),expect(r.json).toEqual(t)})),it("uses contentType and time if supplied.",(async function(){let t="text/html",a=Date.now(),r="<something else>",i=await ut.encrypt(r,{tags:[e,s],contentType:t,time:a}),n=await ut.decrypt(i,{tags:[e],...c}),o=vt.decodeProtectedHeader(i);expect(o.cty).toBe(t),expect(o.iat).toBe(a),expect(n.text).toBe(r)}))}))}))}))}beforeAll((async function(){console.log(await ut.ready),n=await r(ut)}),a),afterAll((async function(){await i(ut,n)}),a),c("DeviceKeySet","device","user","otherDevice"),c("RecoveryKeySet","recovery","otherRecovery","otherDevice",{recovery:!0}),c("User TeamKeySet","user","device","otherUser"),c("Team TeamKeySet","team","otherTeam","otherUser"),describe("storage",(function(){it("will only let a current member write new keys.",(async function(){let t=await ut.create(),a=n.team,r=await e.retrieve("Team",a),i=await ut.verify(r),c=i?.json;if(!i)throw new Error(`Unable to verify '${r?.text}'`);function s(){return ut.sign(c,{team:a,member:t,time:Date.now()})}await ut.changeMembership({tag:a,add:[t]});let o=await s();expect(await e.store("Team",n.team,o)).toBeDefined(),await ut.changeMembership({tag:a,remove:[t]});let d=await s();expect(await e.store("Team",a,d).catch((()=>"failed"))).toBe("failed"),expect(await e.store("Team",a,o).catch((()=>"failed"))).toBe("failed"),expect(await e.store("Team",a,r).catch((()=>"failed"))).toBe("failed"),await ut.destroy(t)})),it("will only let a current member write new public encryption key.",(async function(){let t=await ut.create(),a=n.team,r=await e.retrieve("EncryptionKey",a),i=(await ut.verify(r)).json;function c(){return ut.sign(i,{team:a,member:t,time:Date.now()})}await ut.changeMembership({tag:a,add:[t]});let s=await c();expect(await e.store("EncryptionKey",n.team,s)).toBeDefined(),await ut.changeMembership({tag:a,remove:[t]});let o=await c();expect(await e.store("EncryptionKey",a,o).catch((()=>"failed"))).toBe("failed"),expect(await e.store("EncryptionKey",a,s).catch((()=>"failed"))).toBe("failed"),expect(await e.store("EncryptionKey",a,r).catch((()=>"failed"))).toBe("failed"),await ut.destroy(t)}),1e4),it("will only let owner of a device write new public device encryption key.",(async function(){let t=await ut.create(),a=await ut.create(),r=await e.retrieve("EncryptionKey",t),i=(await ut.verify(r)).json;function n(e){return ut.sign(i,{tags:[e],time:Date.now()})}let c=await n(t);expect(await e.store("EncryptionKey",t,c)).toBeDefined();let s=await n(a);expect(await e.store("EncryptionKey",t,s).catch((()=>"failed"))).toBe("failed"),expect(await e.store("EncryptionKey",t,c)).toBeDefined(),expect(await e.store("EncryptionKey",t,r).catch((()=>"failed"))).toBe("failed"),await ut.destroy(t),await ut.destroy(a)}),1e4)})),describe("auditable signatures",(function(){describe("by an explicit member",(function(){let e,a;beforeAll((async function(){e=await ut.sign(t,{team:n.team,member:n.user}),a=await ut.verify(e,n.team,n.user)})),it("recognizes a team with a member.",(async function(){expect(a).toBeTruthy(),expect(a.text).toBe(t)})),it("defines iss.",(function(){expect(a.protectedHeader.iss).toBe(n.team)})),it("defines act.",(function(){expect(a.protectedHeader.act).toBe(n.user)}))})),describe("automatically supplies a valid member",(function(){it("if you have access",(async function(){let e=await ut.sign(t,{team:n.team}),a=vt.decodeProtectedHeader(e.signatures[0]).act,r=await ut.verify(e,n.team,a);expect(r).toBeTruthy(),expect(a).toBeTruthy(),expect(r.protectedHeader.act).toBe(a),expect(r.protectedHeader.iat).toBeTruthy()}))})),describe("with a valid user who is not a member",(function(){let e;beforeAll((async function(){e=await ut.create(n.device)})),afterAll((async function(){await ut.destroy(e)})),it("verifies as an ordinary dual signature.",(async function(){let a=await ut.sign(t,n.team,e),r=await ut.verify(a,n.team,e);expect(r.text).toBe(t),expect(r.protectedHeader.iss).toBeUndefined(),expect(r.protectedHeader.act).toBeUndefined()}),1e4),it("does not verify as a dual signature specifying team and member.",(async function(){let a=await ut.sign(t,{team:n.team,member:e}),r=await ut.verify(a,n.team,e);expect(r).toBeUndefined()}))}),1e4),describe("with a past member",(function(){let e,t,a;beforeAll((async function(){a=Date.now()-1,e=await ut.create(),await ut.changeMembership({tag:n.team,add:[e]}),t=await ut.sign("message",{team:n.team,member:e,time:a}),await ut.changeMembership({tag:n.team,remove:[e]})})),afterAll((async function(){await ut.destroy(e)}),1e4),it("fails by default.",(async function(){let a=await ut.verify(t,e);expect(a).toBeUndefined()})),it("contains act in signature but verifies if we tell it not to check membership.",(async function(){let a=await ut.verify(t,{team:n.team,member:!1});expect(a).toBeTruthy(),expect(a.text).toBe("message"),expect(a.protectedHeader.act).toBe(e),expect(a.protectedHeader.iat).toBeTruthy()})),it('fails if we tell it to check notBefore:"team", even if we tell it not to check membership.',(async function(){let e=await ut.verify(t,{team:n.team,member:!1,notBefore:"team"});expect(e).toBeUndefined()}))}))})),describe("miscellaneous",(function(){it("can safely be used when a device is removed, but not after being entirely destroyed.",(async function(){let[e,a]=await Promise.all([ut.create(),ut.create()]),r=await ut.create(e,a),i=await ut.create(r),n=await ut.encrypt(t,i),c=await ut.decrypt(n,i);expect(c.text).toBe(t),c=await ut.decrypt(n,i),await ut.changeMembership({tag:r,remove:[e]}),expect(c.text).toBe(t),await ut.changeMembership({tag:r,add:[e]}),c=await ut.decrypt(n,i),expect(c.text).toBe(t),await ut.destroy(a),c=await ut.decrypt(n,i),expect(c.text).toBe(t),await ut.destroy({tag:i,recursiveMembers:!0});let s=await ut.decrypt(n,i).then((()=>null),(e=>e.message));expect(s).toBeTruthy()}),a),it("device is useable as soon as it resolves.",(async function(){let e=await ut.create();expect(await ut.sign("anything",e)).toBeTruthy(),await ut.destroy(e)}),1e4),it("team is useable as soon as it resolves.",(async function(){let e=await ut.create(n.device);expect(await ut.sign("anything",e)).toBeTruthy(),await ut.destroy(e)})),it("allows recovery prompts that contain dot (and confirm that a team can have a single recovery tag as member).",(async function(){let e=await ut.create({prompt:"foo.bar"}),t=await ut.create(e),a="red.white",r=await ut.encrypt(a,t),i=await ut.decrypt(r,t),n=await ut.sign(a,t),c=await ut.verify(n,t);expect(i.text).toBe(a),expect(c).toBeTruthy(),await ut.destroy({tag:t,recursiveMembers:!0})}),1e4),it("supports rotation.",(async function(){let e=await ut.create(n.device),t=await ut.create(e),a=await ut.sign("some purchase order",{team:t,member:e}),r=await ut.encrypt("the other set of books",t);expect(await ut.verify(a)).toBeTruthy(),expect(await ut.verify(a,{team:t,member:!1})).toBeTruthy(),expect(await ut.decrypt(r)).toBeTruthy();let i=await ut.create(n.device),c=await ut.create(n.device);await ut.changeMembership({tag:t,remove:[e],add:[i,c]}),await ut.destroy(e),expect(await ut.sign("bogus PO",{team:t,member:e}).catch((()=>{}))).toBeUndefined();let s=await ut.sign("new PO",{team:t,member:i}),o=await ut.sign("new PO",{team:t,member:c});expect(await ut.verify(s)).toBeTruthy(),expect(await ut.verify(o)).toBeTruthy(),expect(await ut.verify(a).catch((()=>{}))).toBeUndefined(),expect(await ut.verify(a,{team:t,member:!1})).toBeTruthy(),expect(await ut.decrypt(r)).toBeTruthy();let d=await ut.create(i);await ut.destroy(t),expect(await ut.sign("bogus PO",{team:t,member:i}).catch((()=>{}))).toBeUndefined(),expect(await ut.sign("new new PO",{team:d,member:i})).toBeTruthy(),expect(await ut.verify(a,{team:t,member:!1})).toBeTruthy(),expect(await ut.verify(s)).toBeTruthy(),expect(await ut.verify(o)).toBeTruthy(),expect(await ut.decrypt(r).catch((()=>{}))).toBeUndefined()}),15e3)}))}))}))}));
